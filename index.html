<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>终极塔防</title>
  <!-- Tailwind CSS v3 -->
  <script src="https://cdn.tailwindcss.com"></script>
  <!-- Font Awesome -->
  <link href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css" rel="stylesheet">
  <script>
    // 音效管理
    const soundManager = {
      // 音效开关状态
      musicEnabled: true,
      sfxEnabled: true,
      
      // 音量设置
      musicVolume: 0.5,
      sfxVolume: 0.7,
      
      // 初始化音效
      init() {
        // 设置初始音量
        this.setMusicVolume(this.musicVolume);
        this.setSfxVolume(this.sfxVolume);
        
        // 尝试播放背景音乐（需要用户交互）
        document.addEventListener('click', this.tryPlayBackgroundMusic.bind(this), { once: true });
      },
      
      // 尝试播放背景音乐
      tryPlayBackgroundMusic() {
        if (this.musicEnabled) {
          const bgMusic = document.getElementById('bgMusic');
          bgMusic.play().catch(e => {
            console.log('背景音乐播放失败，需要用户交互:', e);
          });
        }
      },
      
      // 播放音效
      playSound(id) {
        if (!this.sfxEnabled) return;
        
        const sound = document.getElementById(id);
        if (sound) {
          // 克隆音效避免播放中断
          const soundClone = sound.cloneNode();
          soundClone.volume = this.sfxVolume;
          soundClone.play().catch(e => {
            console.log(`音效播放失败: ${id}`, e);
          });
        }
      },
      
      // 播放背景音乐
      playBackgroundMusic() {
        if (!this.musicEnabled) return;
        
        const bgMusic = document.getElementById('bgMusic');
        if (bgMusic) {
          bgMusic.volume = this.musicVolume;
          bgMusic.play().catch(e => {
            console.log('背景音乐播放失败:', e);
          });
        }
      },
      
      // 暂停背景音乐
      pauseBackgroundMusic() {
        const bgMusic = document.getElementById('bgMusic');
        if (bgMusic) {
          bgMusic.pause();
        }
      },
      
      // 设置音乐音量
      setMusicVolume(volume) {
        this.musicVolume = volume;
        const bgMusic = document.getElementById('bgMusic');
        if (bgMusic) {
          bgMusic.volume = volume;
        }
      },
      
      // 设置音效音量
      setSfxVolume(volume) {
        this.sfxVolume = volume;
      },
      
      // 切换音乐开关
      toggleMusic() {
        this.musicEnabled = !this.musicEnabled;
        if (this.musicEnabled) {
          this.playBackgroundMusic();
        } else {
          this.pauseBackgroundMusic();
        }
        return this.musicEnabled;
      },
      
      // 切换音效开关
      toggleSfx() {
        this.sfxEnabled = !this.sfxEnabled;
        return this.sfxEnabled;
      }
    };
    
    tailwind.config = {
      theme: {
        extend: {
          colors: {
            primary: '#3B82F6',
            secondary: '#10B981',
            accent: '#F59E0B',
            danger: '#EF4444',
            dark: '#1F2937',
            light: '#F3F4F6'
          },
          fontFamily: {
            sans: ['Inter', 'system-ui', 'sans-serif'],
          },
          animation: {
            'pulse-slow': 'pulse 3s cubic-bezier(0.4, 0, 0.6, 1) infinite',
          }
        }
      }
    }
  </script>
  <style type="text/tailwindcss">
    /* 音量控制样式 */
    .volume-control {
      display: flex;
      align-items: center;
      gap: 8px;
      color: white;
    }
    
    .volume-slider {
      width: 100px;
      height: 4px;
      background: rgba(255, 255, 255, 0.3);
      border-radius: 2px;
      outline: none;
      -webkit-appearance: none;
    }
    
    .volume-slider::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 12px;
      height: 12px;
      border-radius: 50%;
      background: white;
      cursor: pointer;
    }
    
    .audio-toggle {
      cursor: pointer;
      transition: all 0.2s ease;
    }
    
    .audio-toggle:hover {
      transform: scale(1.1);
    }
    
    .audio-toggle.muted {
      opacity: 0.5;
    }
    
    @layer utilities {
      .text-shadow {
        text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
      }
      .glass {
        background: rgba(255, 255, 255, 0.2);
        backdrop-filter: blur(8px);
        -webkit-backdrop-filter: blur(8px);
        border: 1px solid rgba(255, 255, 255, 0.3);
      }
      .btn-3d {
        transform: translateY(-4px);
        box-shadow: 0 4px 0 0 rgba(0, 0, 0, 0.3);
        transition: all 0.1s;
      }
      .btn-3d:active {
        transform: translateY(0);
        box-shadow: 0 0 0 0 rgba(0, 0, 0, 0.3);
      }
    }
    
    /* 任务系统样式 */
    .mission-screen .mission-content {
      background: rgba(17, 24, 39, 0.95);
      border: 2px solid #3B82F6;
      border-radius: 10px;
      padding: 20px;
      max-width: 600px;
      max-height: 80vh;
      overflow-y: auto;
    }
    
    .mission-screen .mission-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 20px;
    }
    
    .mission-screen .mission-list {
      display: flex;
      flex-direction: column;
      gap: 15px;
    }
    
    .mission-screen .mission-item {
      background: rgba(59, 130, 246, 0.1);
      border: 1px solid #3B82F6;
      border-radius: 8px;
      padding: 15px;
      transition: all 0.3s ease;
    }
    
    .mission-screen .mission-item.completed {
      background: rgba(16, 185, 129, 0.2);
      border-color: #10B981;
    }
    
    .mission-screen .mission-item:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(59, 130, 246, 0.3);
    }
    
    .mission-screen .mission-reward {
      margin-top: 10px;
      padding-top: 10px;
      border-top: 1px solid rgba(59, 130, 246, 0.3);
      color: #10B981;
    }
    
    /* 技能系统样式 */
    .skill-screen .skill-content {
      background: rgba(17, 24, 39, 0.95);
      border: 2px solid #8B5CF6;
      border-radius: 10px;
      padding: 20px;
      max-width: 600px;
      max-height: 80vh;
      overflow-y: auto;
    }
    
    .skill-screen .skill-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 20px;
    }
    
    .skill-screen .skill-points {
      font-size: 18px;
      font-weight: bold;
      color: #8B5CF6;
      margin-bottom: 20px;
      text-align: center;
    }
    
    .skill-screen .skill-list {
      display: flex;
      flex-direction: column;
      gap: 15px;
    }
    
    .skill-screen .skill-item {
      background: rgba(139, 92, 246, 0.1);
      border: 1px solid #8B5CF6;
      border-radius: 8px;
      padding: 15px;
      transition: all 0.3s ease;
    }
    
    .skill-screen .skill-item.locked {
      opacity: 0.5;
      border-color: #6B7280;
    }
    
    .skill-screen .skill-item:hover:not(.locked) {
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(139, 92, 246, 0.3);
    }
    
    .skill-screen .skill-level {
      margin-top: 10px;
      display: flex;
      align-items: center;
      gap: 10px;
    }
    
    .skill-screen .skill-button {
      background: #8B5CF6;
      color: white;
      border: none;
      padding: 8px 16px;
      border-radius: 5px;
      cursor: pointer;
      transition: all 0.3s ease;
    }
    
    .skill-screen .skill-button:hover:not(:disabled) {
      background: #7C3AED;
      transform: translateY(-1px);
    }
    
    .skill-screen .skill-button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
    
    /* 地图选择样式 */
    .map-select-screen .map-select-content {
      background: rgba(17, 24, 39, 0.95);
      border: 2px solid #F59E0B;
      border-radius: 10px;
      padding: 20px;
      max-width: 800px;
      max-height: 80vh;
      overflow-y: auto;
    }
    
    .map-select-screen .map-select-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 20px;
    }
    
    .map-select-screen .map-list {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
      gap: 20px;
    }
    
    .map-select-screen .map-item {
      background: rgba(245, 158, 11, 0.1);
      border: 1px solid #F59E0B;
      border-radius: 8px;
      padding: 20px;
      cursor: pointer;
      transition: all 0.3s ease;
    }
    
    .map-select-screen .map-item.locked {
      opacity: 0.5;
      border-color: #6B7280;
      cursor: not-allowed;
    }
    
    .map-select-screen .map-item:hover:not(.locked) {
      transform: translateY(-3px);
      box-shadow: 0 6px 20px rgba(245, 158, 11, 0.3);
    }
    
    .map-select-screen .map-difficulty {
      margin-top: 10px;
      padding: 4px 8px;
      border-radius: 4px;
      font-size: 12px;
      font-weight: bold;
      text-transform: uppercase;
    }
    
    .map-select-screen .map-difficulty.normal {
      background: #10B981;
      color: white;
    }
    
    .map-select-screen .map-difficulty.hard {
      background: #F59E0B;
      color: white;
    }
    
    .map-select-screen .map-difficulty.expert {
      background: #EF4444;
      color: white;
    }
    
    .map-select-screen .map-difficulty.insane {
      background: #8B5CF6;
      color: white;
    }
    
    /* 成就通知样式 */
    .achievement-notification {
      position: fixed;
      top: 20px;
      right: 20px;
      background: rgba(16, 185, 129, 0.95);
      border: 2px solid #10B981;
      border-radius: 10px;
      padding: 15px 20px;
      display: flex;
      align-items: center;
      gap: 15px;
      z-index: 1000;
      transform: translateX(400px);
      transition: transform 0.5s ease;
    }
    
    .achievement-notification.show {
      transform: translateX(0);
    }
    
    .achievement-notification .achievement-icon {
      font-size: 32px;
    }
    
    .achievement-notification .achievement-text {
      display: flex;
      flex-direction: column;
      gap: 5px;
    }
    
    .achievement-notification .achievement-title {
      font-weight: bold;
      color: white;
      font-size: 16px;
    }
    
    .achievement-notification .achievement-desc {
      color: rgba(255, 255, 255, 0.8);
      font-size: 14px;
    }
    
    /* 任务完成通知样式 */
    .mission-complete-notification {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%) scale(0.8);
      background: rgba(59, 130, 246, 0.95);
      border: 2px solid #60A5FA;
      border-radius: 15px;
      padding: 20px;
      z-index: 1001;
      opacity: 0;
      transition: all 0.3s ease;
      pointer-events: none;
    }
    
    .mission-complete-notification.show {
      opacity: 1;
      transform: translate(-50%, -50%) scale(1);
    }
    
    .mission-notification-content {
      display: flex;
      align-items: center;
      gap: 20px;
    }
    
    .mission-notification-icon {
      font-size: 48px;
      animation: pulse 1s ease-in-out infinite alternate;
    }
    
    .mission-notification-text {
      display: flex;
      flex-direction: column;
      gap: 5px;
      color: white;
    }
    
    .mission-notification-title {
      font-size: 20px;
      font-weight: bold;
      text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
    }
    
    .mission-notification-name {
      font-size: 18px;
      font-weight: 500;
    }
    
    .mission-notification-reward {
      font-size: 16px;
      opacity: 0.9;
    }
    
    @keyframes pulse {
      from { transform: scale(1); }
      to { transform: scale(1.1); }
    }
    
    /* 任务项目样式增强 */
    .mission-item-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 10px;
    }
    
    .mission-item-header h3 {
      margin: 0;
      color: #E5E7EB;
      font-size: 16px;
    }
    
    .mission-status {
      font-size: 12px;
      padding: 4px 8px;
      border-radius: 4px;
      font-weight: bold;
    }
    
    .mission-item.completed .mission-status {
      background: #10B981;
      color: white;
    }
    
    .mission-item:not(.completed) .mission-status {
      background: #F59E0B;
      color: white;
    }
    
    .mission-description {
      margin: 10px 0;
      color: #D1D5DB;
      font-size: 14px;
      line-height: 1.4;
    }
    
    .mission-progress {
      margin: 10px 0;
      color: #60A5FA;
      font-size: 14px;
      font-weight: 500;
    }
  </style>
  <style>
    body {
      font-family: 'Inter', system-ui, sans-serif;
      overflow: hidden;
      background-color: #0F172A;
      background-image: 
        radial-gradient(circle at 25% 25%, rgba(59, 130, 246, 0.1) 0%, transparent 50%),
        radial-gradient(circle at 75% 75%, rgba(16, 185, 129, 0.1) 0%, transparent 50%);
      margin: 0;
      padding: 0;
      width: 100vw;
      height: 100vh;
    }
    
    .tower-selection {
      display: flex;
      flex-direction: column;
      gap: 10px;
    }
    
    canvas {
      image-rendering: pixelated;
    }
    
    .game-container {
      position: relative;
      width: 100vw;
      height: 100vh;
      display: flex;
      justify-content: center;
      align-items: center;
      margin: 0;
      padding: 0;
      overflow: hidden;
    }
    
    .map-container {
      position: relative;
      width: 100vw!important;
      height: 100vh!important;
      overflow: hidden;
      margin: 0;
      padding: 0;
    }
    
    .map-scroll-container {
      position: relative;
      width: 100%;
      height: 100%;
      overflow: hidden;
    }
    
    .map-content {
      position: absolute;
      top: 0;
      left: 0;
    }
    
    .scrollbar {
      position: absolute;
      background-color: rgba(255, 255, 255, 0.3);
      border-radius: 6px;
      opacity: 1;
      transition: all 0.3s ease;
      z-index: 30;
    }
    
    .scrollbar:hover {
      background-color: rgba(255, 255, 255, 0.4);
    }
    
    .scrollbar-thumb {
      position: absolute;
      background-color: rgba(59, 130, 246, 0.9);
      border-radius: 6px;
      cursor: pointer;
      transition: all 0.3s ease;
      box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
    }
    
    .scrollbar-thumb:hover {
      background-color: rgba(59, 130, 246, 1);
      transform: scale(1.05);
    }
    
    .scrollbar-horizontal {
      bottom: 0;
      left: 0;
      width: 100%;
      height: 14px;
    }
    
    .scrollbar-vertical {
      top: 0;
      right: 0;
      width: 14px;
      height: 100%;
    }
    
    .menu-screen, .difficulty-screen, .admin-password-screen, .admin-screen, .game-screen, .game-over-screen, .victory-screen, .tower-info-screen, .mission-screen, .skill-screen, .map-select-screen {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      color: white;
      background-color: rgba(15, 23, 42, 0.95);
      transition: opacity 0.5s ease;
    }
    
    .hidden {
      opacity: 0;
      pointer-events: none;
    }
    
    .menu-title {
      font-size: 4rem;
      font-weight: bold;
      margin-bottom: 2rem;
      background: linear-gradient(90deg, #3B82F6, #10B981);
      -webkit-background-clip: text;
      background-clip: text;
      color: transparent;
      text-shadow: 0 0 15px rgba(59, 130, 246, 0.5);
    }
    
    .menu-button {
      width: 200px;
      height: 60px;
      margin: 10px;
      font-size: 1.2rem;
      font-weight: bold;
      border-radius: 10px;
      cursor: pointer;
      transition: all 0.3s ease;
      display: flex;
      justify-content: center;
      align-items: center;
    }
    
    .map-container {
      position: relative;
      width: 100%!important;
      height: 100%!important;
      overflow: auto;
      text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
    }
    
    .difficulty-button {
      width: 150px;
      height: 50px;
      margin: 8px;
      font-size: 1rem;
      font-weight: bold;
      border-radius: 8px;
      cursor: pointer;
      transition: all 0.3s ease;
      display: flex;
      justify-content: center;
      align-items: center;
    }
    
    .map-container {
      position: relative;
      width: 100%!important;
      height: 100%!important;
      overflow: auto;
      text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
    }
    
    .admin-input {
      width: 300px;
      height: 50px;
      font-size: 1.2rem;
      padding: 0 1rem;
      border-radius: 8px;
      border: none;
      margin-bottom: 1rem;
      background-color: rgba(255, 255, 255, 0.2);
      color: white;
      backdrop-filter: blur(5px);
    }
    
    .admin-input::placeholder {
      color: rgba(255, 255, 255, 0.5);
    }
    
    .tower-selection {
      position: absolute;
      top: 0;
      right: 0;
      width: 200px;
      height: 100%;
      background-color: rgba(15, 23, 42, 0.9);
      display: flex;
      flex-direction: column;
      padding: 1rem;
      overflow-y: auto;
    }
    
    /* 炮塔选择界面收缩/展开相关样式 */
    .tower-selection-container {
      position: relative;
      transition: all 0.3s ease;
      height: 100%;
      overflow: visible !important;
    }
    
    .tower-selection-toggle {
      position: absolute;
      top: 50%;
      left: -25px;
      transform: translateY(-50%);
      width: 25px;
      height: 50px;
      background-color: rgba(59, 130, 246, 0.9);
      border-radius: 8px 0 0 8px;
      display: flex;
      justify-content: center;
      align-items: center;
      cursor: pointer;
      z-index: 100;
      transition: all 0.3s ease;
      color: white;
      box-shadow: -2px 0 5px rgba(0, 0, 0, 0.3);
    }
    
    .tower-selection-toggle:hover {
      background-color: rgba(59, 130, 246, 1);
    }
    
    .tower-selection-collapsed {
      width: 0;
      padding: 0;
      overflow: hidden;
    }
    
    .tower-option {
      width: 100%;
      padding: 10px;
      margin-bottom: 10px;
      background-color: rgba(255, 255, 255, 0.1);
      border-radius: 8px;
      cursor: pointer;
      transition: all 0.3s ease;
      display: flex;
      flex-direction: column;
    }
    
    .tower-option:hover {
      background-color: rgba(255, 255, 255, 0.2);
    }
    
    .tower-option.selected {
      border: 2px solid #3B82F6;
      background-color: rgba(59, 130, 246, 0.2);
    }
    
    .tower-option h3 {
      font-size: 1rem;
      margin-bottom: 5px;
      color: #3B82F6;
    }
    
    .tower-option p {
      font-size: 0.8rem;
      color: rgba(255, 255, 255, 0.7);
      margin: 2px 0;
    }
    
    .game-info {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 60px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 0 1rem;
      background-color: rgba(15, 23, 42, 0.8);
      backdrop-filter: blur(5px);
      z-index: 10;
    }
    
    .info-item {
      display: flex;
      align-items: center;
      margin-right: 1rem;
    }
    
    .info-item i {
      margin-right: 5px;
      color: #3B82F6;
    }
    
    .tower-info {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 300px;
      background-color: rgba(15, 23, 42, 0.95);
      border-radius: 10px;
      padding: 1.5rem;
      box-shadow: 0 10px 25px rgba(0, 0, 0, 0.5);
      z-index: 20;
    }
    
    .tower-info h2 {
      font-size: 1.5rem;
      margin-bottom: 1rem;
      color: #3B82F6;
    }
    
    .tower-info p {
      margin: 0.5rem 0;
      color: rgba(255, 255, 255, 0.8);
    }
    
    .tower-info-buttons {
      display: flex;
      justify-content: space-between;
      margin-top: 1.5rem;
    }
    
    .tower-info-button {
      padding: 0.5rem 1rem;
      border-radius: 5px;
      cursor: pointer;
      transition: all 0.3s ease;
      font-weight: bold;
      color: white;
      text-align: center;
    }
    
    .upgrade-button {
      background-color: #10B981;
    }
    
    .sell-button {
      background-color: #EF4444;
    }
    
    .fire-button {
      background-color: #F59E0B;
      color: white;
      min-width: 80px;
    }
    
    .monster-health-bar {
      position: absolute;
      width: 100%;
      height: 4px;
      background-color: rgba(0, 0, 0, 0.5);
      bottom: -5px;
      left: 0;
      border-radius: 2px;
      overflow: hidden;
    }
    
    .monster-health {
      height: 100%;
      background-color: #10B981;
      transition: width 0.3s ease;
    }
    
    /* 炮塔血量条样式 */
    .tower-health-bar {
      position: absolute;
      width: 100%;
      height: 6px;
      background-color: rgba(0, 0, 0, 0.7);
      top: -8px;
      left: 0;
      border-radius: 3px;
      overflow: hidden;
      z-index: 5;
    }
    
    .tower-health {
      height: 100%;
      background: linear-gradient(90deg, #EF4444, #F59E0B, #10B981);
      transition: width 0.3s ease;
    }
    
    /* 炮塔受损效果 */
    .tower-damaged {
      filter: brightness(0.7) sepia(0.3) hue-rotate(-20deg);
      transition: all 0.3s ease;
    }
    
    /* 炮塔摧毁效果 */
    .tower-destroyed {
      filter: grayscale(1) brightness(0.3);
      opacity: 0.6;
      pointer-events: none;
    }
    
    .boss-health-bar {
      position: absolute;
      bottom: 50px;
      left: 50%;
      transform: translateX(-50%);
      width: 80%;
      height: 20px;
      background-color: rgba(0, 0, 0, 0.5);
      border-radius: 10px;
      overflow: hidden;
      z-index: 15;
      box-shadow: 0 0 10px rgba(239, 68, 68, 0.5);
    }
    
    .boss-health-fill {
      height: 100%;
      background: linear-gradient(90deg, #EF4444, #F59E0B);
      transition: width 0.3s ease;
    }
    
    .boss-health-text {
      position: absolute;
      bottom: 75px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 1.2rem;
      font-weight: bold;
      color: #EF4444;
      text-shadow: 0 0 5px rgba(239, 68, 68, 0.8);
      z-index: 15;
    }
    
    .wave-notification {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 3rem;
      font-weight: bold;
      color: white;
      text-shadow: 0 0 10px rgba(59, 130, 246, 0.8);
      opacity: 0;
      transition: opacity 0.5s ease;
      z-index: 20;
    }
    
    .wave-notification.show {
      opacity: 1;
    }
    
    .floating-text {
      position: absolute;
      font-size: 1rem;
      font-weight: bold;
      color: #10B981;
      text-shadow: 0 0 3px rgba(0, 0, 0, 0.5);
      animation: floatUp 1s ease-out forwards;
      pointer-events: none;
    }
    
    @keyframes floatUp {
      0% {
        opacity: 1;
        transform: translateY(0);
      }
      100% {
        opacity: 0;
        transform: translateY(-30px);
      }
    }
    
    .tower-range {
      position: absolute;
      border-radius: 50%;
      border: 2px dashed rgba(59, 130, 246, 0.5);
      pointer-events: none;
      opacity: 0.7;
      transition: all 0.3s ease;
    }
    
    .tower-range.hidden {
      opacity: 0;
      pointer-events: none;
    }
    
    /* 技能快捷栏样式 */
    .skill-hotbar {
      background-color: rgba(15, 23, 42, 0.8);
      padding: 10px;
      border-radius: 10px;
      backdrop-filter: blur(10px);
      border: 1px solid rgba(59, 130, 246, 0.3);
    }
    
    .skill-hotbar-button {
      width: 60px;
      height: 60px;
      border-radius: 8px;
      border: 2px solid #3B82F6;
      background-color: rgba(59, 130, 246, 0.2);
      color: white;
      cursor: pointer;
      transition: all 0.3s ease;
      position: relative;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      font-size: 12px;
      padding: 5px;
    }
    
    .skill-hotbar-button:hover:not(:disabled) {
      background-color: rgba(59, 130, 246, 0.4);
      transform: translateY(-2px);
      box-shadow: 0 5px 15px rgba(59, 130, 246, 0.4);
    }
    
    .skill-hotbar-button:disabled {
      border-color: #6B7280;
      background-color: rgba(107, 114, 128, 0.2);
      cursor: not-allowed;
      opacity: 0.6;
    }
    
    .skill-hotbar-button.locked {
      border-color: #EF4444;
      background-color: rgba(239, 68, 68, 0.2);
      cursor: not-allowed;
    }
    
    .skill-hotbar-button .skill-icon {
      font-size: 20px;
      margin-bottom: 2px;
    }
    
    .skill-hotbar-button .skill-name {
      font-size: 10px;
      text-align: center;
      line-height: 1.2;
    }
    
    .skill-hotbar-button .skill-cooldown {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background-color: rgba(0, 0, 0, 0.7);
      color: white;
      font-size: 16px;
      font-weight: bold;
      width: 100%;
      height: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 6px;
    }
    
    .skill-hotbar-button .skill-level {
      position: absolute;
      top: 2px;
      right: 2px;
      background-color: #F59E0B;
      color: white;
      font-size: 10px;
      font-weight: bold;
      width: 16px;
      height: 16px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    
    .skill-hotbar-button .skill-key {
      position: absolute;
      bottom: 2px;
      right: 2px;
      background-color: rgba(0, 0, 0, 0.6);
      color: white;
      font-size: 8px;
      width: 14px;
      height: 14px;
      border-radius: 3px;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    
    .admin-table-container {
      width: 80%;
      max-height: 60vh;
      overflow-y: auto;
      margin: 2rem 0;
    }
    
    .admin-table {
      width: 100%;
      border-collapse: collapse;
      background-color: rgba(255, 255, 255, 0.1);
      border-radius: 10px;
      overflow: hidden;
    }
    
    .admin-table th, .admin-table td {
      padding: 1rem;
      text-align: left;
      border-bottom: 1px solid rgba(255, 255, 255, 0.2);
    }
    
    .admin-table th {
      background-color: rgba(59, 130, 246, 0.2);
      font-weight: bold;
    }
    
    .admin-table input {
      width: 100px;
      padding: 0.5rem;
      border-radius: 5px;
      border: none;
      background-color: rgba(255, 255, 255, 0.2);
      color: white;
    }
    
    .admin-table input::placeholder {
      color: rgba(255, 255, 255, 0.5);
    }
    
    .admin-tabs {
      display: flex;
      margin-bottom: 1rem;
    }
    
    .admin-tab {
      padding: 0.5rem 1rem;
      margin-right: 0.5rem;
      border-radius: 5px;
      cursor: pointer;
      transition: all 0.3s ease;
    }
    
    .admin-tab.active {
      background-color: rgba(59, 130, 246, 0.2);
      border: 1px solid #3B82F6;
    }
    
    .admin-content {
      display: none;
    }
    
    .admin-content.active {
      display: block;
    }
    
    .encyclopedia-container {
      width: 80%;
      height: 80%;
      overflow-y: auto;
      background-color: rgba(15, 23, 42, 0.9);
      border-radius: 10px;
      padding: 1.5rem;
      box-shadow: 0 10px 25px rgba(0, 0, 0, 0.5);
      max-height: 70vh;
    }
    
    .encyclopedia-tabs {
      display: flex;
      margin-bottom: 1rem;
    }
    
    .encyclopedia-tab {
      padding: 0.5rem 1rem;
      margin-right: 0.5rem;
      border-radius: 5px;
      cursor: pointer;
      transition: all 0.3s ease;
    }
    
    .encyclopedia-tab.active {
      background-color: rgba(59, 130, 246, 0.2);
      border: 1px solid #3B82F6;
    }
    
    .encyclopedia-content {
      display: none;
    }
    
    .encyclopedia-content.active {
      display: block;
    }
    
    .encyclopedia-item {
      margin-bottom: 1.5rem;
      padding-bottom: 1rem;
      border-bottom: 1px solid rgba(255, 255, 255, 0.1);
    }
    
    .encyclopedia-item h3 {
      font-size: 1.2rem;
      margin-bottom: 0.5rem;
      color: #3B82F6;
    }
    
    .encyclopedia-item p {
      margin: 0.3rem 0;
      color: rgba(255, 255, 255, 0.8);
    }
    
    .encyclopedia-item .special {
      color: #F59E0B;
      font-weight: bold;
    }
    
    .back-button {
      position: absolute;
      top: 1rem;
      left: 1rem;
      padding: 0.5rem 1rem;
      border-radius: 5px;
      cursor: pointer;
      transition: all 0.3s ease;
      background-color: rgba(59, 130, 246, 0.2);
      border: 1px solid #3B82F6;
      z-index: 30;
    }
    
    .back-button:hover {
      background-color: rgba(59, 130, 246, 0.4);
    }
    
    .game-over-screen h2, .victory-screen h2 {
      font-size: 3rem;
      margin-bottom: 1rem;
      text-shadow: 0 0 10px rgba(239, 68, 68, 0.8);
    }
    
    .game-over-screen p, .victory-screen p {
      font-size: 1.2rem;
      margin-bottom: 2rem;
    }
    
    .restart-button {
      padding: 1rem 2rem;
      font-size: 1.2rem;
      font-weight: bold;
      border-radius: 10px;
      cursor: pointer;
      transition: all 0.3s ease;
      background-color: #3B82F6;
      text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
    }
    
    .restart-button:hover {
      background-color: #2563EB;
    }
    
    /* 动画效果 */
    .tower-shoot {
      animation: towerShoot 0.3s ease;
    }
    
    @keyframes towerShoot {
      0% {
        transform: scale(1);
      }
      50% {
        transform: scale(1.1);
      }
      100% {
        transform: scale(1);
      }
    }
    
    .monster-hit {
      animation: monsterHit 0.2s ease;
    }
    
    @keyframes monsterHit {
      0% {
        opacity: 1;
      }
      50% {
        opacity: 0.5;
      }
      100% {
        opacity: 1;
      }
    }
    
    .explosion {
      position: absolute;
      width: 30px;
      height: 30px;
      border-radius: 50%;
      background: radial-gradient(circle, #F59E0B, #EF4444);
      opacity: 0;
      animation: explosion 0.5s ease-out forwards;
      pointer-events: none;
    }
    
    @keyframes explosion {
      0% {
        opacity: 1;
        transform: scale(0.5);
      }
      100% {
        opacity: 0;
        transform: scale(2);
      }
    }
    
    .laser {
      position: absolute;
      height: 4px;
      background: linear-gradient(90deg, #3B82F6, #10B981);
      transform-origin: left center;
      opacity: 0;
      animation: laser 0.3s ease-out forwards;
      pointer-events: none;
      box-shadow: 0 0 10px rgba(59, 130, 246, 0.8);
    }
    
    @keyframes laser {
      0% {
        opacity: 1;
      }
      100% {
        opacity: 0;
      }
    }
    
    .freeze-effect {
      position: absolute;
      width: 100%;
      height: 100%;
      border-radius: 50%;
      background-color: rgba(59, 130, 246, 0.3);
      animation: freezeEffect 1s ease-out forwards;
      pointer-events: none;
    }
    
    @keyframes freezeEffect {
      0% {
        opacity: 1;
        transform: scale(1);
      }
      100% {
        opacity: 0;
        transform: scale(1.5);
      }
    }
    
    .stun-effect {
      position: absolute;
      width: 100%;
      height: 100%;
      border-radius: 50%;
      background-color: rgba(245, 158, 11, 0.3);
      animation: stunEffect 1s ease-out forwards;
      pointer-events: none;
    }
    
    @keyframes stunEffect {
      0% {
        opacity: 1;
        transform: scale(1);
      }
      100% {
        opacity: 0;
        transform: scale(1.5);
      }
    }
    
    /* 响应式设计 */
    @media (max-width: 768px) {
      .menu-title {
        font-size: 2.5rem;
      }
      
      .menu-button {
        width: 120px; /* 缩小宽度 */
        height: 50px;
        font-size: 1rem;
      }
      
      .tower-selection {
        width: 120px; /* 缩小宽度 */
      }
      
      .game-info {
        height: 80px;
        flex-direction: column;
        justify-content: center;
        align-items: flex-start;
      }
      
      .info-item {
        margin-bottom: 5px;
      }
      
      .boss-health-bar {
        width: 90%;
        bottom: 20px;
      }
      
      .boss-health-text {
        bottom: 45px;
        font-size: 1rem;
      }
    }
    
    /* 任务系统样式 */
    .mission-screen .mission-content {
      background: rgba(17, 24, 39, 0.95);
      border: 2px solid #3B82F6;
      border-radius: 10px;
      padding: 20px;
      max-width: 600px;
      max-height: 80vh;
      overflow-y: auto;
    }
    
    .mission-screen .mission-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 20px;
    }
    
    .mission-screen .mission-list {
      display: flex;
      flex-direction: column;
      gap: 15px;
    }
    
    .mission-screen .mission-item {
      background: rgba(59, 130, 246, 0.1);
      border: 1px solid #3B82F6;
      border-radius: 8px;
      padding: 15px;
      transition: all 0.3s ease;
    }
    
    .mission-screen .mission-item.completed {
      background: rgba(16, 185, 129, 0.2);
      border-color: #10B981;
    }
    
    .mission-screen .mission-item:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(59, 130, 246, 0.3);
    }
    
    .mission-screen .mission-reward {
      margin-top: 10px;
      padding-top: 10px;
      border-top: 1px solid rgba(59, 130, 246, 0.3);
      color: #10B981;
    }
    
    /* 技能系统样式 */
    .skill-screen .skill-content {
      background: rgba(17, 24, 39, 0.95);
      border: 2px solid #8B5CF6;
      border-radius: 10px;
      padding: 20px;
      max-width: 600px;
      max-height: 80vh;
      overflow-y: auto;
    }
    
    .skill-screen .skill-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 20px;
    }
    
    .skill-screen .skill-points {
      font-size: 18px;
      font-weight: bold;
      color: #8B5CF6;
      margin-bottom: 20px;
      text-align: center;
    }
    
    .skill-screen .skill-list {
      display: flex;
      flex-direction: column;
      gap: 15px;
    }
    
    .skill-screen .skill-item {
      background: rgba(139, 92, 246, 0.1);
      border: 1px solid #8B5CF6;
      border-radius: 8px;
      padding: 15px;
      transition: all 0.3s ease;
    }
    
    .skill-screen .skill-item.locked {
      opacity: 0.5;
      border-color: #6B7280;
    }
    
    .skill-screen .skill-item:hover:not(.locked) {
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(139, 92, 246, 0.3);
    }
    
    .skill-screen .skill-level {
      margin-top: 10px;
      display: flex;
      align-items: center;
      gap: 10px;
    }
    
    .skill-screen .skill-button {
      background: #8B5CF6;
      color: white;
      border: none;
      padding: 8px 16px;
      border-radius: 5px;
      cursor: pointer;
      transition: all 0.3s ease;
    }
    
    .skill-screen .skill-button:hover:not(:disabled) {
      background: #7C3AED;
      transform: translateY(-1px);
    }
    
    .skill-screen .skill-button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
    
    /* 地图选择样式 */
    .map-select-screen .map-select-content {
      background: rgba(17, 24, 39, 0.95);
      border: 2px solid #F59E0B;
      border-radius: 10px;
      padding: 20px;
      max-width: 800px;
      max-height: 80vh;
      overflow-y: auto;
    }
    
    .map-select-screen .map-select-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 20px;
    }
    
    .map-select-screen .map-list {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
      gap: 20px;
    }
    
    .map-select-screen .map-item {
      background: rgba(245, 158, 11, 0.1);
      border: 1px solid #F59E0B;
      border-radius: 8px;
      padding: 20px;
      cursor: pointer;
      transition: all 0.3s ease;
    }
    
    .map-select-screen .map-item.locked {
      opacity: 0.5;
      border-color: #6B7280;
      cursor: not-allowed;
    }
    
    .map-select-screen .map-item:hover:not(.locked) {
      transform: translateY(-3px);
      box-shadow: 0 6px 20px rgba(245, 158, 11, 0.3);
    }
    
    .map-select-screen .map-difficulty {
      margin-top: 10px;
      padding: 4px 8px;
      border-radius: 4px;
      font-size: 12px;
      font-weight: bold;
      text-transform: uppercase;
    }
    
    .map-select-screen .map-difficulty.normal {
      background: #10B981;
      color: white;
    }
    
    .map-select-screen .map-difficulty.hard {
      background: #F59E0B;
      color: white;
    }
    
    .map-select-screen .map-difficulty.expert {
      background: #EF4444;
      color: white;
    }
    
    .map-select-screen .map-difficulty.insane {
      background: #8B5CF6;
      color: white;
    }
    
    /* 成就通知样式 */
    .achievement-notification {
      position: fixed;
      top: 20px;
      right: 20px;
      background: rgba(16, 185, 129, 0.95);
      border: 2px solid #10B981;
      border-radius: 10px;
      padding: 15px 20px;
      display: flex;
      align-items: center;
      gap: 15px;
      z-index: 1000;
      transform: translateX(400px);
      transition: transform 0.5s ease;
    }
    
    .achievement-notification.show {
      transform: translateX(0);
    }
    
    .achievement-notification .achievement-icon {
      font-size: 32px;
    }
    
    .achievement-notification .achievement-text {
      display: flex;
      flex-direction: column;
      gap: 5px;
    }
    
    .achievement-notification .achievement-title {
      font-weight: bold;
      color: white;
      font-size: 16px;
    }
    
    .achievement-notification .achievement-desc {
      color: rgba(255, 255, 255, 0.8);
      font-size: 14px;
    }
    
    /* 任务完成通知样式 */
    .mission-complete-notification {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%) scale(0.8);
      background: rgba(59, 130, 246, 0.95);
      border: 2px solid #60A5FA;
      border-radius: 15px;
      padding: 20px;
      z-index: 1001;
      opacity: 0;
      transition: all 0.3s ease;
      pointer-events: none;
    }
    
    .mission-complete-notification.show {
      opacity: 1;
      transform: translate(-50%, -50%) scale(1);
    }
    
    .mission-notification-content {
      display: flex;
      align-items: center;
      gap: 20px;
    }
    
    .mission-notification-icon {
      font-size: 48px;
      animation: pulse 1s ease-in-out infinite alternate;
    }
    
    .mission-notification-text {
      display: flex;
      flex-direction: column;
      gap: 5px;
      color: white;
    }
    
    .mission-notification-title {
      font-size: 20px;
      font-weight: bold;
      text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
    }
    
    .mission-notification-name {
      font-size: 18px;
      font-weight: 500;
    }
    
    .mission-notification-reward {
      font-size: 16px;
      opacity: 0.9;
    }
    
    @keyframes pulse {
      from { transform: scale(1); }
      to { transform: scale(1.1); }
    }
    
    /* 任务项目样式增强 */
    .mission-item-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 10px;
    }
    
    .mission-item-header h3 {
      margin: 0;
      color: #E5E7EB;
      font-size: 16px;
    }
    
    .mission-status {
      font-size: 12px;
      padding: 4px 8px;
      border-radius: 4px;
      font-weight: bold;
    }
    
    .mission-item.completed .mission-status {
      background: #10B981;
      color: white;
    }
    
    .mission-item:not(.completed) .mission-status {
      background: #F59E0B;
      color: white;
    }
    
    .mission-description {
      margin: 10px 0;
      color: #D1D5DB;
      font-size: 14px;
      line-height: 1.4;
    }
    
    .mission-progress {
      margin: 10px 0;
      color: #60A5FA;
      font-size: 14px;
      font-weight: 500;
    }
  </style>
</head>
<body>
  <!-- 音频元素 -->
  <audio id="bgMusic" loop preload="auto">
    <source src="https://example.com/background-music.mp3" type="audio/mpeg">
  </audio>
  <audio id="buttonClickSound" preload="auto">
    <source src="https://example.com/button-click.mp3" type="audio/mpeg">
  </audio>
  <audio id="towerPlaceSound" preload="auto">
    <source src="https://example.com/tower-place.mp3" type="audio/mpeg">
  </audio>
  <audio id="towerUpgradeSound" preload="auto">
    <source src="https://example.com/tower-upgrade.mp3" type="audio/mpeg">
  </audio>
  <audio id="enemyHitSound" preload="auto">
    <source src="https://example.com/enemy-hit.mp3" type="audio/mpeg">
  </audio>
  <audio id="enemyDieSound" preload="auto">
    <source src="https://example.com/enemy-die.mp3" type="audio/mpeg">
  </audio>
  <audio id="gameOverSound" preload="auto">
    <source src="https://example.com/game-over.mp3" type="audio/mpeg">
  </audio>
  <audio id="victorySound" preload="auto">
    <source src="https://example.com/victory.mp3" type="audio/mpeg">
  </audio>
  <div class="game-container">
    <!-- 主菜单 -->
    <div class="menu-screen" id="menu-screen">
      <h1 class="menu-title">终极塔防</h1>
      <div class="menu-button bg-primary btn-3d" id="start-game">开始游戏</div>
      <div class="menu-button bg-secondary btn-3d" id="encyclopedia">图鉴查看</div>
      <div class="menu-button bg-accent btn-3d" id="admin-mode">管理员模式</div>
      
      <!-- 音量控制 -->
      <div class="volume-controls" style="position: absolute; bottom: 20px; right: 20px; display: flex; gap: 15px;">
        <!-- 音乐控制 -->
        <div class="volume-control">
          <i class="fa fa-music audio-toggle" id="music-toggle" style="font-size: 20px;"></i>
          <input type="range" min="0" max="1" step="0.05" value="0.5" class="volume-slider" id="music-volume">
        </div>
        
        <!-- 音效控制 -->
        <div class="volume-control">
          <i class="fa fa-volume-up audio-toggle" id="sfx-toggle" style="font-size: 20px;"></i>
          <input type="range" min="0" max="1" step="0.05" value="0.7" class="volume-slider" id="sfx-volume">
        </div>
      </div>
    </div>
    
    <!-- 难度选择界面 -->
    <div class="difficulty-screen hidden" id="difficulty-screen">
      <h2 class="text-3xl mb-6">选择难度</h2>
      <div class="difficulty-button bg-green-500 btn-3d" data-difficulty="easy">简单</div>
      <div class="difficulty-button bg-blue-500 btn-3d" data-difficulty="normal">普通</div>
      <div class="difficulty-button bg-yellow-500 btn-3d" data-difficulty="hard">困难</div>
      <div class="difficulty-button bg-red-500 btn-3d" data-difficulty="hell">地狱</div>
      <div class="back-button mt-4" id="back-from-difficulty">返回</div>
    </div>
    
    <!-- 管理员密码界面 -->
    <div class="admin-password-screen hidden" id="admin-password-screen">
      <h2 class="text-2xl mb-4">管理员模式</h2>
      <input type="password" class="admin-input" placeholder="请输入密码" id="admin-password">
      <div class="menu-button bg-accent btn-3d" id="check-password">确认</div>
      <div class="back-button mt-4" id="back-from-password">返回</div>
    </div>
    
    <!-- 管理员界面 -->
    <div class="admin-screen hidden" id="admin-screen">
      <h2 class="text-2xl mb-4">管理员参数调整</h2>
      <div class="admin-tabs">
        <div class="admin-tab active" data-tab="towers">炮塔参数</div>
        <div class="admin-tab" data-tab="monsters">怪物参数</div>
      </div>
      
      <div class="admin-content active" id="towers-content">
        <div class="admin-table-container">
          <table class="admin-table">
            <thead>
              <tr>
                <th>炮塔名称</th>
                <th>射程(格)</th>
                <th>伤害</th>
                <th>攻击间隔(秒)</th>
                <th>价格</th>
              </tr>
            </thead>
            <tbody id="towers-table-body">
              <!-- 炮塔参数将通过JavaScript动态生成 -->
            </tbody>
          </table>
        </div>
      </div>
      
      <div class="admin-content" id="monsters-content">
        <div class="admin-table-container">
          <table class="admin-table">
            <thead>
              <tr>
                <th>怪物名称</th>
                <th>血量</th>
                <th>移动速度(秒/格)</th>
                <th>核心伤害</th>
              </tr>
            </thead>
            <tbody id="monsters-table-body">
              <!-- 怪物参数将通过JavaScript动态生成 -->
            </tbody>
          </table>
        </div>
      </div>
      
      <div class="menu-button bg-primary btn-3d" id="save-admin-settings">保存设置</div>
      <div class="back-button mt-4" id="back-from-admin">返回</div>
    </div>
    
    <!-- 图鉴界面 -->
    <div class="encyclopedia-screen hidden" id="encyclopedia-screen">
      <h2 class="text-2xl mb-4">图鉴</h2>
      <div class="encyclopedia-tabs">
        <div class="encyclopedia-tab active" data-tab="towers">炮塔图鉴</div>
        <div class="encyclopedia-tab" data-tab="monsters">怪物图鉴</div>
      </div>
      
      <div class="encyclopedia-container">
        <div class="encyclopedia-content active" id="towers-encyclopedia">
          <!-- 炮塔图鉴将通过JavaScript动态生成 -->
        </div>
        
        <div class="encyclopedia-content" id="monsters-encyclopedia">
          <!-- 怪物图鉴将通过JavaScript动态生成 -->
        </div>
      </div>
      
      <div class="back-button" id="back-from-encyclopedia">返回</div>
    </div>
    
    <!-- 游戏界面 -->
    <div class="game-screen hidden" id="game-screen">
      <div class="game-info" style="position: absolute; top: 0; left: 0; width: 100%; height: 60px; display: flex; justify-content: space-between; align-items: center; padding: 0 1rem; background-color: rgba(15, 23, 42, 0.8); backdrop-filter: blur(5px); z-index: 10;">
        <div class="info-items" style="display: flex; gap: 20px;">
          <div class="info-item">
            <i class="fa fa-star"></i>
            <span id="difficulty-display">难度: 简单</span>
          </div>
          <div class="info-item">
            <i class="fa fa-wave-square"></i>
            <span id="wave-display">波数: 1/100</span>
          </div>
          <div class="info-item">
            <i class="fa fa-money"></i>
            <span id="money-display">金钱: 1000</span>
          </div>
          <div class="info-item">
            <i class="fa fa-heart"></i>
            <span id="core-health-display">核心血量: 100</span>
          </div>
          <div class="info-item">
            <i class="fa fa-flask"></i>
            <span id="tech-points-display">科技点: 0</span>
          </div>
          <div class="info-item">
            <i class="fa fa-lock" id="quantum-tower-icon"></i>
            <span id="quantum-tower-progress">量子炮解锁: 0/5</span>
          </div>
        </div>
        <div class="system-buttons" style="display: flex; gap: 10px;">
          <div class="mission-system-button" id="mission-system-button" style="padding: 0.5rem 1rem; background-color: rgba(59, 130, 246, 0.8); border-radius: 5px; cursor: pointer; transition: all 0.3s ease; display: flex; align-items: center; gap: 5px;">
            <i class="fa fa-flag"></i>
            <span>任务</span>
          </div>
          <div class="achievement-system-button" id="achievement-system-button" style="padding: 0.5rem 1rem; background-color: rgba(16, 185, 129, 0.8); border-radius: 5px; cursor: pointer; transition: all 0.3s ease; display: flex; align-items: center; gap: 5px;">
            <i class="fa fa-trophy"></i>
            <span>成就</span>
          </div>
          <div class="skill-system-button" id="skill-system-button" style="padding: 0.5rem 1rem; background-color: rgba(245, 158, 11, 0.8); border-radius: 5px; cursor: pointer; transition: all 0.3s ease; display: flex; align-items: center; gap: 5px;">
            <i class="fa fa-bolt"></i>
            <span>技能</span>
          </div>
          <div class="tech-system-button" id="tech-system-button" style="padding: 0.5rem 1rem; background-color: rgba(139, 92, 246, 0.8); border-radius: 5px; cursor: pointer; transition: all 0.3s ease; display: flex; align-items: center; gap: 5px;">
            <i class="fa fa-cogs"></i>
            <span>科技</span>
          </div>
        </div>
      </div>
      
      <!-- 技能快捷栏 -->
      <div class="skill-hotbar" id="skill-hotbar" style="position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%); display: flex; gap: 10px; z-index: 100;">
        <!-- 技能按钮将通过JavaScript动态生成 -->
      </div>
      
      <div class="game-content" style="position: absolute; top: 60px; left: 0; width: 100%; height: calc(100% - 60px); display: flex;">
        <div class="map-container" style="flex: 1; position: relative; overflow: hidden;">
          <canvas id="game-canvas" width="1920" height="1080"></canvas>
        </div>
        
        <!-- 右侧炮塔选择面板 -->
        <div class="tower-selection-container" style="position: absolute; top: 70px; right: 10px; width: 220px; z-index: 10; transition: transform 0.3s ease;">
          <div class="selection-header" style="display: flex; justify-content: space-between; align-items: center; background-color: #3B82F6; padding: 8px 12px; border-radius: 4px 4px 0 0;">
            <div class="selection-tabs" style="display: flex; gap: 2px; margin-bottom: 0;">
              <button class="tab-button active" data-tab="towers" style="padding: 8px 16px; background-color: transparent; color: white; border: none; border-radius: 4px 4px 0 0; cursor: pointer;">炮塔</button>
            </div>
            <button id="toggle-tower-panel" style="background: none; border: none; color: white; cursor: pointer; font-size: 14px; padding: 4px;">
              <i class="fa fa-chevron-left"></i>
            </button>
          </div>
          <div class="tower-selection" id="tower-selection" style="width: 100%; padding: 10px; background-color: rgba(15, 23, 42, 0.9); border-radius: 0 0 4px 4px; overflow-y: auto; max-height: calc(100vh - 116px);"></div>
        </div>
      </div>
      
      <!-- 波数通知 -->
      <div class="wave-notification" id="wave-notification">第1波</div>
      
      <!-- Boss血条 -->
      <div class="boss-health-bar hidden" id="boss-health-bar">
        <div class="boss-health-fill" id="boss-health-fill" style="width: 100%;"></div>
      </div>
      <div class="boss-health-text hidden" id="boss-health-text">BOSS: 100000/100000</div>
    </div>
    
    <!-- 炮塔信息界面 -->
    <div class="tower-info-screen hidden" id="tower-info-screen">
      <div class="tower-info">
        <div class="tower-info-header">
          <h2 id="tower-info-name">能量炮</h2>
          <button class="close-button" id="close-tower-info">✕</button>
        </div>
        <p><strong>等级:</strong> <span id="tower-info-level">1</span></p>
        <p><strong>射程:</strong> <span id="tower-info-range">6</span> 格</p>
        <p><strong>伤害:</strong> <span id="tower-info-damage">10</span></p>
        <p><strong>攻击间隔:</strong> <span id="tower-info-fire-rate">1.0</span> 秒</p>
        <p><strong>特殊效果:</strong> <span id="tower-info-special">最基础的炮台，也是最便宜的</span></p>
        <div class="tower-info-buttons">
          <div class="tower-info-button upgrade-button" id="upgrade-tower">升级 (花费: <span id="upgrade-cost">25</span>)</div>
          <div class="tower-info-button sell-button" id="sell-tower">出售 (获得: <span id="sell-amount">50</span>)</div>
        </div>
      </div>
    </div>
    
    <!-- 游戏结束界面 -->
    <div class="game-over-screen hidden" id="game-over-screen">
      <h2>游戏结束</h2>
      <p>你坚持了 <span id="waves-survived">0</span> 波</p>
      <div class="restart-button" id="restart-game">重新开始</div>
    </div>
    
    <!-- 胜利界面 -->
    <div class="victory-screen hidden" id="victory-screen">
      <h2>恭喜通关!</h2>
      
    <!-- 任务系统界面 -->
    <div class="mission-screen hidden" id="mission-screen">
      <div class="mission-content">
        <div class="mission-header">
          <h2>任务系统</h2>
          <button class="close-button" id="close-mission">✕</button>
        </div>
        <div class="mission-list" id="mission-list">
          <!-- 任务列表将通过JavaScript动态生成 -->
        </div>
      </div>
    </div>
    
    <!-- 技能系统界面 -->
    <div class="skill-screen hidden" id="skill-screen">
      <div class="skill-content">
        <div class="skill-header">
          <h2>技能系统</h2>
          <button class="close-button" id="close-skill">✕</button>
        </div>
        <div class="skill-points">技能点: <span id="skill-points-display">0</span></div>
        <div class="skill-list" id="skill-list">
          <!-- 技能列表将通过JavaScript动态生成 -->
        </div>
      </div>
    </div>
    
    <!-- 地图选择界面 -->
    <div class="map-select-screen hidden" id="map-select-screen">
      <div class="map-select-content">
        <div class="map-select-header">
          <h2>选择地图</h2>
          <button class="close-button" id="close-map-select">✕</button>
        </div>
        <div class="map-list" id="map-list">
          <!-- 地图列表将通过JavaScript动态生成 -->
        </div>
      </div>
    </div>
    
    <!-- 成就通知 -->
    <div class="achievement-notification hidden" id="achievement-notification">
      <div class="achievement-icon">🏆</div>
      <div class="achievement-text">
        <div class="achievement-title" id="achievement-title">成就解锁!</div>
        <div class="achievement-desc" id="achievement-desc">恭喜获得新成就</div>
      </div>
    </div>
      <p>你成功击败了最终BOSS!</p>
      <div class="restart-button" id="victory-restart">重新开始</div>
    </div>
    
    <!-- 科技树界面 -->
    <div class="tech-tree-screen hidden" id="tech-tree-screen">
      <div style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(15, 23, 42, 0.95); display: flex; flex-direction: column; justify-content: flex-start; align-items: center; z-index: 100; padding: 20px 0;">
        <!-- 返回按钮 -->
        <button id="back-from-tech-tree" style="position: absolute; top: 20px; left: 20px; padding: 0.5rem 1rem; border-radius: 5px; background-color: #1E293B; color: white; font-weight: bold; cursor: pointer; transition: all 0.3s ease; display: flex; align-items: center; gap: 5px;">
          <i class="fa fa-arrow-left"></i> 返回
        </button>
        
        <!-- 科技点显示 -->
        <div style="position: absolute; top: 20px; right: 20px; display: flex; align-items: center; gap: 10px; color: white; font-size: 1.2rem;">
          <i class="fa fa-flask" style="color: #8B5CF6;"></i>
          <span id="tech-points-display-tree">科技点: 0</span>
        </div>
        
        <!-- 标题 -->
        <h2 style="font-size: 2.5rem; margin: 2rem 0 1rem 0; color: white; text-shadow: 0 0 10px rgba(139, 92, 246, 0.8);">科技树</h2>
        
        <!-- 滚动提示 -->
        <p style="color: rgba(255, 255, 255, 0.7); margin-bottom: 1.5rem; font-size: 1rem;">左右滑动切换科技分支</p>
        
        <!-- 滚动容器 -->
        <div style="display: flex; gap: 40px; width: 100%; max-width: 1200px; overflow-x: auto; padding: 20px 0; scroll-behavior: smooth; scrollbar-width: thin; scrollbar-color: rgba(139, 92, 246, 0.5) rgba(15, 23, 42, 0.3);">
          <!-- 攻击强化分支 -->
          <div class="tech-branch" style="background-color: rgba(239, 68, 68, 0.1); border: 2px solid rgba(239, 68, 68, 0.5); border-radius: 10px; padding: 20px; min-width: 300px; flex-shrink: 0; transform: transition-transform 0.3s ease;">
            <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 15px;">
              <div style="width: 40px; height: 40px; border-radius: 50%; background-color: rgba(239, 68, 68, 0.2); display: flex; justify-content: center; align-items: center; border: 2px solid #EF4444;">
                <i class="fa fa-crosshairs" style="color: #EF4444; font-size: 1.5rem;"></i>
              </div>
              <h3 style="color: #EF4444; font-size: 1.8rem; margin: 0;">攻击强化</h3>
            </div>
            <div class="tech-nodes">
              <div class="tech-node" data-branch="attack" data-level="1" style="margin-bottom: 15px; padding: 15px; border-radius: 8px; background-color: rgba(255, 255, 255, 0.1); border-left: 4px solid #EF4444; transition: transform 0.2s ease;">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                  <span style="font-weight: bold; font-size: 1.1rem;">等级 1</span>
                  <span style="color: #8B5CF6; font-weight: bold;">10 点</span>
                </div>
                <p style="font-size: 1rem; color: rgba(255, 255, 255, 0.9); margin-bottom: 10px;">所有炮塔攻击力+5%</p>
                <button class="upgrade-tech-button" style="width: 100%; padding: 8px; margin-top: 5px; border-radius: 5px; background-color: rgba(139, 92, 246, 0.7); color: white; cursor: pointer; transition: all 0.3s ease; font-size: 1rem; font-weight: bold;">升级</button>
              </div>
              <div class="tech-node" data-branch="attack" data-level="2" style="margin-bottom: 15px; padding: 15px; border-radius: 8px; background-color: rgba(255, 255, 255, 0.1); border-left: 4px solid #EF4444; transition: transform 0.2s ease;">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                  <span style="font-weight: bold; font-size: 1.1rem;">等级 2</span>
                  <span style="color: #8B5CF6; font-weight: bold;">20 点</span>
                </div>
                <p style="font-size: 1rem; color: rgba(255, 255, 255, 0.9); margin-bottom: 10px;">所有炮塔攻击力+10%</p>
                <button class="upgrade-tech-button" style="width: 100%; padding: 8px; margin-top: 5px; border-radius: 5px; background-color: rgba(139, 92, 246, 0.7); color: white; cursor: pointer; transition: all 0.3s ease; font-size: 1rem; font-weight: bold;">升级</button>
              </div>
              <div class="tech-node" data-branch="attack" data-level="3" style="margin-bottom: 15px; padding: 15px; border-radius: 8px; background-color: rgba(255, 255, 255, 0.1); border-left: 4px solid #EF4444; transition: transform 0.2s ease;">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                  <span style="font-weight: bold; font-size: 1.1rem;">等级 3</span>
                  <span style="color: #8B5CF6; font-weight: bold;">30 点</span>
                </div>
                <p style="font-size: 1rem; color: rgba(255, 255, 255, 0.9); margin-bottom: 10px;">所有炮塔攻击力+15%</p>
                <button class="upgrade-tech-button" style="width: 100%; padding: 8px; margin-top: 5px; border-radius: 5px; background-color: rgba(139, 92, 246, 0.7); color: white; cursor: pointer; transition: all 0.3s ease; font-size: 1rem; font-weight: bold;">升级</button>
              </div>
            </div>
          </div>
          
          <!-- 防御强化分支 -->
          <div class="tech-branch" style="background-color: rgba(59, 130, 246, 0.1); border: 2px solid rgba(59, 130, 246, 0.5); border-radius: 10px; padding: 20px; min-width: 300px; flex-shrink: 0; transform: transition-transform 0.3s ease;">
            <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 15px;">
              <div style="width: 40px; height: 40px; border-radius: 50%; background-color: rgba(59, 130, 246, 0.2); display: flex; justify-content: center; align-items: center; border: 2px solid #3B82F6;">
                <i class="fa fa-shield" style="color: #3B82F6; font-size: 1.5rem;"></i>
              </div>
              <h3 style="color: #3B82F6; font-size: 1.8rem; margin: 0;">防御强化</h3>
            </div>
            <div class="tech-nodes">
              <div class="tech-node" data-branch="defense" data-level="1" style="margin-bottom: 15px; padding: 15px; border-radius: 8px; background-color: rgba(255, 255, 255, 0.1); border-left: 4px solid #3B82F6; transition: transform 0.2s ease;">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                  <span style="font-weight: bold; font-size: 1.1rem;">等级 1</span>
                  <span style="color: #8B5CF6; font-weight: bold;">10 点</span>
                </div>
                <p style="font-size: 1rem; color: rgba(255, 255, 255, 0.9); margin-bottom: 10px;">核心生命值+10%</p>
                <button class="upgrade-tech-button" style="width: 100%; padding: 8px; margin-top: 5px; border-radius: 5px; background-color: rgba(139, 92, 246, 0.7); color: white; cursor: pointer; transition: all 0.3s ease; font-size: 1rem; font-weight: bold;">升级</button>
              </div>
              <div class="tech-node" data-branch="defense" data-level="2" style="margin-bottom: 15px; padding: 15px; border-radius: 8px; background-color: rgba(255, 255, 255, 0.1); border-left: 4px solid #3B82F6; transition: transform 0.2s ease;">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                  <span style="font-weight: bold; font-size: 1.1rem;">等级 2</span>
                  <span style="color: #8B5CF6; font-weight: bold;">20 点</span>
                </div>
                <p style="font-size: 1rem; color: rgba(255, 255, 255, 0.9); margin-bottom: 10px;">核心生命值+20%，炮塔生命值+10%</p>
                <button class="upgrade-tech-button" style="width: 100%; padding: 8px; margin-top: 5px; border-radius: 5px; background-color: rgba(139, 92, 246, 0.7); color: white; cursor: pointer; transition: all 0.3s ease; font-size: 1rem; font-weight: bold;">升级</button>
              </div>
              <div class="tech-node" data-branch="defense" data-level="3" style="margin-bottom: 15px; padding: 15px; border-radius: 8px; background-color: rgba(255, 255, 255, 0.1); border-left: 4px solid #3B82F6; transition: transform 0.2s ease;">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                  <span style="font-weight: bold; font-size: 1.1rem;">等级 3</span>
                  <span style="color: #8B5CF6; font-weight: bold;">30 点</span>
                </div>
                <p style="font-size: 1rem; color: rgba(255, 255, 255, 0.9); margin-bottom: 10px;">核心生命值+30%，炮塔生命值+20%</p>
                <button class="upgrade-tech-button" style="width: 100%; padding: 8px; margin-top: 5px; border-radius: 5px; background-color: rgba(139, 92, 246, 0.7); color: white; cursor: pointer; transition: all 0.3s ease; font-size: 1rem; font-weight: bold;">升级</button>
              </div>
            </div>
          </div>
          
          <!-- 经济强化分支 -->
          <div class="tech-branch" style="background-color: rgba(16, 185, 129, 0.1); border: 2px solid rgba(16, 185, 129, 0.5); border-radius: 10px; padding: 20px; min-width: 300px; flex-shrink: 0; transform: transition-transform 0.3s ease;">
            <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 15px;">
              <div style="width: 40px; height: 40px; border-radius: 50%; background-color: rgba(16, 185, 129, 0.2); display: flex; justify-content: center; align-items: center; border: 2px solid #10B981;">
                <i class="fa fa-money" style="color: #10B981; font-size: 1.5rem;"></i>
              </div>
              <h3 style="color: #10B981; font-size: 1.8rem; margin: 0;">经济强化</h3>
            </div>
            <div class="tech-nodes">
              <div class="tech-node" data-branch="economy" data-level="1" style="margin-bottom: 15px; padding: 15px; border-radius: 8px; background-color: rgba(255, 255, 255, 0.1); border-left: 4px solid #10B981; transition: transform 0.2s ease;">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                  <span style="font-weight: bold; font-size: 1.1rem;">等级 1</span>
                  <span style="color: #8B5CF6; font-weight: bold;">10 点</span>
                </div>
                <p style="font-size: 1rem; color: rgba(255, 255, 255, 0.9); margin-bottom: 10px;">敌人掉落金钱+5%</p>
                <button class="upgrade-tech-button" style="width: 100%; padding: 8px; margin-top: 5px; border-radius: 5px; background-color: rgba(139, 92, 246, 0.7); color: white; cursor: pointer; transition: all 0.3s ease; font-size: 1rem; font-weight: bold;">升级</button>
              </div>
              <div class="tech-node" data-branch="economy" data-level="2" style="margin-bottom: 15px; padding: 15px; border-radius: 8px; background-color: rgba(255, 255, 255, 0.1); border-left: 4px solid #10B981; transition: transform 0.2s ease;">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                  <span style="font-weight: bold; font-size: 1.1rem;">等级 2</span>
                  <span style="color: #8B5CF6; font-weight: bold;">20 点</span>
                </div>
                <p style="font-size: 1rem; color: rgba(255, 255, 255, 0.9); margin-bottom: 10px;">敌人掉落金钱+10%，炮塔建造成本-5%</p>
                <button class="upgrade-tech-button" style="width: 100%; padding: 8px; margin-top: 5px; border-radius: 5px; background-color: rgba(139, 92, 246, 0.7); color: white; cursor: pointer; transition: all 0.3s ease; font-size: 1rem; font-weight: bold;">升级</button>
              </div>
              <div class="tech-node" data-branch="economy" data-level="3" style="margin-bottom: 15px; padding: 15px; border-radius: 8px; background-color: rgba(255, 255, 255, 0.1); border-left: 4px solid #10B981; transition: transform 0.2s ease;">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                  <span style="font-weight: bold; font-size: 1.1rem;">等级 3</span>
                  <span style="color: #8B5CF6; font-weight: bold;">30 点</span>
                </div>
                <p style="font-size: 1rem; color: rgba(255, 255, 255, 0.9); margin-bottom: 10px;">敌人掉落金钱+15%，炮塔建造成本-10%</p>
                <button class="upgrade-tech-button" style="width: 100%; padding: 8px; margin-top: 5px; border-radius: 5px; background-color: rgba(139, 92, 246, 0.7); color: white; cursor: pointer; transition: all 0.3s ease; font-size: 1rem; font-weight: bold;">升级</button>
              </div>
            </div>
          </div>
        </div>
        
        <!-- 滚动指示器 -->
        <div style="display: flex; gap: 8px; margin-top: 20px;">
          <div class="scroll-indicator active" data-index="0" style="width: 12px; height: 12px; border-radius: 50%; background-color: #8B5CF6; cursor: pointer; transition: all 0.3s ease;"></div>
          <div class="scroll-indicator" data-index="1" style="width: 12px; height: 12px; border-radius: 50%; background-color: rgba(139, 92, 246, 0.3); cursor: pointer; transition: all 0.3s ease;"></div>
          <div class="scroll-indicator" data-index="2" style="width: 12px; height: 12px; border-radius: 50%; background-color: rgba(139, 92, 246, 0.3); cursor: pointer; transition: all 0.3s ease;"></div>
        </div>
        
        <!-- 关闭按钮 -->
        <button id="close-tech-tree" style="margin-top: 2rem; padding: 0.8rem 1.5rem; border-radius: 5px; background-color: #3B82F6; color: white; font-weight: bold; cursor: pointer; transition: all 0.3s ease; display: none;">关闭</button>
      </div>
    </div>
    

  </div>

  <script>
    // 游戏数据
    const gameData = {
      // 游戏状态
      gameState: 'menu', // menu, difficulty, admin-password, admin, encyclopedia, game, game-over, victory, card-draw, mission-select, skill-select
      
      // 任务系统
      missionSystem: {
        currentMission: null,
        completedMissions: [],
        availableMissions: [
          { id: 'mission_1', name: '初入战场', description: '成功防御10波敌人', reward: { money: 500, techPoints: 10 }, completed: false },
          { id: 'mission_2', name: '炮塔大师', description: '建造5种不同类型的炮塔', reward: { money: 800, techPoints: 15 }, completed: false },
          { id: 'mission_3', name: '精准打击', description: '使用狙击塔击杀50个敌人', reward: { money: 1000, techPoints: 20 }, completed: false },
          { id: 'mission_4', name: '科技先驱', description: '将科技等级提升到5级', reward: { money: 1500, techPoints: 50 }, completed: false },
          { id: 'mission_5', name: '生存专家', description: '在核心血量低于20%的情况下坚持3波', reward: { money: 2000, techPoints: 30 }, completed: false }
        ],
        missionProgress: {}
      },
      
      // 成就系统
      achievementSystem: {
        achievements: [
          { id: 'achievement_1', name: '防御大师', description: '成功防御100波敌人', reward: { techPoints: 100 }, completed: false },
          { id: 'achievement_2', name: '炮塔收藏家', description: '解锁所有炮塔类型', reward: { techPoints: 150 }, completed: false },
          { id: 'achievement_3', name: '经济大师', description: '单局游戏累积10000金钱', reward: { techPoints: 80 }, completed: false },
          { id: 'achievement_4', name: '科技达人', description: '科技等级达到最高', reward: { techPoints: 200 }, completed: false },
          { id: 'achievement_5', name: '完美防御', description: '在不损失核心血量的情况下通关', reward: { techPoints: 250 }, completed: false }
        ],
        recentlyUnlocked: []
      },
      
      // 技能系统
      skillSystem: {
        skills: [
          { id: 'skill_orbital_strike', name: '轨道打击', description: '对指定区域造成大量伤害', cooldown: 60, duration: 0, unlocked: true, level: 1, maxLevel: 3, damage: 500, radius: 3 },
          { id: 'skill_time_freeze', name: '时间冻结', description: '冻结所有敌人一段时间', cooldown: 45, duration: 5, unlocked: false, level: 1, maxLevel: 3, freezeTime: 3 },
          { id: 'skill_money_boost', name: '经济繁荣', description: '暂时提高击杀敌人的金钱奖励', cooldown: 30, duration: 20, unlocked: false, level: 1, maxLevel: 3, moneyMultiplier: 1.5 },
          { id: 'skill_shield_barrier', name: '护盾屏障', description: '为所有炮塔提供临时护盾', cooldown: 50, duration: 15, unlocked: false, level: 1, maxLevel: 3, shieldAmount: 200 },
          { id: 'skill_core_heal', name: '核心修复', description: '立即恢复核心血量', cooldown: 120, duration: 0, unlocked: false, level: 1, maxLevel: 3, healAmount: 50 }
        ],
        skillPoints: 0,
        activeSkills: [],
        skillCooldowns: {}
      },
      
      // 地图系统
      mapSystem: {
        currentMap: 'default',
        unlockedMaps: ['default'],
        maps: {
          'default': { name: '标准战场', description: '经典的塔防地图', difficulty: 'normal', waves: 100 },
          'canyon': { name: '峡谷通道', description: '狭窄的通道，适合集中防御', difficulty: 'hard', waves: 80, unlocked: false },
          'crossroads': { name: '十字路口', description: '多路径地图，需要分散防御', difficulty: 'expert', waves: 120, unlocked: false },
          'island': { name: '孤岛防御', description: '核心位于中央，四面受敌', difficulty: 'insane', waves: 150, unlocked: false }
        }
      },
      
      // 存档系统
      saveSystem: {
        saves: [],
        currentSave: null,
        autoSaveEnabled: true,
        saveSlots: 3
      },
      // 科技系统
      techSystem: {
        techPoints: 0, // 科技点总数
        attackTechLevel: 0, // 攻击科技等级
        defenseTechLevel: 0, // 防御科技等级
        economyTechLevel: 0, // 经济科技等级
        techPointsPerKill: { // 不同类型怪物的科技点奖励
          normal: 1,
          fast: 1,
          heavy: 2,
          shield: 2,
          healer: 3,
          drone: 2,
          bomber: 3,
          mech: 4,
          thief: 3,
          charger: 4,
          assassin: 5,
          reaper: 5,
          stealth: 5,
          'mini-boss': 20,
          boss: 100
        }
      },
      // 抽卡系统
      cardDraw: {
        isActive: false,
        availableRewards: [],
        selectedReward: null,
        cardsDrawn: 0,
        cardsPerDraw: 3,
        drawChance: 1.0, // 100% 概率触发抽卡
        cardTypes: {
          money: { weight: 30, icon: '💰', color: '#10B981' },
          towerUpgrade: { weight: 25, icon: '🔧', color: '#3B82F6' },
          towerUnlock: { weight: 15, icon: '🔓', color: '#F59E0B' },
          specialPower: { weight: 15, icon: '✨', color: '#8B5CF6' },
          instantEffect: { weight: 15, icon: '💥', color: '#EF4444' }
        }
      },
      isAdminMode: false,
      selectedTower: null,
      selectedCell: null,
      currentWave: 1,
      difficulty: 'easy',
      money: 1000,
      coreHealth: 100,
      isGameOver: false,
      isVictory: false,
      isWaveActive: false,
      waveStartTime: 0,
      waveDelay: 5000, // 5秒波间隔
      currentBoss: null,
      
      // 游戏参数
      gridSize: { width: 18, height: 12 },
      cellSize: 35,
      gridOffset: { x: 100, y: 60 },
      
      // 游戏对象
      towers: [],
      monsters: [],
      allies: [],
      projectiles: [],
      explosions: [],
      effects: [],
      floatingTexts: [],
      
      // 对象池系统
      objectPools: {
        projectiles: [],
        explosions: [],
        effects: [],
        floatingTexts: []
      },
      
      // 路径数据
      path: [],
      blockedCells: new Set(),
      
      // 初始炮塔数据
      towerTypes: [
        // 基础炮塔
        { 
          id: 'energy',          // 炮塔唯一标识
          name: '能量炮',         // 炮塔名称
          range: 6,              // 攻击范围(格数)
          damage: 10,            // 基础伤害
          fireRate: 1.0,         // 攻击间隔(秒)
          price: 100,            // 购买价格
          special: '最基础的炮台，也是最便宜的' // 特殊效果描述
        },
        { 
          id: 'rapid', 
          name: '速射炮', 
          range: 6, 
          damage: 10, 
          fireRate: 0.1,         // 极快的攻击速度
          price: 300, 
          special: '极速射击，快速歼灭' 
        },
        { 
          id: 'ice', 
          name: '冰锥炮', 
          range: 6, 
          damage: 10, 
          fireRate: 1.2, 
          price: 200, 
          special: '减速减速，射中后怪物速度减慢50%，持续五秒' 
        },
        { 
          id: 'pierce', 
          name: '穿刺炮', 
          range: 6, 
          damage: 5,             // 较低基础伤害，但有穿透效果
          fireRate: 0.8, 
          price: 400, 
          special: '完美穿刺，用穿透性尖刺击中怪物' 
        },
        { 
          id: 'laser', 
          name: '激光炮', 
          range: 6, 
          damage: 1,             // 极低基础伤害，但攻击频率极高
          fireRate: 0.01,        // 极高攻击频率
          price: 500, 
          special: '发射激光，用穿透性激光击中怪物' 
        },
        
        // 高级炮塔
        { 
          id: 'rocket', 
          name: '火箭炮', 
          range: 6, 
          damage: 120,           // 高爆发伤害
          fireRate: 1.3, 
          price: 600, 
          special: '范围爆破，激动怪物后炸开形成0.3格半径的冲击波并受到伤害' 
        },
        { 
          id: 'electro', 
          name: '电磁炮', 
          range: 6, 
          damage: 90, 
          fireRate: 1.5, 
          price: 700, 
          special: '眩晕眩晕，发射电磁击中怪物后炸开形成半径为0.2格的冲击波被冲击波波及和被射中的怪物获得一秒的眩晕效果并受到伤害' 
        },
        { 
          id: 'titan', 
          name: '泰坦炮', 
          range: 8,              // 较大攻击范围
          damage: 320,           // 超高单体伤害
          fireRate: 1.8, 
          price: 1000, 
          special: '超高伤害，毁灭每一个击中的怪物' 
        },
        { 
          id: 'sniper', 
          name: '狙击炮', 
          range: 24,             // 超远攻击范围
          damage: 500,           // 极高单体伤害
          fireRate: 2.4,         // 较长攻击间隔
          price: 1200, 
          special: '弹无虚发，精准打击每个怪物，有25%的概率造成双倍伤害' 
        },
        
        // 功能型炮塔
        { 
          id: 'anti-air', 
          name: '防空炮', 
          range: 10, 
          damage: 100, 
          fireRate: 0.5, 
          price: 250, 
          special: '专业防空，对无人机精准打击（只攻击无人机）' 
        },
        { 
          id: 'flame', 
          name: '烈火炮', 
          range: 6, 
          damage: 30, 
          fireRate: 0.8, 
          price: 350, 
          special: '溶解溶解，自身被冰霜法师冻结十秒后解冻，并且在自己没被冻住时，可保护3×3范围内的炮塔不被冻住' 
        },
        { 
          id: 'howitzer', 
          name: '加农炮', 
          range: 15, 
          damage: 1500,          // 极高伤害
          fireRate: 30.0,        // 极长冷却时间
          price: 2000, 
          special: '手动操控，对3x3范围内的敌人造成1500点伤害' 
        },
        
        // 特殊效果炮塔
        { 
          id: 'toxin', 
          name: '毒素炮', 
          range: 8, 
          damage: 40, 
          fireRate: 1.0, 
          price: 800, 
          special: '剧毒腐蚀，发射毒弹使敌人中毒，每秒造成20点伤害，持续5秒' 
        },
        { 
          id: 'sentinel', 
          name: '哨兵炮', 
          range: 12, 
          damage: 80, 
          fireRate: 0.7, 
          price: 1500, 
          special: '警戒范围，优先攻击精英怪物和小BOSS，对精英怪物伤害提升50%' 
        },
        { 
          id: 'quantum', 
          name: '量子炮', 
          range: 15, 
          damage: 500, 
          fireRate: 2.0, 
          price: 5000,           // 最高基础价格
          special: '量子裂变，有20%概率造成范围伤害，对BOSS造成额外100%伤害，需要击败5个小BOSS解锁' 
        },
        
        // 辅助型炮塔
        { 
          id: 'amplifier', 
          name: '能量增幅塔', 
          range: 0,              // 无攻击范围
          damage: 0,             // 无直接伤害
          fireRate: 0,           // 无攻击频率
          price: 1200, 
          special: '能量光环，为3×3范围内的所有炮台提供25%伤害加成' 
        },
        { 
          id: 'repair', 
          name: '修复塔', 
          range: 0,              // 无攻击范围
          damage: 0,             // 无直接伤害
          fireRate: 0,           // 无攻击频率
          price: 1500, 
          special: '自动修复，每3秒修复3×3范围内受损炮台10点生命值' 
        },
        
        // 新增高级炮塔
        { 
          id: 'gravity', 
          name: '重力炮', 
          range: 10, 
          damage: 150, 
          fireRate: 2.0, 
          price: 1800, 
          special: '重力场控制，发射重力波使目标区域内的敌人减速70%，持续3秒，并造成范围伤害', 
          imageUrl: 'https://p3-flow-imagex-sign.byteimg.com/tos-cn-i-a9rns2rl98/rc/pc/super_tool/ca2e3a7040b745a081f3087fe5e6ff3f~tplv-a9rns2rl98-image.image?rcl=20251207152630D25E64ADC4CEEEEBFF66&rk3s=8e244e95&rrcfp=f06b921b&x-expires=1767684465&x-signature=yTEvONtYTCPju36s2sKHqJGui18%3D' 
        },
        { 
          id: 'pulse', 
          name: '脉冲炮', 
          range: 8, 
          damage: 80, 
          fireRate: 0.5, 
          price: 1200, 
          special: '能量脉冲，发射紫色脉冲波，对一条直线上的敌人造成伤害，并使他们短暂停顿', 
          imageUrl: 'https://p3-flow-imagex-sign.byteimg.com/tos-cn-i-a9rns2rl98/rc/pc/super_tool/6ce2bc64843246d5a8d40c1c84c2fb80~tplv-a9rns2rl98-image.image?rcl=20251207152630D25E64ADC4CEEEEBFF66&rk3s=8e244e95&rrcfp=f06b921b&x-expires=1767684474&x-signature=EZt9YWsXXCNJFBeJKYN21QA80oY%3D' 
        },
        { 
          id: 'plasma', 
          name: '等离子炮', 
          range: 12, 
          damage: 200, 
          fireRate: 1.5, 
          price: 2200, 
          special: '等离子爆炸，发射高温等离子球，命中后产生范围爆炸，并对敌人造成持续灼烧效果', 
          imageUrl: 'https://p9-flow-imagex-sign.byteimg.com/tos-cn-i-a9rns2rl98/rc/pc/super_tool/3ec270ab20894d3da94f5c007fb4df54~tplv-a9rns2rl98-image.image?rcl=20251207152630D25E64ADC4CEEEEBFF66&rk3s=8e244e95&rrcfp=f06b921b&x-expires=1767684485&x-signature=q0wOjLMUV1mnLm%2FON5wNE9v34Vk%3D' 
        },
        { 
          id: 'ion', 
          name: '离子炮', 
          range: 15, 
          damage: 300, 
          fireRate: 2.5, 
          price: 2800, 
          special: '离子束攻击，发射高能离子束，对单一目标造成巨大伤害，并有30%几率穿透目标攻击后续敌人', 
          imageUrl: 'https://p3-flow-imagex-sign.byteimg.com/tos-cn-i-a9rns2rl98/rc/pc/super_tool/d9ff6212f60545d4aada5c0b9808bb51~tplv-a9rns2rl98-image.image?rcl=20251207152630D25E64ADC4CEEEEBFF66&rk3s=8e244e95&rrcfp=f06b921b&x-expires=1767684505&x-signature=rW0PAY3g7dh1T86lZCv2DptZPiU%3D' 
        },
        { 
          id: 'missile', 
          name: '导弹塔', 
          range: 20,             // 超远攻击范围
          damage: 400,           // 高爆发伤害
          fireRate: 3.0, 
          price: 3500, 
          special: '精确制导，发射追踪导弹，对远距离目标造成巨大伤害，并有50%几率造成范围爆炸' 
        },
        { 
          id: 'nano', 
          name: '纳米修复塔', 
          range: 0,              // 无攻击范围
          damage: 0,             // 无直接伤害
          fireRate: 0,           // 无攻击频率
          price: 2000, 
          special: '纳米机器人修复，每2秒修复3×3范围内受损炮台20点生命值，并为满血炮台提供临时护盾' 
        },
        { 
          id: 'emp', 
          name: 'EMP电磁脉冲塔', 
          range: 10, 
          damage: 50, 
          fireRate: 4.0,         // 较长冷却时间
          price: 3000, 
          special: '电磁脉冲，发射EMP波，对范围内的机械单位造成双倍伤害，并使其瘫痪2秒' 
        },
        { 
          id: 'beacon', 
          name: '信标塔', 
          range: 0,              // 无攻击范围
          damage: 0,             // 无直接伤害
          fireRate: 0,           // 无攻击频率
          price: 1800, 
          special: '战略信标，放置后为周围8格内的所有炮台提供15%攻击速度加成和10%伤害加成' 
        }
      ],
      
      // 初始怪物数据
      monsterTypes: [
        // 基础怪物
        { 
          id: 'normal',          // 怪物唯一标识
          name: '普通士兵',       // 怪物名称
          health: 100,           // 生命值
          speed: 3.5,              // 移动速度
          coreDamage: 2,         // 对核心的伤害
          special: '最基础的怪物' // 特殊能力描述
        },
        { 
          id: 'fast', 
          name: '极速士兵', 
          health: 80,            // 较低生命值
          speed: 6,              // 高移动速度
          coreDamage: 2, 
          special: '快如闪电，直逼防线' 
        },
        { 
          id: 'heavy', 
          name: '重甲士兵', 
          health: 150,           // 较高生命值
          speed: 1.5,              // 低移动速度
          coreDamage: 2, 
          special: '移动坦克，坚不可摧' 
        },
        
        // 特殊能力怪物
        { 
          id: 'shield', 
          name: '盾牌士兵', 
          health: 200, 
          speed: 3, 
          coreDamage: 5, 
          special: '保护保护，保护自身半径一格以内的怪物，让他们拥有90%的免伤效果（自己没有）' 
        },
        { 
          id: 'healer', 
          name: '医疗兵', 
          health: 100, 
          speed: 4, 
          coreDamage: 5, 
          special: '治疗治疗，治疗全场的怪物，治疗效率15/秒' 
        },
        { 
          id: 'drone', 
          name: '无人机', 
          health: 1, 
          speed: 8,              // 极高移动速度
          coreDamage: 12, 
          special: '极速飞跃，无视地形飞向核心' 
        },
        
        // 危险怪物
        { 
          id: 'bomber', 
          name: '爆破兵', 
          health: 120, 
          speed: 3, 
          coreDamage: 12, 
          special: '爆破爆破，登场后一段时间爆炸，炸毁3×3范围内的炮台，自身也会死亡，但是如果炮台直接将其击杀则不爆炸' 
        },
        { 
          id: 'mech', 
          name: '机械士兵', 
          health: 200, 
          speed: 1.5, 
          coreDamage: 15, 
          special: '机械之心，免疫眩晕效果和减速效果' 
        },
        { 
          id: 'thief', 
          name: '窃取者', 
          health: 100, 
          speed: 7,              // 高移动速度
          coreDamage: 15, 
          special: '音速窃取，登场后击杀怪物只给10%的金钱，并且每秒钟窃取玩家10的金钱' 
        },
        
        // 精英怪物
        { 
          id: 'charger', 
          name: '冲锋兵', 
          health: 200, 
          speed: 3.5, 
          coreDamage: 15, 
          special: '极速冲锋，受到伤害后速度参数变为6' 
        },
        { 
          id: 'assassin', 
          name: '刺客', 
          health: 120, 
          speed: 5,              // 高移动速度
          coreDamage: 20, 
          special: '偷家偷家，受到伤害后无敌5s并且速度参数变为8' 
        },
        { 
          id: 'reaper', 
          name: '收割者', 
          health: 500,           // 高生命值
          speed: 1.2, 
          coreDamage: 20, 
          special: '摧毁摧毁，登场后每隔三秒向上下左右随机一方向发射一条长三格的激光，激光直接摧毁炮塔' 
        },
        { 
          id: 'stealth', 
          name: '隐形刺客', 
          health: 250, 
          speed: 5,              // 高移动速度
          coreDamage: 30, 
          special: '隐形突袭，每隔8秒进入3秒隐形状态，期间炮台无法攻击' 
        },
        
        // BOSS级别怪物
        { 
          id: 'mini-boss', 
          name: 'BOSS', 
          health: 8000,          // 极高生命值
          speed: 0.8,            // 低移动速度
          coreDamage: 80,        // 高核心伤害
          special: '每回合末尾出现的强力怪物，生命值高，伤害大，击败后获得大量金钱奖励' 
        },
        { 
          id: 'boss', 
          name: '最终boss', 
          health: 100000,        // 最终BOSS生命值
          speed: 0.5,            // 极低移动速度
          coreDamage: 100,       // 极高核心伤害
          special: '最终之战，登场后最底下出现血条，并在自身位置召唤以上的各种怪物，并每隔五秒锁定全场的三个炮台，发射火箭弹并摧毁' 
        },
        
        // 新增高级怪物
        { 
          id: 'spider', 
          name: '机械蜘蛛', 
          health: 400, 
          speed: 4, 
          coreDamage: 25, 
          special: '攀爬突袭，能够攀爬墙壁快速接近核心，受到攻击时有20%几率闪避', 
          imageUrl: 'https://p3-flow-imagex-sign.byteimg.com/tos-cn-i-a9rns2rl98/rc/pc/super_tool/396a4f6736e141ad8a63bd804c9acc64~tplv-a9rns2rl98-image.image?rcl=20251207152630D25E64ADC4CEEEEBFF66&rk3s=8e244e95&rrcfp=f06b921b&x-expires=1767684525&x-signature=fms69pSzOlTVjp62mlmHDO%2Bi8JU%3D' 
        },
        { 
          id: 'juggernaut', 
          name: '重装战车', 
          health: 1200,          // 很高生命值
          speed: 0.8,            // 低移动速度
          coreDamage: 40,        // 高核心伤害
          special: '重装碾压，移动缓慢但防御极高，对炮台造成大量伤害，免疫减速效果' 
        },
        { 
          id: 'swarmer', 
          name: '蜂群无人机', 
          health: 50,            // 低生命值
          speed: 10,             // 极高移动速度
          coreDamage: 8, 
          special: '群体攻击，每次出现都是10只一组，单体脆弱但数量众多，优先攻击炮台' 
        },
        { 
          id: 'corruptor', 
          name: '腐蚀者', 
          health: 600,           // 较高生命值
          speed: 3, 
          coreDamage: 30, 
          special: '腐蚀装甲，能够腐蚀炮台装甲，使炮台攻击力降低30%，持续8秒' 
        }
      ],
      
      // 难度设置
      difficultySettings: {
        easy: { initialMoney: 1000, monsterHealthMultiplier: 0.8, monsterSpeedMultiplier: 1.0, monsterCoreDamageMultiplier: 0.8, moneyPerKill: 20, moneyMultiplier: 1.2 },
        normal: { initialMoney: 800, monsterHealthMultiplier: 1.0, monsterSpeedMultiplier: 1.0, monsterCoreDamageMultiplier: 1.0, moneyPerKill: 20, moneyMultiplier: 1.0 },
        hard: { initialMoney: 600, monsterHealthMultiplier: 1.5, monsterSpeedMultiplier: 1.2, monsterCoreDamageMultiplier: 1.5, moneyPerKill: 15, moneyMultiplier: 0.8 },
        hell: { initialMoney: 400, monsterHealthMultiplier: 2.0, monsterSpeedMultiplier: 1.5, monsterCoreDamageMultiplier: 2.0, moneyPerKill: 10, moneyMultiplier: 0.6 }
      },
      
      // 己方单位类型
      allyTypes: [
        {
          id: 'soldier',
          name: '士兵',
          health: 200,
          damage: 20,
          speed: 3.5,
          attackRange: 2,
          price: 100,
          special: '基础近战单位'
        },
        {
          id: 'archer',
          name: '弓箭手',
          health: 150,
          damage: 30,
          speed: 3.5,
          attackRange: 5,
          price: 150,
          special: '远程攻击单位'
        },
        {
          id: 'tank',
          name: '坦克',
          health: 500,
          damage: 40,
          speed: 1.5,
          attackRange: 1,
          price: 300,
          special: '高生命值单位'
        },
        {
          id: 'healer',
          name: '医疗兵',
          health: 100,
          damage: 0,
          speed: 4,
          attackRange: 3,
          price: 200,
          special: '治疗友方单位'
        },
        {
          id: 'mage',
          name: '法师',
          health: 120,
          damage: 25,
          speed: 3.5,
          attackRange: 4,
          price: 250,
          special: '范围伤害，攻击时对目标周围敌人造成50%伤害'
        },
        {
          id: 'converter',
          name: '转化者',
          health: 1,
          damage: 0,
          speed: 3.5,
          attackRange: 0,
          price: 400,
          special: '无伤害，死亡时可将周围怪物变为己方的'
        }
      ],
      
      // 波数设置
      waveSettings: {
        baseMonsters: ['normal', 'fast', 'heavy'],
        allMonsters: ['normal', 'fast', 'heavy', 'shield', 'healer', 'drone', 'bomber', 'mech', 'thief', 'charger', 'assassin', 'reaper', 'stealth', 'juggernaut', 'swarmer', 'corruptor'],
        // 无尽模式设置
        endlessMode: true,
        maxBaseWave: 100, // 基础波数，超过后进入无尽模式
        monsterHealthMultiplierPerWave: 0.05, // 每波怪物血量增加5%
        monsterSpeedMultiplierPerWave: 0.01, // 每波怪物速度增加1%
        monsterCountMultiplierPerWave: 0.02, // 每波怪物数量增加2%
        maxMonsterCount: 100, // 最大怪物数量限制
        eliteMonsterChancePerWave: 0.02, // 每波精英怪物概率增加2%
        eliteMonsterHealthMultiplier: 3, // 精英怪物血量倍数
        eliteMonsterSpeedMultiplier: 1.5, // 精英怪物速度倍数
        eliteMonsterRewardMultiplier: 5 // 精英怪物奖励倍数
      },
      
      // 游戏时间
      lastTime: 0,
      deltaTime: 0
    };
    
    // 保存初始数据（用于重置）
    const initialTowerTypes = JSON.parse(JSON.stringify(gameData.towerTypes));
    const initialMonsterTypes = JSON.parse(JSON.stringify(gameData.monsterTypes));
    
    // 特殊炮塔图片URL
    const quantumTowerImageUrl = 'https://p3-flow-imagex-sign.byteimg.com/tos-cn-i-a9rns2rl98/rc/pc/super_tool/4acefeffcd7b49a4a26db9887e3dccfb~tplv-a9rns2rl98-image.image?rcl=20251130162751B37E07D138961EDD5DC5&rk3s=8e244e95&rrcfp=f06b921b&x-expires=1767083320&x-signature=xzzX4nuxGqpt5EBKAGOrIC8g7z0%3D';
    const amplifierTowerImageUrl = 'https://p3-flow-imagex-sign.byteimg.com/tos-cn-i-a9rns2rl98/rc/pc/super_tool/1fa35b737a244b30b5783fea7fcd05a6~tplv-a9rns2rl98-image.image?rcl=20251130174423DDC6F44409E3B951AD01&rk3s=8e244e95&rrcfp=f06b921b&x-expires=1767087883&x-signature=CyS93EfceeBR%2FvH23aFgEDiIPZw%3D';
    const repairTowerImageUrl = 'https://p3-flow-imagex-sign.byteimg.com/tos-cn-i-a9rns2rl98/rc/pc/super_tool/da4296081c3f49c1ba80a9bc8b34410c~tplv-a9rns2rl98-image.image?rcl=20251130174423DDC6F44409E3B951AD01&rk3s=8e244e95&rrcfp=f06b921b&x-expires=1767087883&x-signature=TXGnb6FzTtJa1pFHkTTl548v6Gc%3D';
    const stealthMonsterImageUrl = 'https://p3-flow-imagex-sign.byteimg.com/tos-cn-i-a9rns2rl98/rc/pc/super_tool/3531f1428250457d9b3d8aef7a3366f2~tplv-a9rns2rl98-image.image?rcl=20251130174423DDC6F44409E3B951AD01&rk3s=8e244e95&rrcfp=f06b921b&x-expires=1767087883&x-signature=SLTq8xkGV0BPUvXkRtSyYxTH8kg%3D';
    
    // 获取DOM元素
    const menuScreen = document.getElementById('menu-screen');
    const difficultyScreen = document.getElementById('difficulty-screen');
    const adminPasswordScreen = document.getElementById('admin-password-screen');
    const adminScreen = document.getElementById('admin-screen');
    const encyclopediaScreen = document.getElementById('encyclopedia-screen');
    const gameScreen = document.getElementById('game-screen');
    const gameOverScreen = document.getElementById('game-over-screen');
    const victoryScreen = document.getElementById('victory-screen');
    const towerInfoScreen = document.getElementById('tower-info-screen');
    
    const adminPasswordInput = document.getElementById('admin-password');
    const towersTableBody = document.getElementById('towers-table-body');
    const monstersTableBody = document.getElementById('monsters-table-body');
    const towersEncyclopedia = document.getElementById('towers-encyclopedia');
    const monstersEncyclopedia = document.getElementById('monsters-encyclopedia');
    const towerSelection = document.getElementById('tower-selection');
    
    const difficultyDisplay = document.getElementById('difficulty-display');
    const waveDisplay = document.getElementById('wave-display');
    const moneyDisplay = document.getElementById('money-display');
    const coreHealthDisplay = document.getElementById('core-health-display');
    const quantumTowerProgress = document.getElementById('quantum-tower-progress');
    const quantumTowerIcon = document.getElementById('quantum-tower-icon');
    const waveNotification = document.getElementById('wave-notification');
    const bossHealthBar = document.getElementById('boss-health-bar');
    const bossHealthFill = document.getElementById('boss-health-fill');
    const bossHealthText = document.getElementById('boss-health-text');
    const wavesSurvived = document.getElementById('waves-survived');
    
    const towerInfoName = document.getElementById('tower-info-name');
    const towerInfoLevel = document.getElementById('tower-info-level');
    const towerInfoRange = document.getElementById('tower-info-range');
    const towerInfoDamage = document.getElementById('tower-info-damage');
    const towerInfoFireRate = document.getElementById('tower-info-fire-rate');
    const towerInfoSpecial = document.getElementById('tower-info-special');
    const upgradeCost = document.getElementById('upgrade-cost');
    const sellAmount = document.getElementById('sell-amount');
    
    const gameCanvas = document.getElementById('game-canvas');
    const ctx = gameCanvas.getContext('2d');
    
    // 游戏主循环 - 移除重复的gameLoop函数
    
    // 更新游戏逻辑 - 移除重复的update和render函数
    
    // 处理画布点击事件
    function handleCanvasClick(event) {
      if (gameData.gameState !== 'game') return;
      
      const rect = gameCanvas.getBoundingClientRect();
      const x = event.clientX - rect.left;
      const y = event.clientY - rect.top;
      
      // 转换为网格坐标
      const gridX = Math.floor((x - gameData.gridOffset.x) / gameData.cellSize);
      const gridY = Math.floor((y - gameData.gridOffset.y) / gameData.cellSize);
      
      // 检查是否在有效网格范围内
      if (gridX >= 0 && gridX < gameData.gridSize.width && gridY >= 0 && gridY < gameData.gridSize.height) {
        // 检查是否选择了单位类型
        if (gameData.selectedAllyType) {
          placeAlly(gameData.selectedAllyType);
          // 清除选择
          gameData.selectedAllyType = null;
        }
      }
    }
    
    // 购买单位函数
    function buyAlly(allyTypeId) {
      console.log('buyAlly called with type:', allyTypeId);
      if (gameData.gameState !== 'game') {
        console.log('Game not in active state');
        return;
      }
      
      // 查找单位类型
      const allyType = gameData.allyTypes.find(type => type.id === allyTypeId);
      if (!allyType) {
        console.error('未找到单位类型:', allyTypeId);
        return;
      }
      
      // 检查金钱是否足够
      if (gameData.money < allyType.price) {
        const endPoint = gameData.path[gameData.path.length - 1];
        showFloatingText(endPoint.x, endPoint.y, '金钱不足！', '#EF4444', 1);
        return;
      }
      
      // 从核心（路径终点）出发
      const endPoint = gameData.path[gameData.path.length - 1];
      
      // 创建单位
      const ally = {
        type: allyTypeId,
        name: allyType.name,
        health: allyType.health,
        maxHealth: allyType.health,
        damage: allyType.damage,
        speed: allyType.speed,
        attackRange: allyType.attackRange,
        attackSpeed: 1.0, // 默认攻击速度，每秒攻击一次
        attackTimer: 0,
        healTimer: 0,
        x: endPoint.x,
        y: endPoint.y,
        pathIndex: gameData.path.length - 1, // 从终点开始
        moving: true, // 初始状态为移动
        id: Date.now() + Math.random() // 唯一ID
      };
      
      // 添加到游戏数据中
      if (!gameData.allies) {
        gameData.allies = [];
      }
      gameData.allies.push(ally);
      
      // 扣除金钱
      gameData.money -= allyType.price;
      updateGameInfo();
      
      // 显示放置效果
      showFloatingText(endPoint.x, endPoint.y, `+${allyType.name}`, '#10B981', 1);
      
      // 播放单位生成音效
      if (soundManager && soundManager.playSound) {
        soundManager.playSound('unitSpawn');
      }
      
      // 创建放置特效
      const effect = {
        type: 'place',
        x: gameData.gridOffset.x + endPoint.x * gameData.cellSize + gameData.cellSize / 2,
        y: gameData.gridOffset.y + endPoint.y * gameData.cellSize + gameData.cellSize / 2,
        size: gameData.cellSize,
        time: 0
      };
      gameData.effects.push(effect);
      
      console.log('购买单位:', ally);
    }
    
    // 初始化单位购买按钮
    function initAllyBuyButtons() {
      // 为每个单位类型创建购买按钮
      const allyButtonsContainer = document.createElement('div');
      allyButtonsContainer.className = 'ally-selection-container';
      allyButtonsContainer.style.cssText = 'position: absolute; top: 70px; left: 0; width: 100px; z-index: 10;';
      allyButtonsContainer.id = 'ally-buttons-container';
      allyButtonsContainer.innerHTML = `
        <div class="selection-header" style="display: flex; justify-content: space-between; align-items: center; background-color: #3B82F6; padding: 4px 8px; border-radius: 4px 4px 0 0;">
          <div class="selection-tabs" style="display: flex; gap: 2px; margin-bottom: 0;">
            <button class="tab-button active" data-tab="allies" style="padding: 4px 8px; background-color: transparent; color: white; border: none; border-radius: 4px 4px 0 0; cursor: pointer; font-size: 10px;">单位</button>
          </div>
        </div>
        <div class="ally-selection" id="ally-buttons" style="width: 100%; background-color: rgba(15, 23, 42, 0.9); border-radius: 0 0 4px 4px; overflow-y: auto; max-height: calc(100vh - 116px);">
          ${gameData.allyTypes.map(ally => `
            <button 
              id="buy-${ally.id}"
              onclick="buyAlly('${ally.id}')"
              style="display: block; width: 100%; padding: 6px; background-color: #3B82F6; color: white; border: none; border-bottom: 1px solid #2563EB; cursor: pointer; transition: background-color 0.3s ease; font-size: 10px; font-weight: bold;"
            >
              ${ally.name} ($${ally.price})
            </button>
          `).join('')}
        </div>
      `;
      
      // 添加到游戏屏幕的map-container中
      const mapContainer = document.querySelector('.map-container');
      if (mapContainer) {
        mapContainer.appendChild(allyButtonsContainer);
      }
      
      // 设置单位购买面板的收起功能
      setupAllyPanelToggle();
    }
    
    // 设置单位购买面板的收起功能
    function setupAllyPanelToggle() {
      const allyPanel = document.getElementById('ally-buttons-container');
      const toggleAllyButton = document.getElementById('toggle-ally-panel');
      
      if (allyPanel && toggleAllyButton) {
        let isAllyPanelCollapsed = true; // 初始状态为收起
        
        // 确保面板初始状态正确 - 收起
        allyPanel.style.transform = 'translateX(-100%)';
        allyPanel.style.transition = 'transform 0.3s ease';
        allyPanel.style.position = 'absolute';
        allyPanel.style.zIndex = '10';
        toggleAllyButton.innerHTML = '<i class="fa fa-chevron-left"></i>';
        
        // 创建一个独立的收起按钮
        const standaloneToggleButton = document.createElement('button');
        standaloneToggleButton.id = 'standalone-toggle-ally-panel';
        standaloneToggleButton.innerHTML = '<i class="fa fa-chevron-right"></i>'; // 初始显示展开图标
        standaloneToggleButton.style.cssText = `
          position: fixed;
          left: 0;
          top: 70px;
          z-index: 20;
          background-color: #3B82F6;
          padding: 12px 8px;
          border-radius: 0 4px 4px 0;
          border: none;
          color: white;
          cursor: pointer;
          box-shadow: 0 2px 4px rgba(0,0,0,0.3);
          transition: transform 0.3s ease;
        `;
        
        // 添加到map容器中
        const mapContainer = document.querySelector('.map-container');
        if (mapContainer) {
          mapContainer.appendChild(standaloneToggleButton);
        }
        
        // 隐藏原始按钮
        toggleAllyButton.style.display = 'none';
        
        // 绑定事件到独立按钮
        standaloneToggleButton.addEventListener('click', (e) => {
          e.stopPropagation();
          e.preventDefault();
          
          if (!isAllyPanelCollapsed) {
            // 收起单位购买面板
            allyPanel.style.transform = 'translateX(-100%)';
            standaloneToggleButton.innerHTML = '<i class="fa fa-chevron-right"></i>';
            // 确保按钮在面板收起后仍然可见
            standaloneToggleButton.style.left = '0';
          } else {
            // 展开单位购买面板
            allyPanel.style.transform = 'translateX(0)';
            standaloneToggleButton.innerHTML = '<i class="fa fa-chevron-left"></i>';
            // 面板展开时，按钮位置保持不变
            standaloneToggleButton.style.left = '0';
          }
          isAllyPanelCollapsed = !isAllyPanelCollapsed;
        });
      }
    }
    
    // 初始化炮台购买按钮
    function initTowerSelection() {
      const towerSelectionContainer = document.getElementById('tower-selection');
      if (towerSelectionContainer) {
        towerSelectionContainer.style.padding = '0';
        towerSelectionContainer.style.backgroundColor = 'rgba(15, 23, 42, 0.9)';
        towerSelectionContainer.innerHTML = `
          ${gameData.towerTypes.map(tower => `
            <button 
              id="buy-${tower.id}"
              onclick="selectTowerType('${tower.id}')"
              style="display: block; width: 100%; padding: 12px; background-color: #3B82F6; color: white; border: none; border-bottom: 1px solid #2563EB; cursor: pointer; transition: background-color 0.3s ease; font-size: 16px; font-weight: bold; text-align: left;"
            >
              ${tower.name} - $${tower.price}
            </button>
          `).join('')}
        `;
      }
    }
    
    // 设置炮台购买面板的收起功能
    function setupTowerPanelToggle() {
      const towerPanel = document.querySelector('.tower-selection-container');
      const toggleTowerButton = document.getElementById('toggle-tower-panel');
      
      if (towerPanel && toggleTowerButton) {
        let isTowerPanelCollapsed = false;
        
        toggleTowerButton.addEventListener('click', (e) => {
          e.stopPropagation();
          if (!isTowerPanelCollapsed) {
            // 收起炮台购买面板
            towerPanel.style.transform = 'translateX(220px)';
            toggleTowerButton.innerHTML = '<i class="fa fa-chevron-left"></i>';
          } else {
            // 展开炮台购买面板
            towerPanel.style.transform = 'translateX(0)';
            toggleTowerButton.innerHTML = '<i class="fa fa-chevron-right"></i>';
          }
          isTowerPanelCollapsed = !isTowerPanelCollapsed;
        });
      }
    }
    
    // 处理画布鼠标移动事件
    function handleCanvasMouseMove(event) {
      if (gameData.gameState !== 'game') return;
      
      const rect = gameCanvas.getBoundingClientRect();
      const x = event.clientX - rect.left;
      const y = event.clientY - rect.top;
      
      // 转换为网格坐标
      const gridX = Math.floor((x - gameData.gridOffset.x) / gameData.cellSize);
      const gridY = Math.floor((y - gameData.gridOffset.y) / gameData.cellSize);
      
      // 更新鼠标悬停的格子
      gameData.selectedCell = { x: gridX, y: gridY };
    }
    
    // 绘制网格
    function drawGrid() {
      ctx.save();
      ctx.strokeStyle = 'rgba(107, 114, 128, 0.3)';
      ctx.lineWidth = 1;
      
      // 绘制垂直线
      for (let x = 0; x <= gameData.gridSize.width; x++) {
        ctx.beginPath();
        ctx.moveTo(gameData.gridOffset.x + x * gameData.cellSize, gameData.gridOffset.y);
        ctx.lineTo(gameData.gridOffset.x + x * gameData.cellSize, gameData.gridOffset.y + gameData.gridSize.height * gameData.cellSize);
        ctx.stroke();
      }
      
      // 绘制水平线
      for (let y = 0; y <= gameData.gridSize.height; y++) {
        ctx.beginPath();
        ctx.moveTo(gameData.gridOffset.x, gameData.gridOffset.y + y * gameData.cellSize);
        ctx.lineTo(gameData.gridOffset.x + gameData.gridSize.width * gameData.cellSize, gameData.gridOffset.y + y * gameData.cellSize);
        ctx.stroke();
      }
      
      ctx.restore();
    }
    
    // 绘制路径
    function drawPath() {
      ctx.save();
      
      // 绘制路径背景
      gameData.path.forEach(point => {
        ctx.fillStyle = 'rgba(59, 130, 246, 0.2)';
        ctx.fillRect(
          gameData.gridOffset.x + point.x * gameData.cellSize,
          gameData.gridOffset.y + point.y * gameData.cellSize,
          gameData.cellSize,
          gameData.cellSize
        );
      });
      
      // 绘制起点
      const startPoint = gameData.path[0];
      ctx.fillStyle = 'rgba(16, 185, 129, 0.5)';
      ctx.fillRect(
        gameData.gridOffset.x + startPoint.x * gameData.cellSize,
        gameData.gridOffset.y + startPoint.y * gameData.cellSize,
        gameData.cellSize,
        gameData.cellSize
      );
      
      // 绘制终点
      const endPoint = gameData.path[gameData.path.length - 1];
      ctx.fillStyle = 'rgba(239, 68, 68, 0.5)';
      ctx.fillRect(
        gameData.gridOffset.x + endPoint.x * gameData.cellSize,
        gameData.gridOffset.y + endPoint.y * gameData.cellSize,
        gameData.cellSize,
        gameData.cellSize
      );
      
      ctx.restore();
    }
    
    // 更新特效
    function updateEffects(deltaTime) {
      for (let i = gameData.effects.length - 1; i >= 0; i--) {
        const effect = gameData.effects[i];
        effect.time += deltaTime;
        
        // 根据特效类型设置持续时间
        let duration = 0;
        switch (effect.type) {
          case 'place': duration = 0.5; break;
          case 'attack': duration = effect.duration || 0.3; break;
          case 'heal': duration = 0.5; break;
          case 'death': duration = 0.8; break;
          case 'convert': duration = 0.8; break; // 转换特效持续时间
          default: duration = 1.0;
        }
        
        // 移除已完成的特效
        if (effect.time >= duration) {
          gameData.effects.splice(i, 1);
        }
      }
    }
    
    // 渲染特效
    function renderEffects() {
      gameData.effects.forEach(effect => {
        ctx.save();
        
        switch (effect.type) {
          case 'place':
            // 放置特效
            const placeScale = Math.sin(effect.time * Math.PI * 4) * 0.2 + 1;
            ctx.globalAlpha = 1 - effect.time * 2;
            ctx.fillStyle = '#10B981';
            ctx.beginPath();
            ctx.arc(effect.x, effect.y, effect.size / 2 * placeScale, 0, Math.PI * 2);
            ctx.fill();
            break;
            
          case 'attack':
            // 攻击特效
            const attackProgress = effect.time / (effect.duration || 0.3);
            const attackX = effect.x + (effect.targetX - effect.x) * attackProgress;
            const attackY = effect.y + (effect.targetY - effect.y) * attackProgress;
            ctx.fillStyle = '#EF4444';
            ctx.beginPath();
            ctx.arc(attackX, attackY, 5, 0, Math.PI * 2);
            ctx.fill();
            break;
            
          case 'heal':
            // 治疗特效
            const healScale = Math.sin(effect.time * Math.PI * 3) * 0.3 + 1;
            ctx.globalAlpha = 1 - effect.time * 2;
            ctx.strokeStyle = '#10B981';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.arc(effect.x, effect.y, effect.size / 2 * healScale, 0, Math.PI * 2);
            ctx.stroke();
            break;
            
          case 'death':
            // 死亡特效
            const deathScale = Math.sin(effect.time * Math.PI * 2) * 0.5 + 1;
            ctx.globalAlpha = 1 - effect.time * 1.25;
            ctx.fillStyle = '#EF4444';
            ctx.beginPath();
            ctx.arc(effect.x, effect.y, effect.size / 2 * deathScale, 0, Math.PI * 2);
            ctx.fill();
            break;
            
          case 'convert':
            // 转换特效
            const convertScale = Math.sin(effect.time * Math.PI * 3) * 0.4 + 1;
            ctx.globalAlpha = 1 - effect.time * 1.25;
            ctx.strokeStyle = '#8B5CF6'; // 紫色边框
            ctx.lineWidth = 4;
            ctx.beginPath();
            ctx.arc(effect.x, effect.y, effect.size / 2 * convertScale, 0, Math.PI * 2);
            ctx.stroke();
            
            // 添加内部填充效果
            ctx.globalAlpha = 0.3;
            ctx.fillStyle = '#8B5CF6';
            ctx.fill();
            break;
        }
        
        ctx.restore();
      });
    }
    
    // 更新浮动文本
    function updateFloatingTexts(deltaTime) {
      for (let i = gameData.floatingTexts.length - 1; i >= 0; i--) {
        const text = gameData.floatingTexts[i];
        text.time += deltaTime;
        text.y -= 30 * deltaTime; // 向上飘动
        
        // 移除已完成的文本
        if (text.time >= text.duration) {
          gameData.floatingTexts.splice(i, 1);
        }
      }
    }
    
    // 渲染浮动文本
    function renderFloatingTexts() {
      gameData.floatingTexts.forEach(text => {
        ctx.save();
        ctx.fillStyle = text.color;
        ctx.font = '16px Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.globalAlpha = 1 - text.time / text.duration;
        ctx.fillText(
          text.text,
          gameData.gridOffset.x + text.x * gameData.cellSize + gameData.cellSize / 2,
          gameData.gridOffset.y + text.y * gameData.cellSize + gameData.cellSize / 2 - text.time * 30
        );
        ctx.restore();
      });
    }
    
    // 显示浮动文本
    function showFloatingText(gridX, gridY, text, color, duration = 1) {
      gameData.floatingTexts.push({
        x: gridX,
        y: gridY,
        text: text,
        color: color,
        time: 0,
        duration: duration
      });
    }
    
    // 初始化游戏
    function initGame() {
      // 设置画布大小
      resizeCanvas();
      window.addEventListener('resize', resizeCanvas);
      
      // 初始化路径
      generatePath();
      
      // 初始化事件监听
      initEventListeners();
      
      // 初始化单位购买按钮
      initAllyBuyButtons();
      
      // 初始化面板切换功能
      initPanelToggle();
      
      // 初始化图鉴
      updateEncyclopedia();
      
      // 开始游戏循环
      requestAnimationFrame(gameLoop);
    }
    
    // 调整画布大小
    function resizeCanvas() {
      const container = gameCanvas.parentElement;
      const containerWidth = container.clientWidth;
      const containerHeight = container.clientHeight;
      
      // 计算合适的画布大小，确保游戏内容完全可见
      const gameWidth = gameData.gridSize.width * gameData.cellSize + 200; // 200像素用于右侧炮塔选择面板
      const gameHeight = gameData.gridSize.height * gameData.cellSize + 100; // 100像素用于顶部信息栏
      
      // 设置画布大小
      gameCanvas.width = Math.max(gameWidth, containerWidth);
      gameCanvas.height = Math.max(gameHeight, containerHeight);
      
      // 重新计算网格偏移，确保居中显示
      gameData.gridOffset = {
        x: (gameCanvas.width - gameData.gridSize.width * gameData.cellSize) / 2,
        y: (gameCanvas.height - gameData.gridSize.height * gameData.cellSize) / 2
      };
    }
    
    // 放置己方单位（从核心出发）
    function placeAlly(allyTypeId) {
      // 检查数据有效性
      if (!gameData || !gameData.allyTypes) {
        console.error('游戏数据或单位类型不存在');
        return;
      }
      
      // 查找单位类型
      const allyType = gameData.allyTypes.find(type => type.id === allyTypeId);
      if (!allyType) {
        console.error('未找到单位类型:', allyTypeId);
        return;
      }
      
      // 检查金钱是否足够
      if (gameData.money < allyType.price) {
        const endPoint = gameData.path[gameData.path.length - 1];
        showFloatingText(endPoint.x, endPoint.y, '金钱不足！', '#EF4444', 1);
        return;
      }
      
      // 从核心（路径终点）出发
      const endPoint = gameData.path[gameData.path.length - 1];
      
      // 创建单位
      const ally = {
        type: allyTypeId,
        name: allyType.name,
        health: allyType.health,
        maxHealth: allyType.health,
        damage: allyType.damage,
        speed: allyType.speed,
        attackRange: allyType.attackRange,
        attackSpeed: 1.0, // 默认攻击速度，每秒攻击一次
        attackTimer: 0,
        healTimer: 0,
        x: endPoint.x,
        y: endPoint.y,
        pathIndex: gameData.path.length - 1, // 从终点开始
        moving: true, // 初始状态为移动
        id: Date.now() + Math.random() // 唯一ID
      };
      
      // 添加到游戏数据中
      if (!gameData.allies) {
        gameData.allies = [];
      }
      gameData.allies.push(ally);
      
      // 扣除金钱
      gameData.money -= allyType.price;
      updateGameInfo();
      
      // 显示放置效果
      showFloatingText(endPoint.x, endPoint.y, `+${allyType.name}`, '#10B981', 1);
      
      // 播放单位生成音效
      if (soundManager && soundManager.playSound) {
        soundManager.playSound('unitSpawn');
      }
      
      // 创建放置特效
      const effect = {
        type: 'place',
        x: gameData.gridOffset.x + endPoint.x * gameData.cellSize + gameData.cellSize / 2,
        y: gameData.gridOffset.y + endPoint.y * gameData.cellSize + gameData.cellSize / 2,
        size: gameData.cellSize,
        time: 0
      };
      gameData.effects.push(effect);
      
      console.log('放置单位:', ally);
    }
    
    // 更新己方单位
    // 单位移动函数 - 沿着道路逐步向怪物刷新点移动
    function moveAlliesSimple() {
      if (!gameData || !gameData.allies || gameData.allies.length === 0 || !gameData.path) return;
      
      gameData.allies.forEach(ally => {
        // 确保单位向路径起点（怪物刷新点）移动
        if (ally.pathIndex > 0 && gameData.path[ally.pathIndex - 1]) {
          const nextPoint = gameData.path[ally.pathIndex - 1];
          
          // 计算方向向量
          const dx = nextPoint.x - ally.x;
          const dy = nextPoint.y - ally.y;
          const distance = Math.sqrt(dx * dx + dy * dy);
          
          if (distance > 0.1) {
            // 逐步向目标点移动（每帧移动0.1格）
            const moveDistance = 0.1;
            ally.x += (dx / distance) * moveDistance;
            ally.y += (dy / distance) * moveDistance;
          } else {
            // 到达目标点，更新路径索引
            ally.x = nextPoint.x;
            ally.y = nextPoint.y;
            ally.pathIndex--;
          }
        }
      });
    }

    // 全新的单位移动和战斗系统
    function animateAllies() {
      if (!gameData || !gameData.allies || gameData.allies.length === 0 || !gameData.path) {
        requestAnimationFrame(animateAllies);
        return;
      }
      
      gameData.allies.forEach(ally => {
        // 为每个单位添加唯一标识
        if (!ally.debugId) {
          ally.debugId = Math.random().toString(36).substr(2, 9);
        }
        
        // 初始化移动进度
        if (ally.moveProgress === undefined) {
          ally.moveProgress = 0;
        }
        
        // 初始化受击动画状态
        if (ally.hitAnimation === undefined) {
          ally.hitAnimation = 0;
        }
        
        // 初始化攻击动画状态
        if (ally.attackAnimation === undefined) {
          ally.attackAnimation = 0;
        }

        // 寻找攻击目标
        let target = null;
        let minDistance = Infinity;
        
        if (gameData.monsters) {
          gameData.monsters.forEach(monster => {
            // 检查怪物对象和属性是否有效
            if (!monster || monster.isDead || monster.health <= 0 || !monster.position || !monster.position.x || !monster.position.y) return;
            
            const distance = Math.sqrt(
              Math.pow(monster.position.x - ally.x, 2) + 
              Math.pow(monster.position.y - ally.y, 2)
            );
            
            if (distance <= ally.attackRange && distance < minDistance) {
              target = monster;
              minDistance = distance;
            }
          });
        }
        
        // 如果有目标，停止移动并攻击
        if (target && target.position) {
          ally.moving = false;
          
          // 处理攻击
          if (!ally.attackTimer) ally.attackTimer = 0;
          if (ally.attackTimer <= 0) {
            ally.attackTimer = ally.attackSpeed || 1.0;
            
            // 造成伤害
            const damage = ally.damage;
            if (target.health !== undefined) {
              target.health = Math.max(0, target.health - damage);
              
              // 显示伤害文本
              if (target.position && target.position.x !== undefined && target.position.y !== undefined) {
                showFloatingText(target.position?.x || 0, target.position?.y || 0, `-${damage}`, '#EF4444', 1);
              }
              
              // 创建攻击特效
              if (gameData.effects && gameData.gridOffset && gameData.cellSize && target.position && target.position.x !== undefined && target.position.y !== undefined) {
                const effect = {
                  type: 'attack',
                  x: gameData.gridOffset.x + ally.x * gameData.cellSize + gameData.cellSize / 2,
                  y: gameData.gridOffset.y + ally.y * gameData.cellSize + gameData.cellSize / 2,
                  targetX: gameData.gridOffset.x + (target.position?.x || 0) * gameData.cellSize + gameData.cellSize / 2,
                  targetY: gameData.gridOffset.y + (target.position?.y || 0) * gameData.cellSize + gameData.cellSize / 2,
                  time: 0,
                  duration: 0.3
                };
                gameData.effects.push(effect);
              }
              
              // 触发攻击动画
              ally.attackAnimation = 1;
            }
          }
        } else {
          // 如果没有目标，继续移动
          ally.moving = true;
        }
        
        // 只有在移动状态下才更新位置
        if (ally.moving) {
          // 确保单位向路径起点（怪物刷新点）移动
          if (ally.pathIndex > 0 && gameData.path[ally.pathIndex - 1]) {
            const currentPoint = gameData.path[ally.pathIndex];
            const nextPoint = gameData.path[ally.pathIndex - 1];
            
            // 根据moveProgress计算当前应该在的位置
            ally.x = currentPoint.x + (nextPoint.x - currentPoint.x) * ally.moveProgress;
            ally.y = currentPoint.y + (nextPoint.y - currentPoint.y) * ally.moveProgress;
            
            // 更新移动进度
            ally.moveProgress += 0.01; // 调整这个值可以改变移动速度
            
            // 如果到达下一个点
            if (ally.moveProgress >= 1) {
              ally.moveProgress = 0;
              ally.pathIndex--;
              // 确保位置精确
              ally.x = nextPoint.x;
              ally.y = nextPoint.y;
            }
          } else if (ally.pathIndex === 0) {
            // 到达怪物刷新点，让单位回到起点
            ally.pathIndex = gameData.path.length - 1;
            ally.moveProgress = 0;
            // 设置初始位置
            if (gameData.path[ally.pathIndex]) {
              ally.x = gameData.path[ally.pathIndex].x;
              ally.y = gameData.path[ally.pathIndex].y;
            }
          }
        }
        
        // 更新攻击计时器
        if (ally.attackTimer > 0) {
          ally.attackTimer -= 0.016; // 假设60fps，每帧减少约1/60
        }
        
        // 更新怪物攻击计时器
        if (target && target.attackTimer !== undefined && target.attackTimer > 0) {
          target.attackTimer -= 0.016;
        }
        
        // 更新动画状态
        if (ally.hitAnimation > 0) {
          ally.hitAnimation -= 0.03; // 受击动画持续时间
        }
        if (ally.attackAnimation > 0) {
          ally.attackAnimation -= 0.03; // 攻击动画持续时间
        }
      });
      
      requestAnimationFrame(animateAllies);
    }

    // 启动动画循环
    animateAllies();
    
    // 渲染己方单位
    function renderAllies() {
      //if (!gameData.allies || gameData.allies.length === 0) return;
      
      gameData.allies.forEach(ally => {
        const x = gameData.gridOffset.x + ally.x * gameData.cellSize + gameData.cellSize / 2;
        const y = gameData.gridOffset.y + ally.y * gameData.cellSize + gameData.cellSize / 2;
        const size = gameData.cellSize * 0.8;
        
        // 绘制单位
        ctx.save();
        
        // 应用攻击动画缩放效果
        let scale = 1;
        if (ally.attackAnimation > 0) {
          scale = 1 + Math.sin(ally.attackAnimation * Math.PI) * 0.2;
        }
        
        // 应用受击动画闪烁效果
        if (ally.hitAnimation > 0) {
          const flashIntensity = Math.sin(ally.hitAnimation * Math.PI * 8);
          ctx.globalAlpha = 0.5 + Math.abs(flashIntensity) * 0.5;
        }
        
        // 设置单位位置和缩放
        ctx.translate(x, y);
        ctx.scale(scale, scale);
        ctx.translate(-x, -y);
        
        // 根据单位类型设置颜色
        switch (ally.type) {
          case 'soldier':
            ctx.fillStyle = '#3B82F6'; // 蓝色
            break;
          case 'archer':
            ctx.fillStyle = '#10B981'; // 绿色
            break;
          case 'tank':
            ctx.fillStyle = '#EF4444'; // 红色
            break;
          case 'healer':
            ctx.fillStyle = '#8B5CF6'; // 紫色
            break;
          case 'mage':
            ctx.fillStyle = '#F59E0B'; // 黄色
            break;
          default:
            ctx.fillStyle = '#6B7280'; // 灰色
        }
        
        // 绘制单位形状
        ctx.beginPath();
        ctx.arc(x, y, size / 2, 0, Math.PI * 2);
        ctx.fill();
        
        // 绘制边框
        ctx.strokeStyle = '#FFFFFF';
        ctx.lineWidth = 2;
        ctx.stroke();
        
        // 绘制单位图标
        ctx.fillStyle = '#FFFFFF';
        ctx.font = '16px Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        
        let icon = '';
        switch (ally.type) {
          case 'soldier': icon = '⚔️'; break;
          case 'archer': icon = '🏹'; break;
          case 'tank': icon = '🛡️'; break;
          case 'healer': icon = '💚'; break;
          case 'mage': icon = '✨'; break;
        }
        ctx.fillText(icon, x, y);
        
        // 恢复变换状态
        ctx.restore();
        
        // 绘制血条
        const healthBarWidth = size;
        const healthBarHeight = 4;
        const healthBarX = x - healthBarWidth / 2;
        const healthBarY = y - size / 2 - 8;
        
        // 背景
        ctx.fillStyle = '#374151';
        ctx.fillRect(healthBarX, healthBarY, healthBarWidth, healthBarHeight);
        
        // 血量
        const healthPercentage = ally.health / ally.maxHealth;
        ctx.fillStyle = healthPercentage > 0.5 ? '#10B981' : healthPercentage > 0.25 ? '#F59E0B' : '#EF4444';
        ctx.fillRect(healthBarX, healthBarY, healthBarWidth * healthPercentage, healthBarHeight);
      });
    }
    
    // 初始化面板切换功能
    function initPanelToggle() {
      // 炮塔面板切换
      const towerPanel = document.querySelector('.tower-selection-container');
      const toggleTowerButton = document.getElementById('toggle-tower-panel');
      
      if (towerPanel && toggleTowerButton) {
        let isTowerPanelCollapsed = false;
        
        toggleTowerButton.addEventListener('click', (e) => {
          e.stopPropagation();
          if (!isTowerPanelCollapsed) {
            // 收起炮塔面板
            towerPanel.style.transform = 'translateX(220px)';
            toggleTowerButton.innerHTML = '<i class="fa fa-chevron-right"></i>';
          } else {
            // 展开炮塔面板
            towerPanel.style.transform = 'translateX(0)';
            toggleTowerButton.innerHTML = '<i class="fa fa-chevron-left"></i>';
          }
          isTowerPanelCollapsed = !isTowerPanelCollapsed;
        });
      }
      
      // 单位购买面板切换
      const allyPanel = document.getElementById('ally-buttons-container');
      const toggleAllyButton = document.getElementById('toggle-ally-panel');
      
      if (allyPanel && toggleAllyButton) {
        let isAllyPanelCollapsed = false;
        
        // 确保按钮在DOM中，即使面板收起也能点击
        document.body.appendChild(toggleAllyButton);
        
        toggleAllyButton.addEventListener('click', (e) => {
          e.stopPropagation();
          if (!isAllyPanelCollapsed) {
            // 收起单位购买面板
            allyPanel.style.transform = 'translateX(-100%)';
            toggleAllyButton.innerHTML = '<i class="fa fa-chevron-right"></i>';
            toggleAllyButton.style.position = 'fixed';
            toggleAllyButton.style.left = '0';
            toggleAllyButton.style.top = '50px';
            toggleAllyButton.style.zIndex = '1000';
            toggleAllyButton.style.backgroundColor = '#3B82F6';
            toggleAllyButton.style.padding = '12px 8px';
            toggleAllyButton.style.borderRadius = '0 4px 4px 0';
            toggleAllyButton.style.border = 'none';
            toggleAllyButton.style.color = 'white';
            toggleAllyButton.style.cursor = 'pointer';
            toggleAllyButton.style.boxShadow = '0 2px 4px rgba(0,0,0,0.3)';
          } else {
            // 展开单位购买面板
            allyPanel.style.transform = 'translateX(0)';
            toggleAllyButton.innerHTML = '<i class="fa fa-chevron-left"></i>';
            toggleAllyButton.style.position = 'static';
            toggleAllyButton.style.left = 'auto';
            toggleAllyButton.style.top = 'auto';
            toggleAllyButton.style.backgroundColor = 'transparent';
            toggleAllyButton.style.padding = '4px';
            toggleAllyButton.style.borderRadius = '0';
            toggleAllyButton.style.boxShadow = 'none';
            
            // 将按钮放回面板内
            const header = allyPanel.querySelector('.flex.justify-between');
            if (header) {
              header.appendChild(toggleAllyButton);
            }
          }
          isAllyPanelCollapsed = !isAllyPanelCollapsed;
        });
      }
    }
    
    // 初始化单位面板切换功能
    function initAllyPanelToggle() {
      const allyPanel = document.getElementById('ally-panel');
      const toggleButton = document.getElementById('toggle-ally-panel');
      const expandButton = document.getElementById('expand-ally-panel');
      
      if (!allyPanel || !toggleButton || !expandButton) {
        console.warn('单位面板元素未找到');
        return;
      }
      
      let isCollapsed = false;
      
      // 收起按钮点击事件
      toggleButton.addEventListener('click', () => {
        if (!isCollapsed) {
          // 收起面板
          allyPanel.style.transform = 'translateX(-230px)';
          expandButton.style.display = 'block';
          toggleButton.innerHTML = '<i class="fa fa-chevron-right"></i>';
        } else {
          // 展开面板
          allyPanel.style.transform = 'translateX(0)';
          expandButton.style.display = 'none';
          toggleButton.innerHTML = '<i class="fa fa-chevron-left"></i>';
        }
        isCollapsed = !isCollapsed;
      });
      
      // 展开按钮点击事件
      expandButton.addEventListener('click', () => {
        allyPanel.style.transform = 'translateX(0)';
        expandButton.style.display = 'none';
        toggleButton.innerHTML = '<i class="fa fa-chevron-left"></i>';
        isCollapsed = false;
      });
    }
    
    // 初始化事件监听
    function initEventListeners() {
      // 科技系统按钮
      const techSystemButton = document.getElementById('tech-system-button');
      if (techSystemButton) {
        techSystemButton.addEventListener('click', () => {
          toggleTechTree();
          soundManager.playSound('buttonClickSound');
        });
      }
      
      // 关闭科技树按钮
      const closeTechTreeButton = document.getElementById('close-tech-tree');
      if (closeTechTreeButton) {
        closeTechTreeButton.addEventListener('click', () => {
          toggleTechTree();
          soundManager.playSound('buttonClickSound');
        });
      }
      
      // 返回按钮
      const backFromTechTreeButton = document.getElementById('back-from-tech-tree');
      if (backFromTechTreeButton) {
        backFromTechTreeButton.addEventListener('click', () => {
          toggleTechTree();
          soundManager.playSound('buttonClickSound');
        });
      }
      
      // 科技树滚动指示器
      const scrollContainer = document.querySelector('#tech-tree-screen > div > div:nth-child(5)');
      const techBranches = document.querySelectorAll('.tech-branch');
      const scrollIndicators = document.querySelectorAll('.scroll-indicator');
      
      if (scrollContainer && techBranches.length > 0 && scrollIndicators.length > 0) {
        // 滚动时更新指示器
        scrollContainer.addEventListener('scroll', () => {
          const scrollPosition = scrollContainer.scrollLeft;
          const branchWidth = techBranches[0].offsetWidth + 40; // 加上间距
          
          // 计算当前可见的分支索引
          let activeIndex = Math.round(scrollPosition / branchWidth);
          activeIndex = Math.max(0, Math.min(activeIndex, techBranches.length - 1));
          
          // 更新指示器状态
          scrollIndicators.forEach((indicator, index) => {
            if (index === activeIndex) {
              indicator.classList.add('active');
              indicator.style.backgroundColor = '#8B5CF6';
            } else {
              indicator.classList.remove('active');
              indicator.style.backgroundColor = 'rgba(139, 92, 246, 0.3)';
            }
          });
        });
        
        // 点击指示器滚动到对应分支
        scrollIndicators.forEach((indicator, index) => {
          indicator.addEventListener('click', () => {
            const branchWidth = techBranches[0].offsetWidth + 40; // 加上间距
            scrollContainer.scrollTo({
              left: index * branchWidth,
              behavior: 'smooth'
            });
            soundManager.playSound('buttonClickSound');
          });
        });
        
        // 科技分支悬停效果
        techBranches.forEach(branch => {
          branch.addEventListener('mouseenter', () => {
            branch.style.transform = 'translateY(-5px)';
            branch.style.boxShadow = '0 10px 25px -5px rgba(139, 92, 246, 0.3)';
          });
          
          branch.addEventListener('mouseleave', () => {
            branch.style.transform = 'translateY(0)';
            branch.style.boxShadow = 'none';
          });
        });
        
        // 科技节点悬停效果
        document.querySelectorAll('.tech-node').forEach(node => {
          node.addEventListener('mouseenter', () => {
            node.style.transform = 'translateX(5px)';
          });
          
          node.addEventListener('mouseleave', () => {
            node.style.transform = 'translateX(0)';
          });
        });
      }
      
      // 科技升级按钮
      document.querySelectorAll('.upgrade-tech-button').forEach(button => {
        button.addEventListener('click', (e) => {
          const techNode = e.target.closest('.tech-node');
          if (techNode) {
            const branch = techNode.dataset.branch;
            const level = parseInt(techNode.dataset.level);
            upgradeTech(branch, level);
            soundManager.playSound('buttonClickSound');
          }
        });
      });
      
      // 炮塔选择界面收缩/展开按钮
      const towerSelectionToggle = document.getElementById('tower-selection-toggle');
      if (towerSelectionToggle) {
        towerSelectionToggle.addEventListener('click', () => {
          toggleTowerSelection();
          soundManager.playSound('buttonClickSound');
        });
      }
      // 主菜单按钮
      document.getElementById('start-game').addEventListener('click', () => {
        changeGameState('difficulty');
        soundManager.playSound('buttonClickSound');
      });
      document.getElementById('encyclopedia').addEventListener('click', () => {
        changeGameState('encyclopedia');
        soundManager.playSound('buttonClickSound');
      });
      document.getElementById('admin-mode').addEventListener('click', () => {
        changeGameState('admin-password');
        soundManager.playSound('buttonClickSound');
      });
      
      // 难度选择按钮
      document.querySelectorAll('.difficulty-button').forEach(button => {
        button.addEventListener('click', () => {
          const difficulty = button.dataset.difficulty;
          startGame(difficulty);
          soundManager.playSound('buttonClickSound');
        });
      });
      
      // 返回按钮
      document.getElementById('back-from-difficulty').addEventListener('click', () => {
        changeGameState('menu');
        soundManager.playSound('buttonClickSound');
      });
      document.getElementById('back-from-password').addEventListener('click', () => {
        changeGameState('menu');
        soundManager.playSound('buttonClickSound');
      });
      document.getElementById('back-from-admin').addEventListener('click', () => {
        changeGameState('menu');
        soundManager.playSound('buttonClickSound');
      });
      document.getElementById('back-from-encyclopedia').addEventListener('click', () => {
        changeGameState('menu');
        soundManager.playSound('buttonClickSound');
      });
      
      // 管理员密码确认
      document.getElementById('check-password').addEventListener('click', () => {
        checkAdminPassword();
        soundManager.playSound('buttonClickSound');
      });
      
      // 管理员标签切换
      document.querySelectorAll('.admin-tab').forEach(tab => {
        tab.addEventListener('click', () => {
          document.querySelectorAll('.admin-tab').forEach(t => t.classList.remove('active'));
          document.querySelectorAll('.admin-content').forEach(c => c.classList.remove('active'));
          
          tab.classList.add('active');
          document.getElementById(`${tab.dataset.tab}-content`).classList.add('active');
        });
      });
      
      // 保存管理员设置
      document.getElementById('save-admin-settings').addEventListener('click', saveAdminSettings);
      
      // 图鉴标签切换
      document.querySelectorAll('.encyclopedia-tab').forEach(tab => {
        tab.addEventListener('click', () => {
          document.querySelectorAll('.encyclopedia-tab').forEach(t => t.classList.remove('active'));
          document.querySelectorAll('.encyclopedia-content').forEach(c => c.classList.remove('active'));
          
          tab.classList.add('active');
          document.getElementById(`${tab.dataset.tab}-encyclopedia`).classList.add('active');
        });
      });
      
      // 游戏画布事件
      gameCanvas.addEventListener('click', handleCanvasClick);
      gameCanvas.addEventListener('mousemove', handleCanvasMouseMove);
      
      // 炮塔信息界面按钮
      document.getElementById('upgrade-tower').addEventListener('click', () => {
        upgradeTower();
        soundManager.playSound('buttonClickSound');
      });
      document.getElementById('sell-tower').addEventListener('click', sellTower);
      document.getElementById('close-tower-info').addEventListener('click', () => {
        document.getElementById('tower-info-screen').classList.add('hidden');
        gameData.selectedTower = null;
      });
      
      // 重新开始按钮
      document.getElementById('restart-game').addEventListener('click', () => {
        resetGame();
        changeGameState('menu');
        soundManager.playSound('buttonClickSound');
      });
      
      document.getElementById('victory-restart').addEventListener('click', () => {
        resetGame();
        changeGameState('menu');
        soundManager.playSound('buttonClickSound');
      });
    }
    
    // 切换任务系统界面
    function toggleMissionSystem() {
      const missionScreen = document.getElementById('mission-screen');
      
      if (missionScreen) {
        // 切换显示/隐藏
        const isHidden = missionScreen.classList.toggle('hidden');
        
        if (!isHidden) {
          // 保存当前游戏状态
          gameData.previousGameState = gameData.gameState;
          
          // 暂停游戏并设置任务系统状态
          gameData.gamePaused = true;
          gameData.gameState = 'mission';
          
          // 更新任务列表
          updateMissionList();
        } else {
          // 恢复游戏状态
          gameData.gamePaused = false;
          
          // 恢复之前的游戏状态，如果有的话
          if (gameData.previousGameState) {
            gameData.gameState = gameData.previousGameState;
            delete gameData.previousGameState;
          } else {
            gameData.gameState = 'game';
          }
        }
      }
    }
    
    // 切换成就系统界面
    function toggleAchievementSystem() {
      const achievementScreen = document.getElementById('mission-screen'); // 复用任务界面的HTML结构
      
      if (achievementScreen) {
        // 切换显示/隐藏
        const isHidden = achievementScreen.classList.toggle('hidden');
        
        if (!isHidden) {
          // 保存当前游戏状态
          gameData.previousGameState = gameData.gameState;
          
          // 暂停游戏并设置成就系统状态
          gameData.gamePaused = true;
          gameData.gameState = 'achievement';
          
          // 更新成就列表
          updateAchievementList();
        } else {
          // 恢复游戏状态
          gameData.gamePaused = false;
          
          // 恢复之前的游戏状态，如果有的话
          if (gameData.previousGameState) {
            gameData.gameState = gameData.previousGameState;
            delete gameData.previousGameState;
          } else {
            gameData.gameState = 'game';
          }
        }
      }
    }
    
    // 切换技能系统界面
    function toggleSkillSystem() {
      const skillScreen = document.getElementById('skill-screen');
      const skillPointsDisplay = document.getElementById('skill-points-display');
      
      if (skillScreen) {
        // 切换显示/隐藏
        const isHidden = skillScreen.classList.toggle('hidden');
        
        if (!isHidden) {
          // 保存当前游戏状态
          gameData.previousGameState = gameData.gameState;
          
          // 暂停游戏并设置技能系统状态
          gameData.gamePaused = true;
          gameData.gameState = 'skill';
          
          if (skillPointsDisplay) {
            skillPointsDisplay.textContent = gameData.skillSystem.skillPoints;
          }
          
          // 更新技能列表
          updateSkillList();
        } else {
          // 恢复游戏状态
          gameData.gamePaused = false;
          
          // 恢复之前的游戏状态，如果有的话
          if (gameData.previousGameState) {
            gameData.gameState = gameData.previousGameState;
            delete gameData.previousGameState;
          } else {
            gameData.gameState = 'game';
          }
        }
      }
    }
    
    // 更新任务列表
    function updateMissionList() {
      const missionList = document.getElementById('mission-list');
      if (!missionList) return;
      
      missionList.innerHTML = '';
      
      gameData.missionSystem.availableMissions.forEach(mission => {
        const isCompleted = gameData.missionSystem.completedMissions.includes(mission.id);
        const progress = gameData.missionSystem.missionProgress[mission.id] || 0;
        const progressText = `${progress}/${mission.target}`;
        
        const missionItem = document.createElement('div');
        missionItem.className = `mission-item ${isCompleted ? 'completed' : ''}`;
        missionItem.innerHTML = `
          <div class="mission-item-header">
            <h3>${mission.name}</h3>
            <span class="mission-status">${isCompleted ? '已完成' : '进行中'}</span>
          </div>
          <div class="mission-description">${mission.description}</div>
          <div class="mission-progress">进度: ${progressText}</div>
          <div class="mission-reward">奖励: ${mission.reward.money} 金钱, ${mission.reward.techPoints} 科技点</div>
        `;
        
        missionList.appendChild(missionItem);
      });
    }
    
    // 更新成就列表
    function updateAchievementList() {
      const missionList = document.getElementById('mission-list'); // 复用任务列表的HTML结构
      if (!missionList) return;
      
      // 更改标题
      const header = document.querySelector('.mission-header h2');
      if (header) {
        header.textContent = '成就系统';
      }
      
      missionList.innerHTML = '';
      
      gameData.achievementSystem.achievements.forEach(achievement => {
        const isUnlocked = achievement.unlocked;
        
        const achievementItem = document.createElement('div');
        achievementItem.className = `mission-item ${isUnlocked ? 'completed' : ''}`;
        achievementItem.innerHTML = `
          <div class="mission-item-header">
            <h3>${achievement.name}</h3>
            <span class="mission-status">${isUnlocked ? '已解锁' : '未解锁'}</span>
          </div>
          <div class="mission-description">${achievement.description}</div>
          <div class="mission-progress">进度: ${achievement.progress}/${achievement.target}</div>
          <div class="mission-reward">奖励: ${achievement.reward.skillPoints} 技能点</div>
        `;
        
        missionList.appendChild(achievementItem);
      });
    }
    
    // 更新技能列表
    function updateSkillList() {
      const skillList = document.getElementById('skill-list');
      if (!skillList) return;
      
      skillList.innerHTML = '';
      
      gameData.skillSystem.skills.forEach(skill => {
        const skillItem = document.createElement('div');
        skillItem.className = `skill-item ${!skill.unlocked ? 'locked' : ''}`;
        
        let skillContent = `
          <div class="mission-item-header">
            <h3>${skill.name}</h3>
            <span class="mission-status">等级 ${skill.level}/${skill.maxLevel}</span>
          </div>
          <div class="mission-description">${skill.description}</div>
        `;
        
        if (skill.unlocked) {
          skillContent += `
            <div class="skill-level">
              <span>当前效果: ${getSkillEffectDescription(skill)}</span>
            </div>
            <div class="mission-reward">冷却时间: ${skill.cooldown} 秒</div>
          `;
          
          if (skill.level < skill.maxLevel) {
            skillContent += `
              <button class="skill-button" onclick="upgradeSkill('${skill.id}')">
                升级 (花费 1 技能点)
              </button>
            `;
          }
        } else {
          skillContent += `
            <div class="mission-reward">解锁条件: 升级前一个技能到最高等级</div>
          `;
        }
        
        skillItem.innerHTML = skillContent;
        skillList.appendChild(skillItem);
      });
    }
    
    // 获取技能效果描述
    function getSkillEffectDescription(skill) {
      switch(skill.id) {
        case 'skill_orbital_strike':
          return `造成 ${skill.damage} 伤害，范围 ${skill.radius} 格`;
        case 'skill_time_freeze':
          return `冻结敌人 ${skill.freezeTime} 秒`;
        case 'skill_money_boost':
          return `金钱奖励提升 ${(skill.moneyMultiplier - 1) * 100}%，持续 ${skill.duration} 秒`;
        case 'skill_shield_barrier':
          return `为所有炮塔提供 ${skill.shieldAmount} 护盾，持续 ${skill.duration} 秒`;
        case 'skill_core_heal':
          return `恢复核心 ${skill.healAmount} 生命值`;
        default:
          return '';
      }
    }
    
    // 切换科技树界面
    function toggleTechTree() {
      const techTreeScreen = document.getElementById('tech-tree-screen');
      const techPointsDisplayTree = document.getElementById('tech-points-display-tree');
      
      if (techTreeScreen) {
        // 切换显示/隐藏
        const isHidden = techTreeScreen.classList.toggle('hidden');
        
        // 如果显示科技树，更新科技点显示和科技节点状态
        if (!isHidden) {
          // 保存当前游戏状态
          gameData.previousGameState = gameData.gameState;
          
          // 暂停游戏并设置科技树状态
          gameData.gamePaused = true;
          gameData.gameState = 'tech-tree';
          
          if (techPointsDisplayTree) {
            techPointsDisplayTree.textContent = `科技点: ${gameData.techSystem.techPoints}`;
          }
          
          // 更新科技节点状态
          updateTechNodes();
        } else {
          // 恢复游戏状态
          gameData.gamePaused = false;
          
          // 恢复之前的游戏状态，如果有的话
          if (gameData.previousGameState) {
            gameData.gameState = gameData.previousGameState;
            delete gameData.previousGameState;
          } else {
            gameData.gameState = 'game';
          }
        }
      }
    }
    
    // 更新科技节点状态
    function updateTechNodes() {
      document.querySelectorAll('.tech-node').forEach(node => {
        const branch = node.dataset.branch;
        const level = parseInt(node.dataset.level);
        const currentLevel = gameData.techSystem[`${branch}TechLevel`];
        const button = node.querySelector('.upgrade-tech-button');
        
        // 根据当前等级更新按钮状态
        if (currentLevel >= level) {
          // 已升级
          button.textContent = '已升级';
          button.disabled = true;
          button.style.backgroundColor = 'rgba(107, 114, 128, 0.7)';
          button.style.cursor = 'default';
        } else if (currentLevel + 1 === level) {
          // 可升级
          const cost = getTechUpgradeCost(branch, level);
          if (gameData.techSystem.techPoints >= cost) {
            button.textContent = '升级';
            button.disabled = false;
            button.style.backgroundColor = 'rgba(139, 92, 246, 0.7)';
            button.style.cursor = 'pointer';
          } else {
            button.textContent = '科技点不足';
            button.disabled = true;
            button.style.backgroundColor = 'rgba(239, 68, 68, 0.7)';
            button.style.cursor = 'not-allowed';
          }
        } else {
          // 未解锁
          button.textContent = '未解锁';
          button.disabled = true;
          button.style.backgroundColor = 'rgba(107, 114, 128, 0.7)';
          button.style.cursor = 'default';
        }
      });
    }
    
    // 获取科技升级所需科技点
    function getTechUpgradeCost(branch, level) {
      // 基础成本 * 等级
      const baseCost = 10;
      return baseCost * level;
    }
    
    // 升级科技
    function upgradeTech(branch, level) {
      // 检查是否可以升级
      const currentLevel = gameData.techSystem[`${branch}TechLevel`];
      if (currentLevel + 1 !== level) {
        showNotification('请按顺序升级科技！', '#EF4444');
        return;
      }
      
      // 检查科技点是否足够
      const cost = getTechUpgradeCost(branch, level);
      if (gameData.techSystem.techPoints < cost) {
        showNotification('科技点不足！', '#EF4444');
        return;
      }
      
      // 消耗科技点
      gameData.techSystem.techPoints -= cost;
      
      // 提升科技等级
      gameData.techSystem[`${branch}TechLevel`] = level;
      
      // 应用科技效果
      applyTechEffects();
      
      // 更新显示
      updateTechPointsDisplay();
      
      // 更新科技树界面
      const techPointsDisplayTree = document.getElementById('tech-points-display-tree');
      if (techPointsDisplayTree) {
        techPointsDisplayTree.textContent = `科技点: ${gameData.techSystem.techPoints}`;
      }
      
      // 更新科技节点状态
      updateTechNodes();
      
      // 显示升级成功通知
      let effectDescription = '';
      switch (branch) {
        case 'attack':
          effectDescription = `所有炮塔攻击力+${level * 5}%`;
          break;
        case 'defense':
          effectDescription = `核心生命值+${level * 10}%，炮塔生命值+${Math.max(0, (level - 1) * 10)}%`;
          break;
        case 'economy':
          effectDescription = `敌人掉落金钱+${level * 5}%，炮塔建造成本-${Math.max(0, (level - 1) * 5)}%`;
          break;
      }
      
      showNotification(`科技升级成功！${effectDescription}`, '#8B5CF6');
      
      // 播放升级音效
      soundManager.playSound('techUpgradeSound');
    }
    
    // 应用科技效果
    function applyTechEffects() {
      // 获取当前科技等级
      const attackLevel = gameData.techSystem.attackTechLevel;
      const defenseLevel = gameData.techSystem.defenseTechLevel;
      const economyLevel = gameData.techSystem.economyTechLevel;
      
      // 应用攻击科技效果（炮塔攻击力加成）
      const attackBonus = 1 + (attackLevel * 5) / 100;
      gameData.towers.forEach(tower => {
        // 保存基础攻击力（如果尚未保存）
        if (tower.baseDamage === undefined || tower.baseDamage === null) {
          tower.baseDamage = tower.damage || 0;
        }
        
        // 应用攻击力加成
        tower.damage = Math.floor(tower.baseDamage * attackBonus);
      });
      
      // 应用防御科技效果（核心生命值加成）
      const coreHealthBonus = 1 + (defenseLevel * 10) / 100;
      if (gameData.baseMaxCoreHealth === undefined || gameData.baseMaxCoreHealth === null) {
        gameData.baseMaxCoreHealth = gameData.maxCoreHealth || 100;
      }
      gameData.maxCoreHealth = Math.floor(gameData.baseMaxCoreHealth * coreHealthBonus);
      
      // 应用防御科技效果（炮塔生命值加成）
      if (defenseLevel >= 2) {
        const towerHealthBonus = 1 + ((defenseLevel - 1) * 10) / 100;
        gameData.towers.forEach(tower => {
          // 保存基础生命值（如果尚未保存）
          if (tower.baseHealth === undefined || tower.baseHealth === null) {
            tower.baseHealth = tower.health || 0;
          }
          
          // 应用生命值加成
          tower.health = Math.floor(tower.baseHealth * towerHealthBonus);
          tower.maxHealth = Math.floor(tower.baseHealth * towerHealthBonus);
        });
      }
      
      // 更新游戏信息
      updateGameInfo();
    }
    
    // 显示通知
    function showNotification(message, color = '#3B82F6') {
      // 创建通知元素
      const notification = document.createElement('div');
      notification.textContent = message;
      notification.style.position = 'fixed';
      notification.style.top = '50%';
      notification.style.left = '50%';
      notification.style.transform = 'translate(-50%, -50%)';
      notification.style.padding = '1rem 2rem';
      notification.style.borderRadius = '5px';
      notification.style.backgroundColor = color;
      notification.style.color = 'white';
      notification.style.fontWeight = 'bold';
      notification.style.fontSize = '1.2rem';
      notification.style.zIndex = '1000';
      notification.style.opacity = '0';
      notification.style.transition = 'all 0.3s ease';
      
      // 添加到文档
      document.body.appendChild(notification);
      
      // 显示通知
      setTimeout(() => {
        notification.style.opacity = '1';
      }, 10);
      
      // 自动隐藏
      setTimeout(() => {
        notification.style.opacity = '0';
        setTimeout(() => {
          document.body.removeChild(notification);
        }, 300);
      }, 2000);
    }
    
    // 切换炮塔选择界面的收缩/展开状态
    function toggleTowerSelection() {
      const container = document.getElementById('tower-selection-container');
      const toggleIcon = document.getElementById('toggle-icon');
      const towerSelection = document.getElementById('tower-selection');
      
      // 切换收缩/展开状态
      if (container.classList.contains('tower-selection-collapsed')) {
        // 展开
        container.classList.remove('tower-selection-collapsed');
        container.style.width = '220px';
        toggleIcon.className = 'fa fa-chevron-left';
      } else {
        // 收缩
        container.classList.add('tower-selection-collapsed');
        container.style.width = '30px';
        toggleIcon.className = 'fa fa-chevron-right';
      }
    }
    
    // 改变游戏状态
    function changeGameState(state) {
      gameData.gameState = state;
      
      // 隐藏所有界面
      menuScreen.classList.add('hidden');
      difficultyScreen.classList.add('hidden');
      adminPasswordScreen.classList.add('hidden');
      adminScreen.classList.add('hidden');
      encyclopediaScreen.classList.add('hidden');
      gameScreen.classList.add('hidden');
      gameOverScreen.classList.add('hidden');
      victoryScreen.classList.add('hidden');
      towerInfoScreen.classList.add('hidden');

      
      // 显示当前状态的界面
      switch (state) {
        case 'menu':
          menuScreen.classList.remove('hidden');
          break;
        case 'difficulty':
          difficultyScreen.classList.remove('hidden');
          break;
        case 'admin-password':
          adminPasswordScreen.classList.remove('hidden');
          adminPasswordInput.value = '';
          break;
        case 'admin':
          adminScreen.classList.remove('hidden');
          updateAdminTables();
          break;
        case 'encyclopedia':
          encyclopediaScreen.classList.remove('hidden');
          break;
        case 'game':
          gameScreen.classList.remove('hidden');
          break;
        case 'game-over':
          gameOverScreen.classList.remove('hidden');
          wavesSurvived.textContent = gameData.currentWave - 1;
          
          // 暂停背景音乐
          soundManager.pauseBackgroundMusic();
          
          // 播放游戏结束音效
          soundManager.playSound('gameOverSound');
          break;
        case 'victory':
          victoryScreen.classList.remove('hidden');
          
          // 暂停背景音乐
          soundManager.pauseBackgroundMusic();
          
          // 播放胜利音效
          soundManager.playSound('victorySound');
          
          // 检查是否是无伤通关地狱模式
          if (gameData.difficulty === 'hell' && gameData.coreHealth === gameData.maxCoreHealth) {
            // 显示管理员密码
            const victoryMessage = document.getElementById('victory-message');
            const adminPasswordMessage = document.createElement('div');
            adminPasswordMessage.className = 'mt-4 p-4 bg-yellow-100 border border-yellow-400 rounded-md';
            adminPasswordMessage.innerHTML = `
              <p class="text-xl font-bold text-yellow-800">恭喜！你解锁了管理员模式！</p>
              <p class="mt-2 text-yellow-700">管理员密码：<span class="font-mono font-bold">taochenhaoshuai</span></p>
              <p class="mt-2 text-sm text-yellow-600">在主菜单点击"管理员模式"，输入密码即可进入。</p>
            `;
            victoryMessage.parentNode.insertBefore(adminPasswordMessage, victoryMessage.nextSibling);
          }
          break;
        case 'card-draw':
          // 显示游戏屏幕（作为背景）
          gameScreen.classList.remove('hidden');
          
          // 显示抽卡界面
          const cardDrawScreen = document.getElementById('card-draw-screen');
          if (cardDrawScreen) {
            cardDrawScreen.classList.remove('hidden');
          }
          break;
      }
    }
    
    // 简单的哈希函数
    function simpleHash(str) {
      let hash = 0;
      for (let i = 0; i < str.length; i++) {
        const char = str.charCodeAt(i);
        hash = ((hash << 5) - hash) + char;
        hash = hash & hash; // Convert to 32bit integer
      }
      return hash;
    }
    
    // 测试哈希值（仅用于开发调试，实际使用时应移除）
    console.log('taochenhaoshuai hash:', simpleHash('taochenhaoshuai'));
    
    
    
    // 检查管理员密码
    function checkAdminPassword() {
      const password = adminPasswordInput.value.trim();
      // 使用哈希值比对，避免明文存储
      if (simpleHash(password) === 1189639810) {
        gameData.isAdminMode = true;
        changeGameState('admin');
      } else {
        // 调试：显示输入密码的哈希值
        console.log('输入密码的哈希值:', simpleHash(password));
        alert('密码错误！');
      }
    }
    
    // 更新管理员表格
    function updateAdminTables() {
      // 清空表格
      towersTableBody.innerHTML = '';
      monstersTableBody.innerHTML = '';
      
      // 更新炮塔表格
      gameData.towerTypes.forEach(tower => {
        const row = document.createElement('tr');
        row.innerHTML = `
          <td>${tower.name}</td>
          <td><input type="number" value="${tower.range}" data-property="range" data-id="${tower.id}"></td>
          <td><input type="number" value="${tower.damage}" data-property="damage" data-id="${tower.id}"></td>
          <td><input type="number" step="0.1" value="${tower.fireRate}" data-property="fireRate" data-id="${tower.id}"></td>
          <td><input type="number" value="${tower.price}" data-property="price" data-id="${tower.id}"></td>
        `;
        towersTableBody.appendChild(row);
      });
      
      // 更新怪物表格
      gameData.monsterTypes.forEach(monster => {
        const row = document.createElement('tr');
        row.innerHTML = `
          <td>${monster.name}</td>
          <td><input type="number" value="${monster.health}" data-property="health" data-id="${monster.id}"></td>
          <td><input type="number" step="0.1" value="${monster.speed}" data-property="speed" data-id="${monster.id}"></td>
          <td><input type="number" value="${monster.coreDamage}" data-property="coreDamage" data-id="${monster.id}"></td>
        `;
        monstersTableBody.appendChild(row);
      });
      
      // 添加输入事件监听
      document.querySelectorAll('#towers-table-body input, #monsters-table-body input').forEach(input => {
        input.addEventListener('change', updateAdminValue);
      });
    }
    
    // 更新管理员设置值
    function updateAdminValue(event) {
      const input = event.target;
      const id = input.dataset.id;
      const property = input.dataset.property;
      const value = parseFloat(input.value);
      
      if (input.closest('#towers-table-body')) {
        const tower = gameData.towerTypes.find(t => t.id === id);
        if (tower) {
          tower[property] = value;
        }
      } else if (input.closest('#monsters-table-body')) {
        const monster = gameData.monsterTypes.find(m => m.id === id);
        if (monster) {
          monster[property] = value;
        }
      }
    }
    
    // 保存管理员设置
    function saveAdminSettings() {
      // 更新图鉴
      updateEncyclopedia();
      
      alert('设置已保存！');
    }
    
    // 更新图鉴
    function updateEncyclopedia() {
      // 清空图鉴
      towersEncyclopedia.innerHTML = '';
      monstersEncyclopedia.innerHTML = '';
      
      // 更新炮塔图鉴
      gameData.towerTypes.forEach(tower => {
        const item = document.createElement('div');
        item.className = 'encyclopedia-item';
        item.innerHTML = `
          <h3>${tower.name}</h3>
          <p><strong>射程:</strong> ${tower.range} 格</p>
          <p><strong>伤害:</strong> ${tower.damage}</p>
          <p><strong>攻击间隔:</strong> ${tower.fireRate} 秒</p>
          <p><strong>价格:</strong> ${tower.price} 金钱</p>
          <p><strong>特殊效果:</strong> <span class="special">${tower.special}</span></p>
        `;
        towersEncyclopedia.appendChild(item);
      });
      
      // 更新怪物图鉴
      gameData.monsterTypes.forEach(monster => {
        const item = document.createElement('div');
        item.className = 'encyclopedia-item';
        item.innerHTML = `
          <h3>${monster.name}</h3>
          <p><strong>血量:</strong> ${monster.health}</p>
          <p><strong>移动速度:</strong> ${monster.speed} 秒/格</p>
          <p><strong>核心伤害:</strong> ${monster.coreDamage}</p>
          <p><strong>特殊效果:</strong> <span class="special">${monster.special}</span></p>
        `;
        monstersEncyclopedia.appendChild(item);
      });
    }
    
    // 开始游戏
    function startGame(difficulty) {
      // 重置游戏数据
      resetGame();
      
      // 设置难度
      gameData.difficulty = difficulty;
      
      // 设置初始金钱
      gameData.money = gameData.difficultySettings[difficulty].initialMoney;
      
      // 更新显示
      updateGameInfo();
      
      // 生成炮塔选择界面
      generateTowerSelection();
      
      // 改变游戏状态
      changeGameState('game');
      
      // 开始第一波
      startWave();
    }
    
    // 重置游戏
    function resetGame() {
      // 重置游戏数据
      gameData.currentWave = 1;
      gameData.coreHealth = 100;
      gameData.isGameOver = false;
      gameData.isVictory = false;
      gameData.isWaveActive = false;
      gameData.waveStartTime = 0;
      gameData.currentBoss = null;
      gameData.miniBossesKilled = 0; // 重置小BOSS击杀计数
      gameData.quantumTowerUnlocked = false; // 重置量子炮解锁状态
      
      // 清空游戏对象
      gameData.towers = [];
      gameData.monsters = [];
      gameData.allies = [];
      gameData.projectiles = [];
      gameData.explosions = [];
      gameData.effects = [];
      gameData.floatingTexts = [];
      
      // 重置路径
      gameData.blockedCells.clear();
      gameData.path = [];
      generatePath();
      
      // 初始化任务系统
      initializeMissionSystem();
      
      // 初始化成就系统
      initializeAchievementSystem();
      
      // 初始化技能系统
      initializeSkillSystem();
      
      // 初始化UI事件监听器
      initializeUIEventListeners();
      
      // 如果不是管理员模式，重置参数
      if (!gameData.isAdminMode) {
        gameData.towerTypes = JSON.parse(JSON.stringify(initialTowerTypes));
        gameData.monsterTypes = JSON.parse(JSON.stringify(initialMonsterTypes));
      }
      
      // 重置量子炮图标
      if (quantumTowerIcon) {
        quantumTowerIcon.className = 'fa fa-lock';
        quantumTowerIcon.style.color = '';
        quantumTowerIcon.style.textShadow = '';
      }
      
      // 更新图鉴
      updateEncyclopedia();
    }
    
    // 生成路径
    function generatePath() {
      // 清空路径
      gameData.path = [];
      
      // 生成从左上角到右下角的更加曲折的路径
      // 路径设计：右 -> 下 -> 右 -> 下 -> 左 -> 下 -> 右 -> 下 -> 右
      // 这种路径更加复杂，提供更好的游戏体验
      
      // 第一段：右移
      for (let x = 0; x < 5; x++) {
        gameData.path.push({ x, y: 0 });
      }
      
      // 第一段：下移
      for (let y = 1; y < 3; y++) {
        gameData.path.push({ x: 4, y });
      }
      
      // 第二段：右移
      for (let x = 5; x < 9; x++) {
        gameData.path.push({ x, y: 2 });
      }
      
      // 第二段：下移
      for (let y = 3; y < 6; y++) {
        gameData.path.push({ x: 8, y });
      }
      
      // 第三段：左移（增加曲折度）
      for (let x = 7; x >= 3; x--) {
        gameData.path.push({ x, y: 5 });
      }
      
      // 第三段：下移
      for (let y = 6; y < 9; y++) {
        gameData.path.push({ x: 3, y });
      }
      
      // 第四段：右移
      for (let x = 4; x < 14; x++) {
        gameData.path.push({ x, y: 8 });
      }
      
      // 第四段：下移
      for (let y = 9; y < 11; y++) {
        gameData.path.push({ x: 13, y });
      }
      
      // 第五段：右移
      for (let x = 14; x < gameData.gridSize.width; x++) {
        gameData.path.push({ x, y: 10 });
      }
      
      // 添加禁止放置区域
      // 起点周围3x3区域
      const startX = gameData.path[0].x;
      const startY = gameData.path[0].y;
      for (let x = startX - 1; x <= startX + 1; x++) {
        for (let y = startY - 1; y <= startY + 1; y++) {
          if (x >= 0 && x < gameData.gridSize.width && y >= 0 && y < gameData.gridSize.height) {
            gameData.blockedCells.add(`${x},${y}`);
          }
        }
      }
      
      // 终点（核心）周围3x3区域
      const endPoint = gameData.path[gameData.path.length - 1];
      const endX = endPoint.x;
      const endY = endPoint.y;
      for (let x = endX - 1; x <= endX + 1; x++) {
        for (let y = endY - 1; y <= endY + 1; y++) {
          if (x >= 0 && x < gameData.gridSize.width && y >= 0 && y < gameData.gridSize.height) {
            gameData.blockedCells.add(`${x},${y}`);
          }
        }
      }
      
      // 路径上的格子也禁止放置炮塔
      gameData.path.forEach(point => {
        gameData.blockedCells.add(`${point.x},${point.y}`);
      });
    }
    
    // 生成炮塔选择界面
    function generateTowerSelection() {
      // 清空炮塔选择界面
      towerSelection.innerHTML = '';
      
      // 添加炮塔选项
      gameData.towerTypes.forEach(tower => {
        const towerOption = document.createElement('div');
        towerOption.className = 'tower-option';
        towerOption.dataset.id = tower.id;
        towerOption.innerHTML = `
          <h3>${tower.name}</h3>
          <p>价格: ${tower.price} 金钱</p>
          <p>伤害: ${tower.damage}</p>
          <p>攻击间隔: ${tower.fireRate} 秒</p>
          <p>射程: ${tower.range} 格</p>
        `;
        
        towerOption.addEventListener('click', () => {
          // 取消之前的选择
          document.querySelectorAll('.tower-option').forEach(option => {
            option.classList.remove('selected');
          });
          
          // 选择当前炮塔
          towerOption.classList.add('selected');
          gameData.selectedTower = tower.id;
        });
        
        towerSelection.appendChild(towerOption);
      });
    }
    
    // 生成己方单位选择界面
    function generateAllySelection() {
      const allySelection = document.getElementById('ally-selection');
      allySelection.innerHTML = '';
      
      // 按价格排序单位
      const sortedAllies = [...gameData.allyTypes].sort((a, b) => a.price - b.price);
      
      sortedAllies.forEach(allyType => {
        const allyOption = document.createElement('div');
        allyOption.className = 'tower-option';
        allyOption.dataset.id = allyType.id;
        allyOption.innerHTML = `
          <h3>${allyType.name}</h3>
          <p>价格: ${allyType.price} 金钱</p>
          <p>伤害: ${allyType.damage}</p>
          <p>生命值: ${allyType.health}</p>
          <p>速度: ${allyType.speed}</p>
        `;
        
        allyOption.addEventListener('click', () => {
          // 取消之前的选择
          document.querySelectorAll('.tower-option').forEach(option => {
            option.classList.remove('selected');
          });
          
          // 选择单位类型
          allyOption.classList.add('selected');
          gameData.selectedTower = null;
          gameData.selectedAllyType = allyType.id;
          
          // 显示选择提示
          showFloatingText(gameData.path[0].x, gameData.path[0].y, `选择了${allyType.name}，点击路径放置`, '#3B82F6', 2);
        });
        
        allySelection.appendChild(allyOption);
      });
    }
    
    // 开始波次
    function startWave() {
      // 更新波次显示
      waveDisplay.textContent = `波数: ${gameData.currentWave}/${gameData.waveSettings.maxBaseWave}`;
      
      // 显示波次通知
      waveNotification.textContent = `第${gameData.currentWave}波`;
      waveNotification.classList.add('show');
      setTimeout(() => {
        waveNotification.classList.remove('show');
      }, 2000);
      
      // 设置波次状态
      gameData.isWaveActive = true;
      gameData.waveStartTime = Date.now();
      
      // 生成怪物
      generateMonsters();
      
      // 开始波次完成检测
      checkWaveCompletion();
    }
    
    // 检查波次完成
    function checkWaveCompletion() {
      // 如果游戏结束，停止检测
      if (gameData.gameOver) return;
      
      // 检查是否所有怪物都已被消灭
      if (gameData.isWaveActive && gameData.monsters.length === 0) {
        // 波次完成
        gameData.isWaveActive = false;
        
        // 显示波次完成通知
        showFloatingText(gameData.gridSize.width / 2, gameData.gridSize.height / 2, `第${gameData.currentWave}波完成！`, '#10B981', 2);
        
        // 给玩家一些奖励
        const waveReward = 100 + gameData.currentWave * 50;
        gameData.money += waveReward;
        showFloatingText(gameData.gridSize.width / 2, gameData.gridSize.height / 2 + 30, `获得奖励: ${waveReward} 金币`, '#F59E0B', 2);
        
        // 更新金钱显示
        updateMoneyDisplay();
        
        // 延迟后开始下一波
        setTimeout(() => {
          gameData.currentWave++;
          startWave();
        }, 3000); // 3秒后开始下一波
      } else {
        // 继续检测
        setTimeout(checkWaveCompletion, 1000);
      }
    }
    
    // 生成怪物
    function generateMonsters() {
      // 清空现有怪物
      gameData.monsters = [];
      
      // 确定可用怪物类型
      let availableMonsters = [...gameData.waveSettings.baseMonsters];
      
      // 根据波次逐步解锁新敌人类型
      if (gameData.currentWave >= 11) {
        availableMonsters.push('spider'); // 第11波开始出现机械蜘蛛
      }
      if (gameData.currentWave >= 15) {
        availableMonsters.push('swarmer'); // 第15波开始出现蜂群无人机
        availableMonsters.push('shield', 'healer', 'drone', 'bomber'); // 提前解锁这些怪物
      }
      if (gameData.currentWave >= 25) {
        availableMonsters.push('corruptor'); // 第25波开始出现腐蚀者
      }
      if (gameData.currentWave >= 35) {
        availableMonsters.push('juggernaut'); // 第35波开始出现重装战车
      }
      if (gameData.currentWave >= 51) {
        // 第51波开始出现稀有怪物
        availableMonsters.push('charger', 'assassin', 'reaper', 'stealth');
      }
      
      // 确保有可用的怪物类型
      if (!availableMonsters || availableMonsters.length === 0) {
        availableMonsters = gameData.waveSettings.baseMonsters;
      }
      
      // 无尽模式设置
      let waveMultiplier = 1;
      let monsterCountMultiplier = 1;
      let eliteMonsterChance = 0;
      
      if (gameData.waveSettings.endlessMode) {
        // 计算波数乘数，基础波数后开始增加难度
        const waveOffset = Math.max(0, gameData.currentWave - gameData.waveSettings.maxBaseWave);
        waveMultiplier = 1 + waveOffset * gameData.waveSettings.monsterHealthMultiplierPerWave;
        monsterCountMultiplier = 1 + waveOffset * gameData.waveSettings.monsterCountMultiplierPerWave;
        eliteMonsterChance = waveOffset * gameData.waveSettings.eliteMonsterChancePerWave;
        
        // 显示无尽模式通知
        if (gameData.currentWave === gameData.waveSettings.maxBaseWave + 1) {
          showFloatingText(gameData.gridSize.width / 2, gameData.gridSize.height / 2, '无尽模式开启！', '#F59E0B', 3);
        }
      }
      
      // 计算怪物数量
      let monsterCount = Math.min(5 + gameData.currentWave * 2, 50);
      
      // 无尽模式下增加怪物数量
      if (gameData.waveSettings.endlessMode) {
        monsterCount = Math.min(Math.floor(monsterCount * monsterCountMultiplier), gameData.waveSettings.maxMonsterCount);
      }
      
      // 按类型分组生成怪物，实现交错生成
      const monstersByType = {};
      availableMonsters.forEach(type => {
        monstersByType[type] = [];
      });
      
      // 根据波次难度调整各类型怪物比例
      const waveFactor = Math.min(1, gameData.currentWave / 50); // 波次因子，用于调整比例
      
      // 确保至少生成一些怪物
      if (monsterCount === 0) {
        monsterCount = Math.max(5, Math.floor(gameData.currentWave / 2));
      }
      
      // 额外的安全检查，确保怪物数量足够
      if (monsterCount < 3) {
        monsterCount = Math.max(3, Math.floor(gameData.currentWave / 2));
      }
      
      // 生成怪物并按类型分组
      for (let i = 0; i < monsterCount; i++) {
        let monsterType;
        
        // 根据波次调整怪物类型概率
        if (gameData.currentWave <= 10) {
          // 早期波次以普通怪物为主
          const rand = Math.random();
          if (rand < 0.6) {
            monsterType = 'normal';
          } else if (rand < 0.85) {
            monsterType = 'fast';
          } else {
            monsterType = 'heavy';
          }
        } else {
          // 后期波次怪物类型更加多样化
          const rand = Math.random();
          
          // 创建可用怪物类型的权重数组
          const weightedTypes = [];
          
          // 根据波数计算权重调整因子
          const waveFactor = Math.min(1, (gameData.currentWave - 10) / 40); // 从第11波开始调整，到第50波达到最大值
          
          // 基础怪物类型权重随波数减少
          const normalWeight = Math.max(0.1, 0.25 - waveFactor * 0.15);
          const fastWeight = Math.max(0.1, 0.2 - waveFactor * 0.1);
          const heavyWeight = Math.max(0.05, 0.15 - waveFactor * 0.1);
          
          // 添加基础怪物类型
          weightedTypes.push({ type: 'normal', weight: normalWeight });
          weightedTypes.push({ type: 'fast', weight: fastWeight });
          weightedTypes.push({ type: 'heavy', weight: heavyWeight });
          
          // 添加新敌人类型（如果可用），权重随波数增加
          if (availableMonsters.includes('spider')) {
            const spiderWeight = Math.min(0.2, 0.12 + waveFactor * 0.1);
            weightedTypes.push({ type: 'spider', weight: spiderWeight });
          }
          if (availableMonsters.includes('swarmer')) {
            const swarmerWeight = Math.min(0.15, 0.1 + waveFactor * 0.1);
            weightedTypes.push({ type: 'swarmer', weight: swarmerWeight });
          }
          if (availableMonsters.includes('corruptor')) {
            const corruptorWeight = Math.min(0.12, 0.08 + waveFactor * 0.08);
            weightedTypes.push({ type: 'corruptor', weight: corruptorWeight });
          }
          if (availableMonsters.includes('juggernaut')) {
            const juggernautWeight = Math.min(0.1, 0.05 + waveFactor * 0.1);
            weightedTypes.push({ type: 'juggernaut', weight: juggernautWeight });
          }
          
          // 添加高级怪物类型（如果可用），权重随波数增加
          if (availableMonsters.includes('shield')) {
            const shieldWeight = Math.min(0.08, 0.05 + waveFactor * 0.06);
            weightedTypes.push({ type: 'shield', weight: shieldWeight });
          }
          if (availableMonsters.includes('healer')) {
            const healerWeight = Math.min(0.06, 0.03 + waveFactor * 0.05);
            weightedTypes.push({ type: 'healer', weight: healerWeight });
          }
          if (availableMonsters.includes('drone')) {
            const droneWeight = Math.min(0.05, 0.02 + waveFactor * 0.04);
            weightedTypes.push({ type: 'drone', weight: droneWeight });
          }
          if (availableMonsters.includes('bomber')) {
            const bomberWeight = Math.min(0.05, 0.02 + waveFactor * 0.04);
            weightedTypes.push({ type: 'bomber', weight: bomberWeight });
          }
          
          // 添加机械士兵
          if (availableMonsters.includes('mech')) {
            const mechWeight = Math.min(0.15, 0.1 + waveFactor * 0.1);
            weightedTypes.push({ type: 'mech', weight: mechWeight });
          }
          
          // 添加稀有怪物类型（如果可用），权重随波数增加
          const rareTypes = ['charger', 'assassin', 'reaper', 'stealth'];
          rareTypes.forEach(type => {
            if (availableMonsters.includes(type)) {
              const rareWeight = Math.min(0.02, 0.005 + waveFactor * 0.02);
              weightedTypes.push({ type: type, weight: rareWeight });
            }
          });
          
          // 根据权重随机选择怪物类型
          let totalWeight = weightedTypes.reduce((sum, item) => sum + item.weight, 0);
          let randomValue = rand * totalWeight;
          
          for (const item of weightedTypes) {
            randomValue -= item.weight;
            if (randomValue <= 0) {
              monsterType = item.type;
              break;
            }
          }
          
          // 如果没有选中任何类型（理论上不应该发生），使用默认类型
          if (!monsterType) {
            monsterType = 'normal';
          }
        }
        
        const monsterData = gameData.monsterTypes.find(m => m.id === monsterType);
        
        // 检查怪物类型是否存在，如果不存在则使用默认类型
        if (!monsterData) {
          console.warn(`怪物类型 '${monsterType}' 不存在，使用默认类型 'normal'`);
          monsterType = 'normal';
          monsterData = gameData.monsterTypes.find(m => m.id === monsterType);
          
          // 如果默认类型也不存在，创建一个基础的怪物数据结构
          if (!monsterData) {
            console.error('默认怪物类型也不存在，创建基础怪物数据');
            monsterData = {
              id: 'normal',
              name: '未知怪物',
              health: 500,
              speed: 4,
              coreDamage: 3,
              reward: 50
            };
          }
        }
        
        // 应用难度乘数和波数加成
        const difficulty = gameData.difficultySettings && gameData.difficultySettings[gameData.difficulty] ? gameData.difficultySettings[gameData.difficulty] : gameData.difficultySettings.normal;
        let currentWaveMultiplier = 1 + gameData.currentWave * 0.1; // 每波增加10%血量
        
        // 无尽模式下使用自定义波数乘数
        if (gameData.waveSettings.endlessMode) {
          currentWaveMultiplier = waveMultiplier;
        }
        
        let health = monsterData.health * difficulty.monsterHealthMultiplier * currentWaveMultiplier;
        let speed = monsterData.speed * difficulty.monsterSpeedMultiplier;
        let coreDamage = monsterData.coreDamage * difficulty.monsterCoreDamageMultiplier;
        
        // 无尽模式下增加怪物速度
        if (gameData.waveSettings.endlessMode) {
          const waveOffset = Math.max(0, gameData.currentWave - gameData.waveSettings.maxBaseWave);
          speed *= 1 + waveOffset * gameData.waveSettings.monsterSpeedMultiplierPerWave;
        }
        
        // 生成精英怪物
        let isElite = false;
        if (gameData.waveSettings.endlessMode && Math.random() < eliteMonsterChance) {
          isElite = true;
          health *= gameData.waveSettings.eliteMonsterHealthMultiplier;
          speed *= gameData.waveSettings.eliteMonsterSpeedMultiplier;
          coreDamage *= 2; // 精英怪物对核心伤害翻倍
        }
        
        // 创建怪物
        const monster = {
          id: `monster-${Date.now()}-${i}`,
          type: monsterType,
          name: isElite ? `精英${monsterData.name}` : monsterData.name,
          health: health,
          maxHealth: health,
          speed: speed,
          coreDamage: coreDamage,
          position: { x: gameData.path[0].x, y: gameData.path[0].y },
          pathIndex: 0,
          progress: 0,
          isFlying: monsterType === 'drone',
          isStunned: false,
          isSlowed: false,
          slowDuration: 0,
          isElite: isElite,
          reward: isElite ? Math.floor(monsterData.reward * gameData.waveSettings.eliteMonsterRewardMultiplier) : monsterData.reward,
          isInvulnerable: false,
          invulnerableDuration: 0,
          isBomberActivated: false,
          bomberTimer: 3 + Math.random() * 4, // 3-7秒后爆炸，增加随机性
          healerTimer: 0,
          reaperTimer: 0,
          iceMageTimer: 0,
          // 炮塔攻击能力
          canAttackTowers: true, // 怪物可以攻击炮塔
          towerAttackDamage: Math.floor(coreDamage * 0.5), // 对炮塔伤害为核心伤害的一半
          towerAttackRange: 1, // 攻击范围（格）
          lastTowerAttackTime: 0, // 上次攻击炮塔时间
          towerAttackCooldown: 2000, // 攻击冷却时间（毫秒）
          // 隐形刺客特殊属性
          isInvisible: false,
          invisibleTime: 0,
          stealthCooldown: 0
        };
        
        // 蜂群无人机特殊处理：生成10只一组
        if (monsterType === 'swarmer') {
          for (let j = 0; j < 10; j++) {
            const swarmMonster = {
              ...monster,
              id: `monster-${Date.now()}-${i}-${j}`,
              name: `蜂群无人机-${j+1}`
            };
            monstersByType[monsterType].push(swarmMonster);
          }
        } else {
          monstersByType[monsterType].push(monster);
        }
      }
      
      // 检查是否为大BOSS波次（每10波）
      const isBossWave = gameData.currentWave % 10 === 0 && gameData.currentWave >= 10;
      
      if (isBossWave) {
        // 大BOSS波次：只生成大BOSS
        console.log(`第${gameData.currentWave}波：大BOSS波次！`);
        
        // 创建大BOSS
        const bigBoss = {
          id: `big-boss-${Date.now()}`,
          type: 'big-boss',
          name: '大BOSS',
          health: 50000 * (1 + gameData.currentWave * 0.2), // 基础50000血，每波增加20%
          maxHealth: 50000 * (1 + gameData.currentWave * 0.2),
          speed: 3, // 大BOSS移动较慢
          coreDamage: 50, // 对核心伤害很高
          position: { x: gameData.path[0].x, y: gameData.path[0].y },
          pathIndex: 0,
          progress: 0,
          isFlying: false,
          isStunned: false,
          isSlowed: false,
          slowDuration: 0,
          isElite: true,
          reward: 10000 + gameData.currentWave * 1000, // 大量金钱奖励
          isInvulnerable: false,
          invulnerableDuration: 0,
          // 大BOSS特殊属性
          isBigBoss: true,
          // 召唤能力
          summonTimer: 10, // 每10秒召唤一次
          summonCount: 0,
          maxSummons: 5, // 最多召唤5次
          isSummoning: false,
          summonDuration: 3,
          summonProgress: 0,
          // 护盾效果
          shieldHealth: 10000,
          maxShieldHealth: 10000,
          isShielded: true,
          // 攻击能力
          attackTimer: 3, // 每3秒攻击一次
          attackRange: 3, // 攻击范围
          attackDamage: 100, // 攻击伤害
          // 独特外观
          hasUniqueAppearance: true,
          shouldNotDisappear: true,
          // 大BOSS特殊技能
          enrageThreshold: 0.3, // 血量低于30%时狂暴
          isEnraged: false,
          enrageSpeedMultiplier: 1.5,
          enrageDamageMultiplier: 2
        };
        
        gameData.miniBossQueue = [bigBoss];
        
        // 显示大BOSS出现通知
        setTimeout(() => {
          showFloatingText(gameData.gridSize.width / 2, gameData.gridSize.height / 2, '大BOSS出现！', '#EF4444', 4);
          showFloatingText(gameData.gridSize.width / 2, gameData.gridSize.height / 2 + 40, '小心！它非常强大！', '#F59E0B', 4);
        }, 1000);
        
      } else if (gameData.currentWave >= 5) {
        // 普通波次：添加小BOSS
        // 增强小BOSS属性
        const miniBossData = gameData.monsterTypes.find(m => m.id === 'mini-boss');
        if (miniBossData) {
          const difficulty = gameData.difficultySettings && gameData.difficultySettings[gameData.difficulty] ? gameData.difficultySettings[gameData.difficulty] : gameData.difficultySettings.normal;
          const currentWaveMultiplier = 1 + gameData.currentWave * 0.2; // 增强：每波增加20%血量
          
          const health = miniBossData.health * difficulty.monsterHealthMultiplier * currentWaveMultiplier;
          const speed = miniBossData.speed * difficulty.monsterSpeedMultiplier;
          const coreDamage = miniBossData.coreDamage * difficulty.monsterCoreDamageMultiplier;
          
          // 创建增强版小BOSS
          const miniBoss = {
            id: `mini-boss-${Date.now()}`,
            type: 'mini-boss',
            name: 'BOSS',
            health: health,
            maxHealth: health,
            speed: speed,
            coreDamage: coreDamage,
            position: { x: gameData.path[0].x, y: gameData.path[0].y },
            pathIndex: 0,
            progress: 0,
            isFlying: false,
            isStunned: false,
            isSlowed: false,
            slowDuration: 0,
            isElite: true,
            reward: 3000 + gameData.currentWave * 300, // 增加奖励
            isInvulnerable: false,
            invulnerableDuration: 0,
            // 小BOSS增强属性
            isMiniBoss: true,
            // 增强的召唤能力
            summonTimer: 4, // 每4秒召唤一次（更频繁）
            summonCount: 0,
            maxSummons: 20, // 最多召唤20次
            isSummoning: false,
            summonDuration: 2,
            summonProgress: 0,
            // 增强的护盾
            shieldHealth: 3000, // 护盾值提升
            maxShieldHealth: 3000,
            isShielded: true,
            // 攻击炮塔能力
            canAttackTowers: true,
            towerAttackDamage: Math.floor(coreDamage * 0.8), // 对炮塔伤害提升
            towerAttackRange: 2,
            lastTowerAttackTime: 0,
            towerAttackCooldown: 3000,
            // 移动速度变化
            originalSpeed: speed,
            // 独特外观
            hasUniqueAppearance: true,
            shouldNotDisappear: true
          };
          
          gameData.miniBossQueue = [miniBoss];
        }
      }
      
      // 交错生成怪物
      const monsterQueues = [];
      availableMonsters.forEach(type => {
        if (monstersByType[type].length > 0) {
          monsterQueues.push({
            type: type,
            queue: [...monstersByType[type]],
            interval: 300 + Math.random() * 200 // 每个类型的生成间隔随机
          });
        }
      });
      
      // 交错生成计时器
      let globalTimer = 0;
      const interval = 100; // 检查间隔
      let miniBossSpawned = false;
      
      function spawnNextMonster() {
        let spawned = false;
        
        // 检查每个类型队列是否可以生成下一个怪物
        monsterQueues.forEach(queue => {
          if (queue.queue.length > 0 && globalTimer % Math.round(queue.interval / interval) === 0) {
            const monster = queue.queue.shift();
            gameData.monsters.push(monster);
            spawned = true;
          }
        });
        
        // 检查是否需要生成小BOSS
        if (gameData.miniBossQueue && !miniBossSpawned) {
          // 获取剩余怪物数量
          const remainingMonsters = monsterQueues.reduce((total, queue) => total + queue.queue.length, 0);
          
          // 当所有普通怪物都已生成时生成小BOSS
          if (remainingMonsters === 0) {
            const miniBoss = gameData.miniBossQueue.shift();
            gameData.monsters.push(miniBoss);
            miniBossSpawned = true;
            
            // 显示小BOSS出现通知
            showFloatingText(gameData.gridSize.width / 2, gameData.gridSize.height / 2, '小BOSS出现！', '#EF4444', 3);
            
            // 播放BOSS出现音效
            soundManager.playSound('bossSpawnSound');
          }
        }
        
        globalTimer++;
        
        // 如果还有怪物需要生成，继续下一轮
        const remainingMonsters = monsterQueues.reduce((total, queue) => total + queue.queue.length, 0);
        if (remainingMonsters > 0 || (gameData.miniBossQueue && !miniBossSpawned)) {
          gameData.timers.spawnInterval = setTimeout(spawnNextMonster, interval);
        }
      }
      
      // 开始交错生成
      if (monsterQueues.length > 0 || (gameData.miniBossQueue && gameData.miniBossQueue.length > 0)) {
        spawnNextMonster();
      } else {
        console.warn('没有怪物队列可生成，创建默认怪物');
        // 如果没有怪物队列，创建多个默认怪物
        for (let i = 0; i < Math.min(5 + gameData.currentWave, 20); i++) {
          const defaultMonster = createMonster('normal');
          if (defaultMonster) {
            gameData.monsters.push(defaultMonster);
          }
        }
        console.log(`生成了${gameData.monsters.length}个默认怪物`);
        
        // 如果仍然没有怪物，强制生成基础怪物
        if (gameData.monsters.length === 0) {
          console.error('强制生成基础怪物');
          const monsterData = gameData.monsterTypes.find(m => m.id === 'normal');
          if (monsterData) {
            const difficulty = gameData.difficultySettings && gameData.difficultySettings[gameData.difficulty] ? gameData.difficultySettings[gameData.difficulty] : gameData.difficultySettings.normal;
            const currentWaveMultiplier = 1 + gameData.currentWave * 0.1;
            
            const monster = {
              id: `monster-${Date.now()}-default`,
              type: 'normal',
              name: monsterData.name,
              health: monsterData.health * difficulty.monsterHealthMultiplier * currentWaveMultiplier,
              maxHealth: monsterData.health * difficulty.monsterHealthMultiplier * currentWaveMultiplier,
              speed: monsterData.speed * difficulty.monsterSpeedMultiplier,
              coreDamage: monsterData.coreDamage * difficulty.monsterCoreDamageMultiplier,
              position: { x: gameData.path[0].x, y: gameData.path[0].y },
              pathIndex: 0,
              progress: 0,
              isFlying: false,
              isStunned: false,
              isSlowed: false,
              slowDuration: 0,
              isElite: false,
              reward: 20,
              isInvulnerable: false,
              invulnerableDuration: 0,
              canAttackTowers: false
            };
            gameData.monsters.push(monster);
            console.log('强制生成了normal类型怪物');
          }
        }
      }
    }
    
    // 怪物攻击炮塔函数
    function monstersAttackTowers() {
      gameData.monsters.forEach(monster => {
        // 检查是否可以攻击炮塔
        if (!monster.canAttackTowers || monster.isFlying) return;
        
        // 检查攻击冷却
        if (Date.now() - monster.lastTowerAttackTime < monster.towerAttackCooldown) return;
        
        // 寻找附近的炮塔
        const nearbyTowers = gameData.towers.filter(tower => {
          if (tower.isDestroyed) return false;
          
          const distance = Math.sqrt(
            Math.pow(tower.position.x - monster.position.x, 2) + 
            Math.pow(tower.position.y - monster.position.y, 2)
          );
          
          return distance <= monster.towerAttackRange;
        });
        
        // 如果有可攻击的炮塔
        if (nearbyTowers.length > 0) {
          // 选择第一个炮塔进行攻击
          const targetTower = nearbyTowers[0];
          
          // 攻击炮塔
          damageTower(targetTower, monster.towerAttackDamage);
          
          // 更新攻击时间
          monster.lastTowerAttackTime = Date.now();
          
          // 显示攻击效果
          createAttackEffect(monster.position.x, monster.position.y, targetTower.position.x, targetTower.position.y);
        }
      });
    }
    
    // 炮塔受伤函数
    function damageTower(tower, damage) {
      if (tower.isDestroyed) return;
      
      tower.health = Math.max(0, tower.health - damage);
      tower.lastAttackedTime = Date.now();
      
      // 显示受伤效果
      showTowerDamageEffect(tower);
      
      // 显示伤害数字
      showFloatingText(tower.position.x, tower.position.y, `-${damage}`, '#EF4444');
      
      // 检查是否被摧毁
      if (tower.health <= 0) {
        destroyTower(tower);
      }
    }
    
    // 炮塔摧毁函数
    function destroyTower(tower) {
      tower.isDestroyed = true;
      tower.health = 0;
      
      // 显示摧毁效果
      createExplosion(tower.position.x, tower.position.y, 'tower');
      
      // 显示摧毁通知
      showFloatingText(tower.position.x, tower.position.y, '炮塔被摧毁！', '#EF4444', 2);
      
      // 播放摧毁音效
      soundManager.playSound('towerDestroySound');
    }
    
    // 修复炮塔函数
    function repairTower(tower) {
      if (!tower.isDestroyed && tower.health >= tower.maxHealth) {
        showFloatingText(tower.position.x, tower.position.y, '炮塔已修复！', '#10B981');
        return false;
      }
      
      if (gameData.money < tower.repairCost) {
        showFloatingText(tower.position.x, tower.position.y, '金钱不足！', '#EF4444');
        return false;
      }
      
      // 扣除修复费用
      gameData.money -= tower.repairCost;
      updateGameInfo();
      
      // 修复炮塔
      tower.health = tower.maxHealth;
      tower.isDestroyed = false;
      
      // 显示修复效果
      showFloatingText(tower.position.x, tower.position.y, '炮塔已修复！', '#10B981');
      
      // 播放修复音效
      soundManager.playSound('towerRepairSound');
      
      return true;
    }
    
    // 显示炮塔受伤效果
    function showTowerDamageEffect(tower) {
      // 创建闪烁效果
      const towerElement = document.querySelector(`[data-tower-id="${tower.id}"]`);
      if (towerElement) {
        towerElement.classList.add('tower-damaged');
        setTimeout(() => {
          towerElement.classList.remove('tower-damaged');
        }, 500);
      }
    }
    
    // 生成BOSS
    function generateBoss() {
      // 获取BOSS数据
      const bossData = gameData.monsterTypes.find(m => m.id === gameData.waveSettings.bossMonster);
      
      // 应用难度乘数和波数加成
      const difficulty = gameData.difficultySettings && gameData.difficultySettings[gameData.difficulty] ? gameData.difficultySettings[gameData.difficulty] : gameData.difficultySettings.normal;
      const waveMultiplier = 1 + gameData.currentWave * 0.2; // 每波增加10%血量
      const health = bossData.health * difficulty.monsterHealthMultiplier * waveMultiplier;
      const speed =1.5* bossData.speed * difficulty.monsterSpeedMultiplier;
      const coreDamage = bossData.coreDamage * difficulty.monsterCoreDamageMultiplier;
      
      // 创建BOSS
      const boss = {
        id: `boss-${Date.now()}`,
        type: gameData.waveSettings.bossMonster,
        name: bossData.name,
        health: health,
        maxHealth: health,
        speed: speed,
        coreDamage: coreDamage,
        attackDamage: coreDamage * 0.5, // BOSS攻击伤害设为核心伤害的一半
        attackRange: 3, // BOSS攻击范围
        attackTimer: 0, // 攻击计时器
        position: { x: gameData.path[0].x, y: gameData.path[0].y },
        pathIndex: 0,
        progress: 0,
        isFlying: false,
        isStunned: false,
        isSlowed: false,
        slowDuration: 0,
        isInvulnerable: false,
        invulnerableDuration: 0,
        summonTimer: 0,
        rocketTimer: 0
      };
      
      gameData.monsters.push(boss);
      gameData.currentBoss = boss;
      
      // 显示BOSS血条
      bossHealthBar.classList.remove('hidden');
      bossHealthText.classList.remove('hidden');
      updateBossHealthBar();
    }
    
    // 更新BOSS血条
    function updateBossHealthBar() {
      if (!gameData.currentBoss) return;
      
      const healthPercentage = (gameData.currentBoss.health / gameData.currentBoss.maxHealth) * 100;
      bossHealthFill.style.width = `${healthPercentage}%`;
      bossHealthText.textContent = `BOSS: ${Math.floor(gameData.currentBoss.health)}/${gameData.currentBoss.maxHealth}`;
    }
    
    // 处理画布点击
    function handleCanvasClick(event) {
      if (gameData.gameState !== 'game' || gameData.isGameOver || gameData.isVictory) return;
      
      const rect = gameCanvas.getBoundingClientRect();
      const x = event.clientX - rect.left;
      const y = event.clientY - rect.top;
      
      // 计算点击的格子
      const gridX = Math.floor((x - gameData.gridOffset.x) / gameData.cellSize);
      const gridY = Math.floor((y - gameData.gridOffset.y) / gameData.cellSize);
      
      // 检查是否在网格范围内
      if (gridX >= 0 && gridX < gameData.gridSize.width && gridY >= 0 && gridY < gameData.gridSize.height) {
        // 检查是否在技能目标选择模式
        if (gameData.skillTargeting && gameData.skillTargeting.active) {
          const targetX = gameData.gridOffset.x + gridX * gameData.cellSize + gameData.cellSize / 2;
          const targetY = gameData.gridOffset.y + gridY * gameData.cellSize + gameData.cellSize / 2;
          handleSkillTargeting(targetX, targetY);
          return;
        }
        
        // 检查是否在加农炮目标选择模式
        if (gameData.isHowitzerTargeting && gameData.selectedHowitzer) {
          handleHowitzerTargetSelection(gridX, gridY);
          return;
        }
        
        // 检查是否点击了已有的炮塔
        const clickedTower = gameData.towers.find(tower => tower.position.x === gridX && tower.position.y === gridY);
        if (clickedTower) {
          // 显示炮塔信息
          showTowerInfo(clickedTower);
          return;
        }
        
        // 如果有选中的炮塔，尝试放置
        if (gameData.selectedTower) {
          placeTower(gridX, gridY);
        }
        
        // 如果有选中的单位，尝试放置
        if (gameData.selectedAllyType) {
          // 检查位置是否在路径上
          const isOnPath = gameData.path.some(point => point.x === gridX && point.y === gridY);
          if (isOnPath) {
            // 放置单位
            placeAlly(gridX, gridY, gameData.selectedAllyType);
          } else {
            // 显示错误提示
            showFloatingText(gridX, gridY, '只能放在路径上！', '#EF4444', 1);
          }
        }
      }
    }
    
    // 处理加农炮目标选择
    // 初始化技能快捷栏
    function initializeSkillHotbar() {
      const hotbar = document.getElementById('skill-hotbar');
      if (!hotbar) return;
      
      hotbar.innerHTML = '';
      
      // 为每个解锁的技能创建快捷按钮
      gameData.skillSystem.skills.forEach((skill, index) => {
        if (skill.unlocked) {
          const button = document.createElement('button');
          button.id = 'hotbar_' + skill.id;
          button.className = 'skill-hotbar-button';
          button.dataset.skillId = skill.id;
          button.dataset.key = (index + 1).toString();
          
          // 设置按钮内容
          const skillIcons = {
            'skill_orbital_strike': '🚀',
            'skill_time_freeze': '❄️',
            'skill_money_boost': '💰',
            'skill_shield_barrier': '🛡️',
            'skill_core_heal': '💚'
          };
          
          const icon = skillIcons[skill.id] || '✨';
          
          button.innerHTML = `
            <div class="skill-icon">${icon}</div>
            <div class="skill-name">${skill.name}</div>
            <div class="skill-level">${skill.level}</div>
            <div class="skill-key">${button.dataset.key}</div>
          `;
          
          // 添加点击事件
          button.addEventListener('click', () => {
            if (gameData.gameState === 'game' && !gameData.isGameOver && !gameData.isVictory) {
              // 对于需要目标的技能（如轨道打击），进入目标选择模式
              if (skill.id === 'skill_orbital_strike') {
                startSkillTargeting(skill.id);
              } else {
                // 其他技能直接使用
                useSkill(skill.id);
              }
            }
          });
          
          hotbar.appendChild(button);
        }
      });
      
      updateSkillHotbar();
    }
    
    // 更新技能快捷栏
    function updateSkillHotbar() {
      const hotbar = document.getElementById('skill-hotbar');
      if (!hotbar) return;
      
      gameData.skillSystem.skills.forEach(skill => {
        const button = document.getElementById('hotbar_' + skill.id);
        if (!button) return;
        
        // 检查冷却
        const cooldown = getSkillCooldown(skill.id);
        const cooldownElement = button.querySelector('.skill-cooldown');
        
        if (cooldown > 0) {
          button.disabled = true;
          if (!cooldownElement) {
            const cooldownDiv = document.createElement('div');
            cooldownDiv.className = 'skill-cooldown';
            cooldownDiv.textContent = cooldown;
            button.appendChild(cooldownDiv);
          } else {
            cooldownElement.textContent = cooldown;
          }
        } else {
          button.disabled = false;
          if (cooldownElement) {
            cooldownElement.remove();
          }
        }
        
        // 更新技能等级
        const levelElement = button.querySelector('.skill-level');
        if (levelElement) {
          levelElement.textContent = skill.level;
        }
      });
    }
    
    // 开始技能目标选择
    function startSkillTargeting(skillId) {
      gameData.skillTargeting = {
        skillId: skillId,
        active: true
      };
      
      // 显示目标选择提示
      showFloatingText(gameData.gridSize.width / 2, gameData.gridSize.height / 2, '请选择技能目标位置', '#F59E0B', 3);
    }
    
    // 结束技能目标选择
    function endSkillTargeting() {
      gameData.skillTargeting = null;
    }
    
    // 处理技能目标选择
    function handleSkillTargeting(x, y) {
      if (!gameData.skillTargeting || !gameData.skillTargeting.active) return;
      
      const skillId = gameData.skillTargeting.skillId;
      const skill = gameData.skillSystem.skills.find(s => s.id === skillId);
      
      if (skill) {
        // 使用技能并传入目标位置
        useSkill(skillId, { x, y });
      }
      
      // 结束目标选择模式
      endSkillTargeting();
    }
    
    // 启动BOSS行为处理
    function startBossBehaviorHandling() {
      // 清除现有的定时器
      if (window.bossBehaviorInterval) {
        clearInterval(window.bossBehaviorInterval);
      }
      
      // 创建新的定时器，每16ms执行一次（约60fps）
      window.bossBehaviorInterval = setInterval(() => {
        if (gameData && gameData.gameState === 'game' && !gameData.isGameOver && !gameData.isVictory) {
          handleBossBehavior();
        }
      }, 16);
      
      console.log('BOSS行为处理已启动');
    }
    
    // 停止BOSS行为处理
    function stopBossBehaviorHandling() {
      if (window.bossBehaviorInterval) {
        clearInterval(window.bossBehaviorInterval);
        window.bossBehaviorInterval = null;
        console.log('BOSS行为处理已停止');
      }
    }
    
    // 处理BOSS特殊行为
    function handleBossBehavior() {
      // 处理小BOSS行为
      gameData.miniBossQueue.forEach(boss => {
        if (boss.isDead) return;
        
        // 更新召唤计时器
        if (boss.summonTimer > 0) {
          boss.summonTimer -= 0.016; // 假设60fps
        }
        
        // 处理召唤逻辑
        if (boss.summonTimer <= 0 && boss.summonCount < boss.maxSummons && !boss.isSummoning) {
          boss.isSummoning = true;
          boss.summonProgress = 0;
          if (boss && boss.position) {
            showFloatingText(boss.position.x, boss.position.y, '正在召唤！', '#F59E0B', 2);
          }
        }
        
        // 处理召唤进度
        if (boss.isSummoning) {
          boss.summonProgress += 0.016;
          if (boss.summonProgress >= boss.summonDuration) {
            // 召唤完成，生成小怪物
            summonMinions(boss);
            boss.isSummoning = false;
            boss.summonTimer = boss.isBigBoss ? 10 : 4; // 大BOSS 10秒，小BOSS 4秒
            boss.summonCount++;
          }
        }
        
        // 处理护盾恢复（如果需要）
        if (boss.isShielded && boss.shieldHealth < boss.maxShieldHealth) {
          boss.shieldHealth = Math.min(boss.maxShieldHealth, boss.shieldHealth + 1);
        }
        
        // 大BOSS特殊能力：狂暴
        if (boss.isBigBoss) {
          const healthPercentage = boss.health / boss.maxHealth;
          if (healthPercentage <= boss.enrageThreshold && !boss.isEnraged) {
            boss.isEnraged = true;
            boss.speed *= boss.enrageSpeedMultiplier;
            boss.coreDamage *= boss.enrageDamageMultiplier;
            if (boss && boss.position) {
              showFloatingText(boss.position.x, boss.position.y, '狂暴！', '#EF4444', 3);
            }
          }
          
          // 更新攻击计时器
          if (boss.attackTimer > 0) {
            boss.attackTimer -= 0.016;
          }
          
          // 范围攻击
          if (boss.attackTimer <= 0) {
            attackTowersInRange(boss);
            boss.attackTimer = 3; // 3秒冷却
          }
        }
      });
    }
    
    // 召唤小怪
    function summonMinions(boss) {
      const summonCount = boss.isBigBoss ? 3 : 2; // 大BOSS召唤3个，小BOSS召唤2个
      const monsterTypes = ['juggernaut', 'corruptor', 'spider', 'swarmer'];
      
      for (let i = 0; i < summonCount; i++) {
        const monsterType = monsterTypes[Math.floor(Math.random() * monsterTypes.length)];
        const monsterData = gameData.monsterTypes.find(m => m.id === monsterType);
        
        if (monsterData) {
          const difficulty = gameData.difficultySettings && gameData.difficultySettings[gameData.difficulty] ? gameData.difficultySettings[gameData.difficulty] : gameData.difficultySettings.normal;
          const waveMultiplier = 1 + gameData.currentWave * 0.1;
          
          const monster = {
            id: `summoned-${monsterType}-${Date.now()}-${i}`,
            type: monsterType,
            name: monsterData.name,
            health: monsterData.health * difficulty.monsterHealthMultiplier * waveMultiplier * (boss.isBigBoss ? 1.5 : 1.2),
            maxHealth: monsterData.health * difficulty.monsterHealthMultiplier * waveMultiplier * (boss.isBigBoss ? 1.5 : 1.2),
            speed: monsterData.speed * difficulty.monsterSpeedMultiplier,
            coreDamage: monsterData.coreDamage * difficulty.monsterCoreDamageMultiplier,
            position: { x: (boss && boss.position ? boss.position.x : 0) + (Math.random() - 0.5) * 2, y: (boss && boss.position ? boss.position.y : 0) + (Math.random() - 0.5) * 2 },
            pathIndex: boss.pathIndex,
            progress: boss.progress,
            isFlying: monsterType === 'drone',
            isStunned: false,
            isSlowed: false,
            slowDuration: 0,
            isElite: boss.isBigBoss, // 大BOSS召唤的是精英怪
            reward: monsterData.reward,
            isInvulnerable: false,
            invulnerableDuration: 0,
            isSummoned: true // 标记为召唤的怪物
          };
          
          // 添加到怪物数组
          if (!gameData.monstersByType[monsterType]) {
            gameData.monstersByType[monsterType] = [];
          }
          gameData.monstersByType[monsterType].push(monster);
        }
      }
      
      if (boss && boss.position) {
        showFloatingText(boss.position.x, boss.position.y, `召唤了${summonCount}个怪物！`, '#F59E0B', 2);
      }
    }
    
    // BOSS范围攻击炮塔和单位
    function attackTowersInRange(boss) {
      // 添加空值检查
      if (!boss || !boss.position) {
        console.warn('BOSS对象或位置信息缺失');
        return;
      }
      
      // 攻击炮塔
      if (gameData.towers) {
        gameData.towers.forEach(tower => {
          const distance = Math.sqrt(
            Math.pow(tower.position.x - boss.position.x, 2) + 
            Math.pow(tower.position.y - boss.position.y, 2)
          );
          
          if (distance <= boss.attackRange) {
            // 对炮塔造成伤害
            tower.health = Math.max(0, tower.health - boss.attackDamage);
            showFloatingText(tower.position.x, tower.position.y, `-${boss.attackDamage}`, '#EF4444', 1);
            
            // 炮塔死亡检查
            if (tower.health <= 0) {
              showFloatingText(tower.position.x, tower.position.y, '炮塔被摧毁！', '#EF4444', 2);
              // 移除炮塔的逻辑会在其他地方处理
            }
          }
        });
      }
      
      // 攻击单位
      if (gameData.allies) {
        gameData.allies.forEach(ally => {
          const distance = Math.sqrt(
            Math.pow(ally.x - boss.position.x, 2) + 
            Math.pow(ally.y - boss.position.y, 2)
          );
          
          if (distance <= boss.attackRange) {
            // 对单位造成伤害
            ally.health = Math.max(0, ally.health - boss.attackDamage);
            showFloatingText(ally.x, ally.y, `-${boss.attackDamage}`, '#EF4444', 1);
            
            // 触发受击动画
            ally.hitAnimation = 1;
            
            // 检查单位是否死亡
            if (ally.health <= 0) {
              // 创建死亡特效
              if (gameData.effects && gameData.gridOffset && gameData.cellSize) {
                const effect = {
                  type: 'death',
                  x: gameData.gridOffset.x + ally.x * gameData.cellSize + gameData.cellSize / 2,
                  y: gameData.gridOffset.y + ally.y * gameData.cellSize + gameData.cellSize / 2,
                  size: gameData.cellSize,
                  time: 0
                };
                gameData.effects.push(effect);
              }
              
              // 从数组中移除单位
              const index = gameData.allies.indexOf(ally);
              if (index > -1) {
                gameData.allies.splice(index, 1);
              }
            }
          }
        });
      }
    }
    
    // 初始化UI事件监听器
    function initializeUIEventListeners() {
      console.log('初始化UI事件监听器...');
      
      // 直接为任务按钮添加点击事件，不依赖gameData.gameState
      const missionButton = document.getElementById('mission-system-button');
      if (missionButton) {
        console.log('找到任务按钮，添加事件监听器');
        
        // 移除可能存在的旧监听器
        const newButton = missionButton.cloneNode(true);
        missionButton.parentNode.replaceChild(newButton, missionButton);
        
        // 为新按钮添加监听器
        newButton.addEventListener('click', function() {
          console.log('任务按钮被点击！');
          console.log('当前游戏数据:', gameData);
          
          // 直接显示任务界面，不检查游戏状态
          const missionScreen = document.getElementById('mission-screen');
          if (missionScreen) {
            console.log('找到任务界面，显示中...');
            missionScreen.classList.remove('hidden');
            
            // 确保任务数据存在
            if (!gameData.missionSystem) {
              console.log('任务系统数据不存在，初始化中...');
              initializeMissionSystem();
            }
            
            // 更新任务界面
            updateMissionScreen();
          } else {
            console.log('未找到任务界面元素');
          }
        });
        
        console.log('任务按钮事件监听器添加成功');
      } else {
        console.log('错误：未找到任务按钮元素');
      }
      
      // 成就系统按钮
      const achievementButton = document.getElementById('achievement-system-button');
      if (achievementButton) {
        achievementButton.addEventListener('click', () => {
          if (gameData.gameState === 'game') {
            showAchievementScreen();
          }
        });
      }
      
      // 技能系统按钮
      const skillButton = document.getElementById('skill-system-button');
      if (skillButton) {
        skillButton.addEventListener('click', () => {
          if (gameData.gameState === 'game') {
            showSkillScreen();
          }
        });
      }
      
      // 科技系统按钮
      const techButton = document.getElementById('tech-system-button');
      if (techButton) {
        techButton.addEventListener('click', () => {
          if (gameData.gameState === 'game') {
            showTechScreen();
          }
        });
      }
      
      // 关闭按钮
      const closeMissionButton = document.getElementById('close-mission');
      if (closeMissionButton) {
        closeMissionButton.addEventListener('click', hideMissionScreen);
      }
      
      const closeSkillButton = document.getElementById('close-skill');
      if (closeSkillButton) {
        closeSkillButton.addEventListener('click', hideSkillScreen);
      }
    }
    
    // 显示任务界面
    function showMissionScreen() {
      const missionScreen = document.getElementById('mission-screen');
      if (missionScreen) {
        missionScreen.classList.remove('hidden');
        updateMissionScreen();
      }
    }
    
    // 隐藏任务界面
    function hideMissionScreen() {
      const missionScreen = document.getElementById('mission-screen');
      if (missionScreen) {
        missionScreen.classList.add('hidden');
      }
    }
    
    // 显示成就界面
    function showAchievementScreen() {
      const achievementScreen = document.getElementById('mission-screen'); // 复用任务界面
      if (achievementScreen) {
        // 修改标题
        const header = achievementScreen.querySelector('.mission-header h2');
        if (header) {
          header.textContent = '成就系统';
        }
        
        // 更新内容
        updateAchievementScreen();
        achievementScreen.classList.remove('hidden');
      }
    }
    
    // 显示技能界面
    function showSkillScreen() {
      const skillScreen = document.getElementById('skill-screen');
      if (skillScreen) {
        skillScreen.classList.remove('hidden');
        updateSkillScreen();
      }
    }
    
    // 隐藏技能界面
    function hideSkillScreen() {
      const skillScreen = document.getElementById('skill-screen');
      if (skillScreen) {
        skillScreen.classList.add('hidden');
      }
    }
    
    // 显示科技界面（占位函数）
    function showTechScreen() {
      alert('科技系统正在开发中，敬请期待！');
    }
    
    // 更新成就界面
    function updateAchievementScreen() {
      const missionList = document.getElementById('mission-list');
      if (!missionList) return;
      
      missionList.innerHTML = '';
      
      const achievements = getAchievementProgress();
      
      achievements.forEach(achievement => {
        const achievementItem = document.createElement('div');
        achievementItem.className = `mission-item ${achievement.completed ? 'completed' : ''}`;
        
        const progressText = achievement.completed ? '✓ 已完成' : `${achievement.current}/${achievement.target}`;
        
        achievementItem.innerHTML = `
          <div class="mission-item-header">
            <h3>${achievement.name}</h3>
            <span class="mission-status">${progressText}</span>
          </div>
          <p class="mission-description">${achievement.description}</p>
          <div class="mission-progress">进度: ${Math.round(achievement.progress * 100)}%</div>
          ${achievement.reward.techPoints ? `<div class="mission-reward">奖励: 🔬 ${achievement.reward.techPoints}</div>` : ''}
        `;
        
        missionList.appendChild(achievementItem);
      });
    }
    
    // 更新技能界面
    function updateSkillScreen() {
      const skillPointsDisplay = document.getElementById('skill-points-display');
      const skillList = document.getElementById('skill-list');
      
      if (skillPointsDisplay) {
        skillPointsDisplay.textContent = gameData.skillSystem.skillPoints;
      }
      
      if (!skillList) return;
      
      skillList.innerHTML = '';
      
      gameData.skillSystem.skills.forEach((skill, index) => {
        const skillItem = document.createElement('div');
        skillItem.className = `mission-item ${skill.unlocked ? '' : 'locked'}`;
        
        const canUpgrade = skill.unlocked && skill.level < skill.maxLevel && gameData.skillSystem.skillPoints > 0;
        const canUnlock = !skill.unlocked && index === 0 || (index > 0 && gameData.skillSystem.skills[index - 1].unlocked && gameData.skillSystem.skills[index - 1].level >= gameData.skillSystem.skills[index - 1].maxLevel) && gameData.skillSystem.skillPoints > 0;
        
        skillItem.innerHTML = `
          <div class="mission-item-header">
            <h3>${skill.name} ${skill.unlocked ? `<span class="text-sm text-gray-400">(等级 ${skill.level}/${skill.maxLevel})</span>` : ''}</h3>
            <span class="mission-status">${skill.unlocked ? '已解锁' : '未解锁'}</span>
          </div>
          <p class="mission-description">${skill.description}</p>
          <div class="skill-level">
            ${skill.unlocked ? `
              <button class="skill-button" id="upgrade_${skill.id}" ${canUpgrade ? '' : 'disabled'}>
                升级 (消耗1技能点)
              </button>
            ` : canUnlock ? `
              <button class="skill-button" id="unlock_${skill.id}">
                解锁 (消耗1技能点)
              </button>
            ` : '<span class="text-gray-400">需要先解锁前置技能</span>'}
          </div>
        `;
        
        skillList.appendChild(skillItem);
        
        // 添加按钮事件
        if (skill.unlocked && canUpgrade) {
          const upgradeButton = document.getElementById(`upgrade_${skill.id}`);
          if (upgradeButton) {
            upgradeButton.addEventListener('click', () => {
              if (upgradeSkill(skill.id)) {
                updateSkillScreen();
              }
            });
          }
        } else if (!skill.unlocked && canUnlock) {
          const unlockButton = document.getElementById(`unlock_${skill.id}`);
          if (unlockButton) {
            unlockButton.addEventListener('click', () => {
              if (unlockSkill(skill.id)) {
                updateSkillScreen();
                // 重新初始化技能快捷栏
                initializeSkillHotbar();
              }
            });
          }
        }
      });
    }
    
    /**
     * 处理加农炮目标选择
     * @param {number} gridX - 网格X坐标
     * @param {number} gridY - 网格Y坐标
     * @description 处理玩家选择加农炮攻击目标的逻辑，支持选择和确认两个阶段
     */
    function handleHowitzerTargetSelection(gridX, gridY) {
      // 如果已经选择了目标格子，确认发射
      if (gameData.selectedTargetCell && 
          gameData.selectedTargetCell.x === gridX && 
          gameData.selectedTargetCell.y === gridY) {
        // 发射加农炮
        fireHowitzer(gameData.selectedHowitzer, gridX, gridY);
        
        // 退出目标选择模式
        gameData.isHowitzerTargeting = false;
        gameData.selectedHowitzer = null;
        gameData.selectedTargetCell = null;
      } else {
        // 选择目标格子
        gameData.selectedTargetCell = { x: gridX, y: gridY };
        
        // 显示确认提示
        showFloatingText(gridX, gridY, '点击确认发射', '#F59E0B', 2);
      }
    }
    
    /**
     * 发射加农炮
     * @param {Object} tower - 加农炮炮塔对象
     * @param {number} targetX - 目标X坐标
     * @param {number} targetY - 目标Y坐标
     * @description 创建加农炮炮弹并添加到投射物数组，同时设置炮塔冷却时间
     */
    function fireHowitzer(tower, targetX, targetY) {
      // 设置冷却时间
      tower.cooldown = tower.fireRate;
      
      // 创建炮弹
      const projectile = {
        type: 'howitzer',           // 投射物类型
        towerType: 'howitzer',      // 发射炮塔类型
        damage: tower.damage,       // 伤害值
        position: { ...tower.position }, // 起始位置
        target: { x: targetX, y: targetY }, // 目标位置
        speed: 3,                   // 速度(格/秒)
        tower: tower                // 关联的炮塔
      };
      
      // 添加到投射物数组
      gameData.projectiles.push(projectile);
      
      // 显示发射提示
      showFloatingText(tower.position.x, tower.position.y, '发射！', '#F59E0B');
    }
    
    // 处理画布鼠标移动
    function handleCanvasMouseMove(event) {
      if (gameData.gameState !== 'game' || gameData.isGameOver || gameData.isVictory) return;
      
      const rect = gameCanvas.getBoundingClientRect();
      const x = event.clientX - rect.left;
      const y = event.clientY - rect.top;
      
      // 计算鼠标所在的格子
      const gridX = Math.floor((x - gameData.gridOffset.x) / gameData.cellSize);
      const gridY = Math.floor((y - gameData.gridOffset.y) / gameData.cellSize);
      
      // 检查是否在网格范围内
      if (gridX >= 0 && gridX < gameData.gridSize.width && gridY >= 0 && gridY < gameData.gridSize.height) {
        gameData.selectedCell = { x: gridX, y: gridY };
      } else {
        gameData.selectedCell = null;
      }
    }
    
    // 放置炮塔
    function placeTower(x, y) {
      // 检查是否是禁止放置区域
      if (gameData.blockedCells.has(`${x},${y}`)) {
        showFloatingText(x, y, '禁止放置！', '#EF4444');
        return;
      }
      
      // 检查是否已经有炮塔
      const towerExists = gameData.towers.some(tower => tower.position.x === x && tower.position.y === y);
      if (towerExists) {
        showFloatingText(x, y, '已有炮塔！', '#EF4444');
        return;
      }
      
      // 检查路径是否被阻挡
      if (!isPathValid(x, y)) {
        showFloatingText(x, y, '阻挡路径！', '#EF4444');
        return;
      }
      
      // 获取炮塔数据
      const towerData = gameData.towerTypes.find(t => t.id === gameData.selectedTower);
      if (!towerData) return;
      
      // 检查金钱是否足够
      if (gameData.money < towerData.price) {
        showFloatingText(x, y, '金钱不足！', '#EF4444');
        return;
      }
      
      // 创建炮塔
      const tower = {
        id: `tower-${Date.now()}`,
        type: towerData.id,
        name: towerData.name,
        range: towerData.range,
        damage: towerData.damage,
        fireRate: towerData.fireRate,
        price: towerData.price,
        special: towerData.special,
        position: { x, y },
        level: 1,
        fireTimer: 0,
        isFrozen: false,
        health: 100, // 默认生命值
        maxHealth: 100, // 默认最大生命值
        isDestroyed: false, // 炮台是否被摧毁
        lastAttackedTime: 0, // 上次被攻击时间
        repairCost: Math.floor(towerData.price * 0.3) // 修复费用
      };
      
      // 为加农炮添加冷却时间属性
      if (tower.type === 'howitzer') {
        tower.cooldown = 0; // 初始冷却时间为0，可以立即使用
      }
      
      // 扣除金钱
      gameData.money -= towerData.price;
      updateGameInfo();
      
      // 添加炮塔
      gameData.towers.push(tower);
      
      // 添加到阻挡单元格
      gameData.blockedCells.add(`${x},${y}`);
    }
    
    // 检查路径是否有效
    function isPathValid(x, y) {
      // 检查是否在禁止放置区域
      if (gameData.blockedCells.has(`${x},${y}`)) {
        return false;
      }
      
      // 检查是否阻挡路径（简单检查）
      return !gameData.path.some(point => point.x === x && point.y === y);
    }
    
    // 显示炮塔信息
    function showTowerInfo(tower) {
      // 设置炮塔信息
      towerInfoName.textContent = tower.name;
      towerInfoLevel.textContent = tower.level;
      towerInfoRange.textContent = tower.range;
      
      towerInfoDamage.textContent = tower.damage;
      towerInfoDamage.previousElementSibling.textContent = '伤害:';
      
      towerInfoFireRate.textContent = tower.fireRate;
      towerInfoSpecial.textContent = tower.special;
      
      // 计算升级费用
      const upgradeCostValue = Math.floor(tower.price * tower.level / 4);
      upgradeCost.textContent = upgradeCostValue;
      
      // 计算出售金额
      const sellAmountValue = Math.floor(tower.price * 0.5);
      sellAmount.textContent = sellAmountValue;
      
      // 存储当前选中的炮塔
      gameData.selectedTower = tower;
      
      // 显示炮塔信息界面
      towerInfoScreen.classList.remove('hidden');
      
      // 移除原有的升级按钮
      const upgradeButton = document.getElementById('upgrade-tower');
      if (upgradeButton) {
        upgradeButton.remove();
      }
      
      // 移除原有的升级选项和技能选项
      const oldUpgradeOptions = document.querySelector('.tower-upgrade-options');
      if (oldUpgradeOptions) {
        oldUpgradeOptions.remove();
      }
      
      const oldSkillOptions = document.querySelector('.tower-skill-options');
      if (oldSkillOptions) {
        oldSkillOptions.remove();
      }
      
      // 如果是加农炮，添加发射按钮
      const towerInfoButtons = document.querySelector('.tower-info-buttons');
      let fireButton = document.getElementById('fire-howitzer');
      
      if (tower.type === 'howitzer') {
        // 确保冷却时间属性存在
        if (tower.cooldown === undefined) {
          tower.cooldown = 0;
        }
        
        // 如果按钮不存在，创建新按钮
        if (!fireButton) {
          fireButton = document.createElement('div');
          fireButton.id = 'fire-howitzer';
          fireButton.className = 'tower-info-button fire-button';
          towerInfoButtons.appendChild(fireButton);
        }
        
        // 更新按钮状态
        if (tower.cooldown <= 0) {
          fireButton.textContent = '发射';
          fireButton.style.cursor = 'pointer';
          fireButton.onclick = (event) => {
            startHowitzerTargeting(tower);
            // 阻止事件冒泡，防止触发出售按钮
            event.stopPropagation();
          };
        } else {
          fireButton.textContent = `冷却中: ${Math.ceil(tower.cooldown)}秒`;
          fireButton.style.cursor = 'not-allowed';
          fireButton.onclick = null;
        }
      } else if (fireButton) {
        // 如果不是加农炮，移除发射按钮
        fireButton.remove();
      }
      
      // 添加升级方向选择
      if (tower.level < 8) {
        // 创建升级方向选择容器
        const upgradeOptions = document.createElement('div');
        upgradeOptions.className = 'tower-upgrade-options';
        upgradeOptions.style.display = 'flex';
        upgradeOptions.style.justifyContent = 'space-between';
        upgradeOptions.style.marginTop = '10px';
        
        // 根据炮塔类型获取升级路径描述
        let damagePathName = '攻击强化';
        let speedPathName = '速度强化';
        let damagePathDesc = '+30%';
        let speedPathDesc = '+20%';
        
        switch(tower.type) {
          case 'energy':
            damagePathName = '能量增强';
            speedPathName = '快速充能';
            damagePathDesc = '伤害+40% 射程+0.5';
            speedPathDesc = '攻速+30% 双伤几率+5%';
            break;
          case 'rapid':
            damagePathName = '火力压制';
            speedPathName = '极速射击';
            damagePathDesc = '伤害+30% 穿透+1';
            speedPathDesc = '攻速+40%';
            break;
          case 'ice':
            damagePathName = '冰冻风暴';
            speedPathName = '速冻路径';
            damagePathDesc = '伤害+30% 减速+5%';
            speedPathDesc = '攻速+20% 减速持续+1秒';
            break;
          case 'pierce':
            damagePathName = '穿刺强化';
            speedPathName = '快速穿刺';
            damagePathDesc = '伤害+50% 穿透+2';
            speedPathDesc = '攻速+25% 射程+0.5';
            break;
          case 'laser':
            damagePathName = '激光增强';
            speedPathName = '光速路径';
            damagePathDesc = '伤害提升 激光宽度+0.02';
            speedPathDesc = '射程+1';
            break;
          case 'rocket':
            damagePathName = '高爆火箭';
            speedPathName = '快速发射';
            damagePathDesc = '伤害+40% 爆炸范围+0.05';
            speedPathDesc = '攻速+15% 弹速+2';
            break;
          case 'electro':
            damagePathName = '电磁强化';
            speedPathName = '广域电磁';
            damagePathDesc = '伤害+35% 眩晕+0.2秒';
            speedPathDesc = '攻速+15% 脉冲范围+0.03';
            break;
          case 'titan':
            damagePathName = '泰坦之力';
            speedPathName = '泰坦速射';
            damagePathDesc = '伤害+60% 范围伤害+0.05';
            speedPathDesc = '攻速+10% 射程+0.5';
            break;
          case 'sniper':
            damagePathName = '精准狙击';
            speedPathName = '快速狙击';
            damagePathDesc = '伤害+45% 暴击+5%';
            speedPathDesc = '攻速+15% 射程+2';
            break;
          case 'anti-air':
            damagePathName = '防空强化';
            speedPathName = '快速防空';
            damagePathDesc = '伤害+50% 对空范围+0.1';
            speedPathDesc = '攻速+30%';
            break;
          case 'flame':
            damagePathName = '烈焰强化';
            speedPathName = '快速喷火';
            damagePathDesc = '伤害+30% 灼烧+3';
            speedPathDesc = '攻速+20% 保护范围+0.5';
            break;
          case 'howitzer':
            damagePathName = '高爆炮弹';
            speedPathName = '快速装填';
            damagePathDesc = '伤害+50% 爆炸范围+0.1';
            speedPathDesc = '冷却-10%';
            break;
          case 'toxin':
            damagePathName = '剧毒强化';
            speedPathName = '快速施毒';
            damagePathDesc = '伤害+30% 持续伤害+5';
            speedPathDesc = '攻速+20% 持续+1秒';
            break;
          case 'sentinel':
            damagePathName = '精英猎手';
            speedPathName = '快速锁定';
            damagePathDesc = '伤害+30% 精英加成+10%';
            speedPathDesc = '攻速+20% 射程+1';
            break;
          case 'quantum':
            damagePathName = '量子裂变';
            speedPathName = '量子加速';
            damagePathDesc = '伤害+40% 范围几率+5%';
            speedPathDesc = '攻速+10% BOSS加成+20%';
            break;
          case 'amplifier':
            damagePathName = '增幅强化';
            speedPathName = '广域增幅';
            damagePathDesc = '伤害加成+5%';
            speedPathDesc = '范围+0.5';
            break;
          case 'repair':
            damagePathName = '修复强化';
            speedPathName = '快速修复';
            damagePathDesc = '修复量+3';
            speedPathDesc = '间隔-0.2秒';
            break;
        }
        
        // 创建攻击伤害升级按钮
        const damageUpgrade = document.createElement('div');
        damageUpgrade.className = 'tower-info-button upgrade-button';
        damageUpgrade.style.width = '48%';
        damageUpgrade.innerHTML = `<div style="font-weight: bold; margin-bottom: 2px;">${damagePathName}</div><div style="font-size: 0.8rem; opacity: 0.9;">${damagePathDesc}</div><div style="font-size: 0.7rem; opacity: 0.7; margin-top: 2px;">花费: ${upgradeCostValue}</div>`;
        damageUpgrade.onclick = () => {
          upgradeTower(tower, 'damage');
        };
        
        // 创建攻击速度升级按钮
        const speedUpgrade = document.createElement('div');
        speedUpgrade.className = 'tower-info-button upgrade-button';
        speedUpgrade.style.width = '48%';
        speedUpgrade.innerHTML = `<div style="font-weight: bold; margin-bottom: 2px;">${speedPathName}</div><div style="font-size: 0.8rem; opacity: 0.9;">${speedPathDesc}</div><div style="font-size: 0.7rem; opacity: 0.7; margin-top: 2px;">花费: ${upgradeCostValue}</div>`;
        speedUpgrade.onclick = () => {
          upgradeTower(tower, 'speed');
        };
        
        // 添加到容器
        upgradeOptions.appendChild(damageUpgrade);
        upgradeOptions.appendChild(speedUpgrade);
        
        // 添加到界面
        const towerInfoContent = document.querySelector('.tower-info');
        towerInfoContent.appendChild(upgradeOptions);
      } else if (tower.level === 8 && !tower.hasSkill) {
        // 8级解锁技能
        const skillOptions = document.createElement('div');
        skillOptions.className = 'tower-skill-options';
        skillOptions.style.display = 'flex';
        skillOptions.style.flexDirection = 'column';
        skillOptions.style.gap = '10px';
        skillOptions.style.marginTop = '10px';
        
        // 创建技能选择提示
        const skillTitle = document.createElement('div');
        skillTitle.textContent = '选择一个技能:';
        skillTitle.style.fontWeight = 'bold';
        skillTitle.style.color = '#F59E0B';
        
        // 创建技能1
        const skill1 = document.createElement('div');
        skill1.className = 'tower-info-button upgrade-button';
        skill1.textContent = '核心恢复: 每回合为核心恢复1点生命值';
        skill1.onclick = () => {
          upgradeTowerSkill(tower, 'coreHeal');
        };
        
        // 创建技能2
        const skill2 = document.createElement('div');
        skill2.className = 'tower-info-button upgrade-button';
        skill2.textContent = '攻击强化: 伤害和攻击速度提升10%';
        skill2.onclick = () => {
          upgradeTowerSkill(tower, 'attackBoost');
        };
        
        // 添加到容器
        skillOptions.appendChild(skillTitle);
        skillOptions.appendChild(skill1);
        skillOptions.appendChild(skill2);
        
        // 添加到界面
        const towerInfoContent = document.querySelector('.tower-info');
        towerInfoContent.appendChild(skillOptions);
      }
    }
    
    // 关闭炮塔信息界面
    function closeTowerInfo() {
      towerInfoScreen.classList.add('hidden');
      gameData.selectedTower = null;
      
      // 清除存储的最后炮塔信息
      gameData.lastTowerInfo = null;
      
      // 移除加农炮发射按钮
      const fireButton = document.getElementById('fire-howitzer');
      if (fireButton) {
        fireButton.remove();
      }
      
      // 退出加农炮目标选择模式
      gameData.isHowitzerTargeting = false;
      gameData.selectedHowitzer = null;
      gameData.selectedTargetCell = null;
    }
    
    // 开始加农炮目标选择
    function startHowitzerTargeting(tower) {
      // 检查是否可以发射
      if (tower.cooldown > 0) return;
      
      // 关闭炮塔信息界面
      closeTowerInfo();
      
      // 进入目标选择模式
      gameData.isHowitzerTargeting = true;
      gameData.selectedHowitzer = tower;
      gameData.selectedTargetCell = null;
      
      // 显示目标选择提示
      showFloatingText(tower.position.x, tower.position.y - 2, '请选择目标格子', '#F59E0B', 3);
    }
    
    // 升级炮塔
    function upgradeTower(tower, direction) {
      if (!tower) return;
      
      // 检查是否已达到等级上限
      if (tower.level >= 8) {
        alert('已达到最高等级！');
        return;
      }
      
      const upgradeCostValue = Math.floor(tower.price * tower.level / 4);
      
      // 检查金钱是否足够
      if (gameData.money < upgradeCostValue) {
        alert('金钱不足！');
        return;
      }
      
      // 扣除金钱
      gameData.money -= upgradeCostValue;
      updateGameInfo();
      
      // 升级炮塔
      tower.level++;
      
      // 根据炮塔类型和选择的方向升级
      let upgradeEffect = '';
      
      switch(tower.type) {
        case 'energy':
          if (direction === 'damage') {
            // 能量增强路径：增加伤害和射程
            tower.damage = Math.floor(tower.damage * 1.4);
            tower.range += 0.5;
            upgradeEffect = '能量增强: 伤害+40% 射程+0.5';
          } else if (direction === 'speed') {
            // 快速充能路径：增加攻击速度和几率造成双倍伤害
            tower.fireRate = Math.max(0.1, tower.fireRate * 0.7);
            if (!tower.doubleDamageChance) tower.doubleDamageChance = 0;
            tower.doubleDamageChance += 0.05;
            upgradeEffect = '快速充能: 攻速+30% 双伤几率+5%';
          }
          break;
          
        case 'rapid':
          if (direction === 'damage') {
            // 火力压制路径：增加伤害和穿透能力
            tower.damage = Math.floor(tower.damage * 1.3);
            if (!tower.pierceCount) tower.pierceCount = 0;
            tower.pierceCount += 1;
            upgradeEffect = '火力压制: 伤害+30% 穿透+1';
          } else if (direction === 'speed') {
            // 极速射击路径：大幅提升攻击速度
            tower.fireRate = Math.max(0.01, tower.fireRate * 0.6);
            upgradeEffect = '极速射击: 攻速+40%';
          }
          break;
          
        case 'ice':
          if (direction === 'damage') {
            // 冰冻风暴路径：增加伤害和减速效果
            tower.damage = Math.floor(tower.damage * 1.3);
            if (!tower.slowAmount) tower.slowAmount = 0.5;
            tower.slowAmount = Math.min(0.8, tower.slowAmount + 0.05);
            upgradeEffect = '冰冻风暴: 伤害+30% 减速+5%';
          } else if (direction === 'speed') {
            // 速冻路径：增加攻击速度和减速持续时间
            tower.fireRate = Math.max(0.1, tower.fireRate * 0.8);
            if (!tower.slowDuration) tower.slowDuration = 5;
            tower.slowDuration += 1;
            upgradeEffect = '速冻路径: 攻速+20% 减速持续+1秒';
          }
          break;
          
        case 'pierce':
          if (direction === 'damage') {
            // 穿刺强化路径：增加伤害和穿透数量
            tower.damage = Math.floor(tower.damage * 1.5);
            if (!tower.pierceCount) tower.pierceCount = 3;
            tower.pierceCount += 2;
            upgradeEffect = '穿刺强化: 伤害+50% 穿透+2';
          } else if (direction === 'speed') {
            // 快速穿刺路径：增加攻击速度和范围
            tower.fireRate = Math.max(0.1, tower.fireRate * 0.75);
            tower.range += 0.5;
            upgradeEffect = '快速穿刺: 攻速+25% 射程+0.5';
          }
          break;
          
        case 'laser':
          if (direction === 'damage') {
            // 激光增强路径：增加基础伤害
            tower.damage = Math.floor(tower.damage + 0.5 * tower.level);
            if (!tower.laserWidth) tower.laserWidth = 0.1;
            tower.laserWidth = Math.min(0.3, tower.laserWidth + 0.02);
            upgradeEffect = '激光增强: 伤害提升 激光宽度+0.02';
          } else if (direction === 'speed') {
            // 光速路径：略微提升攻击速度但增加射程
            tower.fireRate = Math.max(0.01, tower.fireRate * 0.95);
            tower.range += 1;
            upgradeEffect = '光速路径: 射程+1';
          }
          break;
          
        case 'rocket':
          if (direction === 'damage') {
            // 高爆火箭路径：增加爆炸伤害和范围
            tower.damage = Math.floor(tower.damage * 1.4);
            if (!tower.explosionRadius) tower.explosionRadius = 0.3;
            tower.explosionRadius = Math.min(0.8, tower.explosionRadius + 0.05);
            upgradeEffect = '高爆火箭: 伤害+40% 爆炸范围+0.05';
          } else if (direction === 'speed') {
            // 快速发射路径：增加攻击速度和火箭飞行速度
            tower.fireRate = Math.max(0.1, tower.fireRate * 0.85);
            if (!tower.projectileSpeed) tower.projectileSpeed = 10;
            tower.projectileSpeed += 2;
            upgradeEffect = '快速发射: 攻速+15% 弹速+2';
          }
          break;
          
        case 'electro':
          if (direction === 'damage') {
            // 电磁强化路径：增加伤害和眩晕时间
            tower.damage = Math.floor(tower.damage * 1.35);
            if (!tower.stunDuration) tower.stunDuration = 1;
            tower.stunDuration = Math.min(3, tower.stunDuration + 0.2);
            upgradeEffect = '电磁强化: 伤害+35% 眩晕+0.2秒';
          } else if (direction === 'speed') {
            // 广域电磁路径：增加攻击速度和电磁脉冲范围
            tower.fireRate = Math.max(0.1, tower.fireRate * 0.85);
            if (!tower.explosionRadius) tower.explosionRadius = 0.2;
            tower.explosionRadius = Math.min(0.5, tower.explosionRadius + 0.03);
            upgradeEffect = '广域电磁: 攻速+15% 脉冲范围+0.03';
          }
          break;
          
        case 'titan':
          if (direction === 'damage') {
            // 泰坦之力路径：大幅增加伤害
            tower.damage = Math.floor(tower.damage * 1.6);
            if (!tower.aoeRadius) tower.aoeRadius = 0;
            tower.aoeRadius = Math.min(0.5, tower.aoeRadius + 0.05);
            upgradeEffect = '泰坦之力: 伤害+60% 范围伤害+0.05';
          } else if (direction === 'speed') {
            // 泰坦速射路径：增加攻击速度和射程
            tower.fireRate = Math.max(0.1, tower.fireRate * 0.9);
            tower.range += 0.5;
            upgradeEffect = '泰坦速射: 攻速+10% 射程+0.5';
          }
          break;
          
        case 'sniper':
          if (direction === 'damage') {
            // 精准狙击路径：增加伤害和暴击几率
            tower.damage = Math.floor(tower.damage * 1.45);
            if (!tower.critChance) tower.critChance = 0.25;
            tower.critChance = Math.min(0.7, tower.critChance + 0.05);
            upgradeEffect = '精准狙击: 伤害+45% 暴击+5%';
          } else if (direction === 'speed') {
            // 快速狙击路径：增加攻击速度和射程
            tower.fireRate = Math.max(0.1, tower.fireRate * 0.85);
            tower.range += 2;
            upgradeEffect = '快速狙击: 攻速+15% 射程+2';
          }
          break;
          
        case 'anti-air':
          if (direction === 'damage') {
            // 防空强化路径：增加对空伤害和范围伤害
            tower.damage = Math.floor(tower.damage * 1.5);
            if (!tower.airAoeRadius) tower.airAoeRadius = 0;
            tower.airAoeRadius = Math.min(1, tower.airAoeRadius + 0.1);
            upgradeEffect = '防空强化: 伤害+50% 对空范围+0.1';
          } else if (direction === 'speed') {
            // 快速防空路径：大幅增加攻击速度
            tower.fireRate = Math.max(0.05, tower.fireRate * 0.7);
            upgradeEffect = '快速防空: 攻速+30%';
          }
          break;
          
        case 'flame':
          if (direction === 'damage') {
            // 烈焰强化路径：增加伤害和灼烧效果
            tower.damage = Math.floor(tower.damage * 1.3);
            if (!tower.burnDamage) tower.burnDamage = 5;
            tower.burnDamage += 3;
            upgradeEffect = '烈焰强化: 伤害+30% 灼烧+3';
          } else if (direction === 'speed') {
            // 快速喷火路径：增加攻击速度和保护范围
            tower.fireRate = Math.max(0.1, tower.fireRate * 0.8);
            if (!tower.protectionRange) tower.protectionRange = 1;
            tower.protectionRange = Math.min(3, tower.protectionRange + 0.5);
            upgradeEffect = '快速喷火: 攻速+20% 保护范围+0.5';
          }
          break;
          
        case 'howitzer':
          if (direction === 'damage') {
            // 高爆炮弹路径：增加伤害和爆炸范围
            tower.damage = Math.floor(tower.damage * 1.5);
            if (!tower.blastRadius) tower.blastRadius = 1.5;
            tower.blastRadius = Math.min(3, tower.blastRadius + 0.1);
            upgradeEffect = '高爆炮弹: 伤害+50% 爆炸范围+0.1';
          } else if (direction === 'speed') {
            // 快速装填路径：减少冷却时间
            tower.fireRate = Math.max(10, tower.fireRate * 0.9);
            upgradeEffect = '快速装填: 冷却-10%';
          }
          break;
          
        case 'toxin':
          if (direction === 'damage') {
            // 剧毒强化路径：增加基础伤害和持续伤害
            tower.damage = Math.floor(tower.damage * 1.3);
            if (!tower.poisonDamage) tower.poisonDamage = 20;
            tower.poisonDamage += 5;
            upgradeEffect = '剧毒强化: 伤害+30% 持续伤害+5';
          } else if (direction === 'speed') {
            // 快速施毒路径：增加攻击速度和持续时间
            tower.fireRate = Math.max(0.1, tower.fireRate * 0.8);
            if (!tower.poisonDuration) tower.poisonDuration = 5;
            tower.poisonDuration += 1;
            upgradeEffect = '快速施毒: 攻速+20% 持续+1秒';
          }
          break;
          
        case 'sentinel':
          if (direction === 'damage') {
            // 精英猎手路径：增加对精英和BOSS的伤害加成
            tower.damage = Math.floor(tower.damage * 1.3);
            if (!tower.eliteBonus) tower.eliteBonus = 0.5;
            tower.eliteBonus = Math.min(2, tower.eliteBonus + 0.1);
            upgradeEffect = '精英猎手: 伤害+30% 精英加成+10%';
          } else if (direction === 'speed') {
            // 快速锁定路径：增加攻击速度和优先目标范围
            tower.fireRate = Math.max(0.1, tower.fireRate * 0.8);
            tower.range += 1;
            upgradeEffect = '快速锁定: 攻速+20% 射程+1';
          }
          break;
          
        case 'quantum':
          if (direction === 'damage') {
            // 量子裂变路径：增加伤害和范围伤害几率
            tower.damage = Math.floor(tower.damage * 1.4);
            if (!tower.quantumAoeChance) tower.quantumAoeChance = 0.2;
            tower.quantumAoeChance = Math.min(0.8, tower.quantumAoeChance + 0.05);
            upgradeEffect = '量子裂变: 伤害+40% 范围几率+5%';
          } else if (direction === 'speed') {
            // 量子加速路径：增加攻击速度和对BOSS的伤害加成
            tower.fireRate = Math.max(0.1, tower.fireRate * 0.9);
            if (!tower.bossBonus) tower.bossBonus = 1;
            tower.bossBonus += 0.2;
            upgradeEffect = '量子加速: 攻速+10% BOSS加成+20%';
          }
          break;
          
        case 'amplifier':
          if (direction === 'damage') {
            // 增幅强化路径：增加伤害加成效果
            if (!tower.damageBoost) tower.damageBoost = 0.25;
            tower.damageBoost = Math.min(0.8, tower.damageBoost + 0.05);
            upgradeEffect = '增幅强化: 伤害加成+5%';
          } else if (direction === 'speed') {
            // 广域增幅路径：增加增幅范围
            if (!tower.boostRange) tower.boostRange = 1;
            tower.boostRange = Math.min(3, tower.boostRange + 0.5);
            upgradeEffect = '广域增幅: 范围+0.5';
          }
          break;
          
        case 'repair':
          if (direction === 'damage') {
            // 修复强化路径：增加修复量
            if (!tower.repairAmount) tower.repairAmount = 10;
            tower.repairAmount += 3;
            upgradeEffect = '修复强化: 修复量+3';
          } else if (direction === 'speed') {
            // 快速修复路径：减少修复间隔
            if (!tower.repairInterval) tower.repairInterval = 3;
            tower.repairInterval = Math.max(1, tower.repairInterval - 0.2);
            upgradeEffect = '快速修复: 间隔-0.2秒';
          }
          break;
          
        default:
          // 默认升级路径
          if (direction === 'damage') {
            tower.damage = Math.floor(tower.damage * 1.3);
            upgradeEffect = '伤害+30%';
          } else if (direction === 'speed') {
            tower.fireRate = Math.max(0.1, tower.fireRate * 0.8);
            upgradeEffect = '攻速+20%';
          }
      }
      
      // 增加最大生命值
      if (tower.maxHealth) {
        tower.maxHealth = Math.floor(tower.maxHealth * 1.2);
        tower.health = tower.maxHealth; // 升级时恢复满血
      }
      
      // 显示升级提示
      if (upgradeEffect) {
        showFloatingText(tower.position.x, tower.position.y - 1, upgradeEffect, '#10B981');
      }
      
      // 更新炮塔信息
      showTowerInfo(tower);
    }
    
    // 升级炮塔技能
    function upgradeTowerSkill(tower, skill) {
      if (!tower) return;
      
      // 设置技能
      tower.hasSkill = true;
      tower.skill = skill;
      
      // 根据选择的技能效果
      if (skill === 'coreHeal') {
        // 核心恢复技能
        tower.coreHealAmount = 1;
        tower.special += ' | 核心恢复: 每回合为核心恢复1点生命值';
        
        // 显示技能提示
        showFloatingText(tower.position.x, tower.position.y - 2, '解锁技能: 核心恢复', '#F59E0B');
      } else if (skill === 'attackBoost') {
        // 攻击强化技能
        tower.damage = Math.floor(tower.damage * 1.1);
        tower.fireRate = Math.max(0.1, tower.fireRate * 0.9);
        tower.special += ' | 攻击强化: 伤害和攻击速度提升10%';
        
        // 显示技能提示
        showFloatingText(tower.position.x, tower.position.y - 2, '解锁技能: 攻击强化', '#F59E0B');
      }
      
      // 更新炮塔信息
      showTowerInfo(tower);
    }
    
    // 出售炮塔
    function sellTower() {
      if (!gameData.selectedTower) return;
      
      const tower = gameData.selectedTower;
      const sellAmountValue = Math.floor(tower.price * 0.5);
      
      // 添加金钱
      gameData.money += sellAmountValue;
      updateGameInfo();
      
      // 从阻挡单元格中移除
      gameData.blockedCells.delete(`${tower.position.x},${tower.position.y}`);
      
      // 移除炮塔
      const index = gameData.towers.indexOf(tower);
      if (index !== -1) {
        gameData.towers.splice(index, 1);
      }
      
      // 隐藏炮塔信息界面
      towerInfoScreen.classList.add('hidden');
      gameData.selectedTower = null;
    }
    
    // 更新游戏信息
    function updateGameInfo() {
      try {
        // 安全检查DOM元素
        if (difficultyDisplay) {
          difficultyDisplay.textContent = `难度: ${getDifficultyName(gameData.difficulty)}`;
        }
        if (waveDisplay) {
          waveDisplay.textContent = `波数: ${gameData.currentWave || 1}/${gameData.waveSettings ? gameData.waveSettings.maxBaseWave || 100 : 100}`;
        }
        if (moneyDisplay) {
          moneyDisplay.textContent = `金钱: ${gameData.money || 0}`;
        }
        if (coreHealthDisplay) {
          coreHealthDisplay.textContent = `核心血量: ${gameData.coreHealth || 100}`;
        }
        
        // 更新量子炮解锁进度
        if (quantumTowerProgress) {
          if (gameData.quantumTowerUnlocked) {
            quantumTowerProgress.textContent = '量子炮: 已解锁';
            quantumTowerProgress.style.color = '#8B5CF6';
            quantumTowerProgress.style.fontWeight = 'bold';
          } else {
            quantumTowerProgress.textContent = `量子炮解锁: ${gameData.miniBossesKilled || 0}/5`;
            quantumTowerProgress.style.color = '#F59E0B';
          }
        }
      } catch (error) {
        console.error('更新游戏信息时出错:', error);
      }
    }
    
    // 获取难度名称
    function getDifficultyName(difficulty) {
      switch (difficulty) {
        case 'easy': return '简单';
        case 'normal': return '普通';
        case 'hard': return '困难';
        case 'hell': return '地狱';
        default: return '未知';
      }
    }
    
    // 更新科技点显示
    function updateTechPointsDisplay() {
      // 检查科技点显示元素是否存在
      const techPointsDisplay = document.getElementById('tech-points-display');
      if (techPointsDisplay) {
        techPointsDisplay.textContent = `科技点: ${gameData.techSystem.techPoints}`;
      }
    }
    
    // 对象池管理函数
    function getFromPool(poolType) {
      const pool = gameData.objectPools[poolType];
      if (pool && pool.length > 0) {
        const obj = pool.pop();
        // 重置对象状态
        for (let key in obj) {
          if (typeof obj[key] === 'number') obj[key] = 0;
          else if (typeof obj[key] === 'string') obj[key] = '';
          else if (typeof obj[key] === 'boolean') obj[key] = false;
          else if (Array.isArray(obj[key])) obj[key].length = 0;
          else if (typeof obj[key] === 'object' && obj[key] !== null) {
            for (let subKey in obj[key]) {
              obj[key][subKey] = 0;
            }
          }
        }
        return obj;
      }
      return null;
    }
    
    function returnToPool(poolType, obj) {
      const pool = gameData.objectPools[poolType];
      if (pool && obj) {
        // 限制对象池大小，防止内存无限增长
        const maxPoolSize = {
          projectiles: 100,
          explosions: 50,
          effects: 30,
          floatingTexts: 20
        };
        
        if (pool.length < maxPoolSize[poolType]) {
          pool.push(obj);
        }
      }
    }
    
    // 显示浮动文本（使用对象池）
    function showFloatingText(gridX, gridY, text, color) {
      const x = gameData.gridOffset.x + gridX * gameData.cellSize + gameData.cellSize / 2;
      const y = gameData.gridOffset.y + gridY * gameData.cellSize + gameData.cellSize / 2;
      
      let floatingText = getFromPool('floatingTexts');
      
      if (!floatingText) {
        floatingText = {
          x: 0,
          y: 0,
          text: '',
          color: '',
          time: 0
        };
      }
      
      floatingText.x = x;
      floatingText.y = y;
      floatingText.text = text;
      floatingText.color = color;
      floatingText.time = 0;
      
      gameData.floatingTexts.push(floatingText);
    }
    
    // 创建爆炸效果
    function createExplosion(gridX, gridY, radius) {
      const x = gameData.gridOffset.x + gridX * gameData.cellSize + gameData.cellSize / 2;
      const y = gameData.gridOffset.y + gridY * gameData.cellSize + gameData.cellSize / 2;
      
      const explosion = {
        x,
        y,
        radius: radius * gameData.cellSize,
        time: 0
      };
      
      gameData.explosions.push(explosion);
    }
    
    // 创建小BOSS死亡效果
    function createMiniBossDeathEffect(gridX, gridY) {
      const x = gameData.gridOffset.x + gridX * gameData.cellSize + gameData.cellSize / 2;
      const y = gameData.gridOffset.y + gridY * gameData.cellSize + gameData.cellSize / 2;
      
      // 创建多个爆炸效果
      for (let i = 0; i < 5; i++) {
        const explosion = {
          x: x + (Math.random() - 0.5) * 100,
          y: y + (Math.random() - 0.5) * 100,
          radius: 50 + Math.random() * 50,
          time: 0,
          isMiniBossDeath: true
        };
        
        gameData.explosions.push(explosion);
      }
      
      // 创建闪光效果
      const flash = {
        type: 'flash',
        x,
        y,
        size: 200,
        time: 0
      };
      
      gameData.effects.push(flash);
    }
    
    // 创建小BOSS击中效果
    function createMiniBossHitEffect(gridX, gridY) {
      const x = gameData.gridOffset.x + gridX * gameData.cellSize + gameData.cellSize / 2;
      const y = gameData.gridOffset.y + gridY * gameData.cellSize + gameData.cellSize / 2;
      
      const effect = {
        type: 'miniBossHit',
        x,
        y,
        size: gameData.cellSize * 1.5,
        time: 0
      };
      
      gameData.effects.push(effect);
    }
    
    // 创建速度提升效果
    function createSpeedBoostEffect(gridX, gridY) {
      const x = gameData.gridOffset.x + gridX * gameData.cellSize + gameData.cellSize / 2;
      const y = gameData.gridOffset.y + gridY * gameData.cellSize + gameData.cellSize / 2;
      
      const effect = {
        type: 'speedBoost',
        x,
        y,
        size: gameData.cellSize * 1.2,
        time: 0
      };
      
      gameData.effects.push(effect);
    }
    
    // 创建激光效果
    function createLaser(startX, startY, endX, endY) {
      const startGridX = Math.floor((startX - gameData.gridOffset.x) / gameData.cellSize);
      const startGridY = Math.floor((startY - gameData.gridOffset.y) / gameData.cellSize);
      const endGridX = Math.floor((endX - gameData.gridOffset.x) / gameData.cellSize);
      const endGridY = Math.floor((endY - gameData.gridOffset.y) / gameData.cellSize);
      
      const dx = endX - startX;
      const dy = endY - startY;
      const length = Math.sqrt(dx * dx + dy * dy);
      const angle = Math.atan2(dy, dx);
      
      const laser = {
        x: startX,
        y: startY,
        length,
        angle,
        time: 0,
        startGridX,
        startGridY,
        endGridX,
        endGridY
      };
      
      gameData.effects.push(laser);
    }
    
    // 创建冻结效果
    function createFreezeEffect(gridX, gridY) {
      const x = gameData.gridOffset.x + gridX * gameData.cellSize + gameData.cellSize / 2;
      const y = gameData.gridOffset.y + gridY * gameData.cellSize + gameData.cellSize / 2;
      
      const effect = {
        type: 'freeze',
        x,
        y,
        size: gameData.cellSize,
        time: 0
      };
      
      gameData.effects.push(effect);
    }
    
    // 创建眩晕效果
    function createStunEffect(gridX, gridY) {
      const x = gameData.gridOffset.x + gridX * gameData.cellSize + gameData.cellSize / 2;
      const y = gameData.gridOffset.y + gridY * gameData.cellSize + gameData.cellSize / 2;
      
      const effect = {
        type: 'stun',
        x,
        y,
        size: gameData.cellSize,
        time: 0
      };
      
      gameData.effects.push(effect);
    }
    
    // 游戏循环
    function gameLoop(timestamp) {
      // 计算时间差
      if (!gameData.lastTime) gameData.lastTime = timestamp;
      gameData.deltaTime = (timestamp - gameData.lastTime) / 1000; // 转换为秒
      gameData.lastTime = timestamp;
      
      // 清除画布
      ctx.clearRect(0, 0, gameCanvas.width, gameCanvas.height);
      
      // 绘制背景
      ctx.fillStyle = '#0F172A';
      ctx.fillRect(0, 0, gameCanvas.width, gameCanvas.height);
      
      // 根据游戏状态更新
      switch (gameData.gameState) {
        case 'game':
          // 添加错误处理
          try {
            updateGame();
            renderGame();
          } catch (error) {
            console.error('游戏更新或渲染出错:', error);
            console.error('错误堆栈:', error.stack);
            console.error('游戏状态:', gameData.gameState);
            console.error('当前波次:', gameData.currentWave);
            console.error('炮塔数量:', gameData.towers ? gameData.towers.length : '未知');
            console.error('怪物数量:', gameData.monsters ? gameData.monsters.length : '未知');
            
            // 显示错误信息
            ctx.fillStyle = 'white';
            ctx.font = '24px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('游戏出错！请刷新页面重试', gameCanvas.width / 2, gameCanvas.height / 2);
            ctx.font = '16px Arial';
            ctx.fillText('错误信息: ' + error.message, gameCanvas.width / 2, gameCanvas.height / 2 + 40);
            
            // 显示错误详情
            ctx.font = '14px Arial';
            ctx.fillText('错误类型: ' + error.name, gameCanvas.width / 2, gameCanvas.height / 2 + 70);
            ctx.fillText('游戏状态: ' + gameData.gameState, gameCanvas.width / 2, gameCanvas.height / 2 + 100);
            ctx.fillText('当前波次: ' + (gameData.currentWave || '未知'), gameCanvas.width / 2, gameCanvas.height / 2 + 130);
            
            // 显示手动刷新提示
            ctx.font = '16px Arial';
            ctx.fillText('点击任意位置继续游戏或刷新页面', gameCanvas.width / 2, gameCanvas.height / 2 + 170);
            
            // 添加点击继续游戏的事件监听
            const handleClickToContinue = () => {
              // 移除事件监听，避免多次触发
              gameCanvas.removeEventListener('click', handleClickToContinue);
              
              // 尝试恢复游戏
              gameData.isGameOver = false;
              gameData.isVictory = false;
              gameData.gamePaused = false;
              
              // 重新开始游戏循环
              gameLoop(timestamp);
            };
            
            // 添加点击事件监听
            gameCanvas.addEventListener('click', handleClickToContinue, { once: true });
          }
          break;
          
        case 'tech-tree':
          // 科技树状态下，只渲染游戏但不更新
          try {
            renderGame();
          } catch (error) {
            console.error('科技树状态下渲染出错:', error);
            console.error('错误堆栈:', error.stack);
          }
          break;
      }
      
      // 继续游戏循环
      requestAnimationFrame(gameLoop);
    }
    
    // 性能优化：对象池系统
    const objectPool = {
      projectiles: [],
      effects: [],
      floatingTexts: [],
      
      // 获取对象
      getObject(type) {
        const pool = this[type];
        if (pool && pool.length > 0) {
          const obj = pool.pop();
          obj.active = true;
          return obj;
        }
        return null;
      },
      
      // 回收对象
      returnObject(type, obj) {
        const pool = this[type];
        if (pool && obj) {
          obj.active = false;
          // 重置对象属性
          for (let key in obj) {
            if (typeof obj[key] === 'number') obj[key] = 0;
            else if (typeof obj[key] === 'string') obj[key] = '';
            else if (typeof obj[key] === 'boolean') obj[key] = false;
            else if (Array.isArray(obj[key])) obj[key] = [];
            else if (typeof obj[key] === 'object') obj[key] = null;
          }
          pool.push(obj);
        }
      },
      
      // 清理对象池
      clearPool(type) {
        if (this[type]) {
          this[type] = [];
        }
      },
      
      // 获取池大小
      getPoolSize(type) {
        return this[type] ? this[type].length : 0;
      }
    };
    
    // 性能监控和优化系统
    const performanceManager = {
      fps: 0,
      frameCount: 0,
      lastFpsUpdate: 0,
      targetFps: 60,
      frameInterval: 1000 / 60,
      lastFrameTime: 0,
      
      // 初始化性能监控
      init() {
        this.lastFpsUpdate = Date.now();
        this.lastFrameTime = Date.now();
      },
      
      // 更新性能监控
      update() {
        const currentTime = Date.now();
        
        // 计算FPS
        this.frameCount++;
        if (currentTime - this.lastFpsUpdate >= 1000) {
          this.fps = Math.round((this.frameCount * 1000) / (currentTime - this.lastFpsUpdate));
          this.frameCount = 0;
          this.lastFpsUpdate = currentTime;
          
          // 动态调整游戏质量
          this.adjustGameQuality();
        }
        
        // 帧率控制
        return currentTime - this.lastFrameTime >= this.frameInterval;
      },
      
      // 调整游戏质量
      adjustGameQuality() {
        if (this.fps < 30) {
          // 低帧率时降低效果质量
          gameData.effectQuality = Math.max(0.5, gameData.effectQuality - 0.1);
          gameData.maxProjectiles = Math.max(50, gameData.maxProjectiles - 10);
          gameData.maxEffects = Math.max(20, gameData.maxEffects - 5);
        } else if (this.fps > 50 && gameData.effectQuality < 1) {
          // 高帧率时恢复效果质量
          gameData.effectQuality = Math.min(1, gameData.effectQuality + 0.05);
          gameData.maxProjectiles = Math.min(200, gameData.maxProjectiles + 5);
          gameData.maxEffects = Math.min(50, gameData.maxEffects + 2);
        }
      },
      
      // 获取性能统计
      getStats() {
        return {
          fps: this.fps,
          objectCounts: {
            towers: gameData.towers ? gameData.towers.length : 0,
            monsters: gameData.monsters ? gameData.monsters.length : 0,
            projectiles: gameData.projectiles ? gameData.projectiles.length : 0,
            effects: gameData.effects ? gameData.effects.length : 0,
            floatingTexts: gameData.floatingTexts ? gameData.floatingTexts.length : 0
          },
          poolSizes: {
            projectiles: objectPool.getPoolSize('projectiles'),
            effects: objectPool.getPoolSize('effects'),
            floatingTexts: objectPool.getPoolSize('floatingTexts')
          }
        };
      }
    };
    
    // 增强的错误处理和防御性检查函数
    function validateGameObject(obj, objectType = 'unknown') {
      if (!obj) {
        console.warn(`发现空的${objectType}对象`);
        return false;
      }
      
      if (typeof obj.position === 'undefined' || obj.position === null) {
        console.warn(`${objectType}对象缺少position属性:`, obj);
        return false;
      }
      
      if (typeof obj.position.x !== 'number' || typeof obj.position.y !== 'number') {
        console.warn(`${objectType}对象的position属性无效:`, obj.position);
        return false;
      }
      
      return true;
    }
    
    // 安全获取对象位置的函数
    function getSafePosition(obj, defaultX = 0, defaultY = 0) {
      if (!obj || !obj.position) {
        return { x: defaultX, y: defaultY };
      }
      
      return {
        x: typeof obj.position.x === 'number' ? obj.position.x : defaultX,
        y: typeof obj.position.y === 'number' ? obj.position.y : defaultY
      };
    }
    
    // 更新游戏
    // 任务系统核心函数
    function initializeMissionSystem() {
      // 重置任务进度
      gameData.missionSystem.missionProgress = {
        wavesDefended: 0,
        towersBuilt: {},
        sniperKills: 0,
        techLevel: 0,
        lowHealthWaves: 0,
        lowHealthStartTime: null
      };
      
      // 初始化任务状态
      gameData.missionSystem.availableMissions.forEach(mission => {
        mission.completed = false;
      });
      
      console.log('任务系统初始化完成');
    }
    
    function updateMissionProgress(type, data = {}) {
      const progress = gameData.missionSystem.missionProgress;
      
      switch(type) {
        case 'wave_completed':
          progress.wavesDefended++;
          checkLowHealthMission();
          break;
          
        case 'tower_built':
          if (data.towerType) {
            progress.towersBuilt[data.towerType] = (progress.towersBuilt[data.towerType] || 0) + 1;
          }
          break;
          
        case 'monster_killed':
          if (data.killerType === 'sniper') {
            progress.sniperKills++;
          }
          break;
          
        case 'tech_updated':
          progress.techLevel = Math.max(
            gameData.techSystem.attackTechLevel,
            gameData.techSystem.defenseTechLevel,
            gameData.techSystem.economyTechLevel
          );
          break;
          
        case 'core_health_changed':
          checkLowHealthMission();
          break;
      }
      
      // 检查任务完成情况
      checkMissionCompletion();
    }
    
    function checkLowHealthMission() {
      const progress = gameData.missionSystem.missionProgress;
      const lowHealthThreshold = gameData.maxCoreHealth * 0.2;
      
      if (gameData.coreHealth <= lowHealthThreshold) {
        if (!progress.lowHealthStartTime) {
          progress.lowHealthStartTime = Date.now();
        }
      } else {
        progress.lowHealthStartTime = null;
      }
    }
    
    function checkMissionCompletion() {
      const progress = gameData.missionSystem.missionProgress;
      
      gameData.missionSystem.availableMissions.forEach(mission => {
        if (mission.completed) return;
        
        let isCompleted = false;
        
        switch(mission.id) {
          case 'mission_1': // 初入战场
            isCompleted = progress.wavesDefended >= 10;
            break;
            
          case 'mission_2': // 炮塔大师
            const uniqueTowers = Object.keys(progress.towersBuilt).length;
            isCompleted = uniqueTowers >= 5;
            break;
            
          case 'mission_3': // 精准打击
            isCompleted = progress.sniperKills >= 50;
            break;
            
          case 'mission_4': // 科技先驱
            isCompleted = progress.techLevel >= 5;
            break;
            
          case 'mission_5': // 生存专家
            if (progress.lowHealthStartTime) {
              const lowHealthDuration = (Date.now() - progress.lowHealthStartTime) / 1000;
              const requiredWaves = 3;
              const waveDuration = gameData.waveDelay + (gameData.currentWave * 1000); // 估算每波持续时间
              isCompleted = lowHealthDuration >= (requiredWaves * waveDuration);
            }
            break;
        }
        
        if (isCompleted) {
          completeMission(mission);
        }
      });
    }
    
    function completeMission(mission) {
      mission.completed = true;
      gameData.missionSystem.completedMissions.push(mission.id);
      
      // 发放奖励
      if (mission.reward.money) {
        gameData.money += mission.reward.money;
        showFloatingText('任务奖励: +' + mission.reward.money + ' 金钱', 
                        canvas.width / 2, 50, '#10B981', 2);
      }
      
      if (mission.reward.techPoints) {
        gameData.techSystem.techPoints += mission.reward.techPoints;
        showFloatingText('任务奖励: +' + mission.reward.techPoints + ' 科技点', 
                        canvas.width / 2, 80, '#3B82F6', 2);
      }
      
      // 显示任务完成通知
      showMissionCompleteNotification(mission);
      
      console.log('任务完成:', mission.name, '奖励:', mission.reward);
      
      // 更新任务界面
      updateMissionScreen();
    }
    
    function showMissionCompleteNotification(mission) {
      const notification = document.createElement('div');
      notification.className = 'mission-complete-notification';
      notification.innerHTML = `
        <div class="mission-notification-content">
          <div class="mission-notification-icon">🎯</div>
          <div class="mission-notification-text">
            <div class="mission-notification-title">任务完成!</div>
            <div class="mission-notification-name">${mission.name}</div>
            <div class="mission-notification-reward">
              ${mission.reward.money ? '💰 +' + mission.reward.money : ''}
              ${mission.reward.techPoints ? '🔬 +' + mission.reward.techPoints : ''}
            </div>
          </div>
        </div>
      `;
      
      document.body.appendChild(notification);
      
      // 添加动画类
      setTimeout(() => {
        notification.classList.add('show');
      }, 100);
      
      // 3秒后移除
      setTimeout(() => {
        notification.classList.remove('show');
        setTimeout(() => {
          document.body.removeChild(notification);
        }, 500);
      }, 3000);
    }
    
    function updateMissionScreen() {
      const missionList = document.getElementById('mission-list');
      if (!missionList) return;
      
      missionList.innerHTML = '';
      
      gameData.missionSystem.availableMissions.forEach(mission => {
        const missionItem = document.createElement('div');
        missionItem.className = `mission-item ${mission.completed ? 'completed' : ''}`;
        
        let progressText = '';
        const progress = gameData.missionSystem.missionProgress;
        
        switch(mission.id) {
          case 'mission_1':
            progressText = `${progress.wavesDefended}/10 波`;
            break;
          case 'mission_2':
            const uniqueTowers = Object.keys(progress.towersBuilt).length;
            progressText = `${uniqueTowers}/5 种炮塔`;
            break;
          case 'mission_3':
            progressText = `${progress.sniperKills}/50 击杀`;
            break;
          case 'mission_4':
            progressText = `${progress.techLevel}/5 级`;
            break;
          case 'mission_5':
            progressText = progress.lowHealthStartTime ? '进行中...' : '未开始';
            break;
        }
        
        missionItem.innerHTML = `
          <div class="mission-item-header">
            <h3>${mission.name}</h3>
            <span class="mission-status">${mission.completed ? '✓ 已完成' : '⏳ 进行中'}</span>
          </div>
          <p class="mission-description">${mission.description}</p>
          <div class="mission-progress">进度: ${progressText}</div>
          <div class="mission-reward">
            奖励: 
            ${mission.reward.money ? '💰 ' + mission.reward.money : ''}
            ${mission.reward.techPoints ? '🔬 ' + mission.reward.techPoints : ''}
          </div>
        `;
        
        missionList.appendChild(missionItem);
      });
    }
    
    // 成就系统核心函数
    function initializeAchievementSystem() {
      // 初始化成就进度跟踪
      gameData.achievementSystem.achievementProgress = {
        totalWavesDefended: 0,
        towersUnlocked: new Set(),
        totalMoney: 0,
        maxTechLevel: 0,
        perfectDefense: true
      };
      
      // 重置成就状态
      gameData.achievementSystem.achievements.forEach(achievement => {
        achievement.completed = false;
      });
      
      console.log('成就系统初始化完成');
    }
    
    function updateAchievementProgress(type, data = {}) {
      const progress = gameData.achievementSystem.achievementProgress;
      
      switch(type) {
        case 'wave_completed':
          progress.totalWavesDefended++;
          break;
          
        case 'tower_unlocked':
          if (data.towerType) {
            progress.towersUnlocked.add(data.towerType);
          }
          break;
          
        case 'money_earned':
          progress.totalMoney += data.amount || 0;
          break;
          
        case 'tech_updated':
          progress.maxTechLevel = Math.max(
            progress.maxTechLevel,
            gameData.techSystem.attackTechLevel,
            gameData.techSystem.defenseTechLevel,
            gameData.techSystem.economyTechLevel
          );
          break;
          
        case 'core_damaged':
          progress.perfectDefense = false;
          break;
      }
      
      // 检查成就完成情况
      checkAchievementCompletion();
    }
    
    function checkAchievementCompletion() {
      const progress = gameData.achievementSystem.achievementProgress;
      
      gameData.achievementSystem.achievements.forEach(achievement => {
        if (achievement.completed) return;
        
        let isCompleted = false;
        
        switch(achievement.id) {
          case 'achievement_1': // 防御大师
            isCompleted = progress.totalWavesDefended >= 100;
            break;
            
          case 'achievement_2': // 炮塔收藏家
            const totalTowerTypes = gameData.towerTypes.length;
            isCompleted = progress.towersUnlocked.size >= totalTowerTypes;
            break;
            
          case 'achievement_3': // 经济大师
            isCompleted = progress.totalMoney >= 10000;
            break;
            
          case 'achievement_4': // 科技达人
            isCompleted = progress.maxTechLevel >= 10; // 假设最高科技等级为10
            break;
            
          case 'achievement_5': // 完美防御
            isCompleted = progress.perfectDefense && gameData.currentWave >= gameData.maxWaves;
            break;
        }
        
        if (isCompleted) {
          unlockAchievement(achievement);
        }
      });
    }
    
    function unlockAchievement(achievement) {
      achievement.completed = true;
      gameData.achievementSystem.recentlyUnlocked.push(achievement);
      
      // 发放奖励
      if (achievement.reward.techPoints) {
        gameData.techSystem.techPoints += achievement.reward.techPoints;
        showFloatingText('成就奖励: +' + achievement.reward.techPoints + ' 科技点', 
                        canvas.width / 2, 120, '#8B5CF6', 3);
      }
      
      // 显示成就解锁通知
      showAchievementNotification(achievement);
      
      console.log('成就解锁:', achievement.name, '奖励:', achievement.reward);
    }
    
    function showAchievementNotification(achievement) {
      const notification = document.getElementById('achievement-notification');
      const title = document.getElementById('achievement-title');
      const desc = document.getElementById('achievement-desc');
      
      if (notification && title && desc) {
        title.textContent = achievement.name;
        desc.textContent = achievement.description;
        
        notification.classList.add('show');
        
        // 5秒后隐藏
        setTimeout(() => {
          notification.classList.remove('show');
        }, 5000);
      }
    }
    
    function getAchievementProgress() {
      const progress = gameData.achievementSystem.achievementProgress;
      const achievements = gameData.achievementSystem.achievements;
      
      return achievements.map(achievement => {
        let current = 0;
        let target = 0;
        
        switch(achievement.id) {
          case 'achievement_1':
            current = progress.totalWavesDefended;
            target = 100;
            break;
          case 'achievement_2':
            current = progress.towersUnlocked.size;
            target = gameData.towerTypes.length;
            break;
          case 'achievement_3':
            current = progress.totalMoney;
            target = 10000;
            break;
          case 'achievement_4':
            current = progress.maxTechLevel;
            target = 10;
            break;
          case 'achievement_5':
            current = progress.perfectDefense ? 1 : 0;
            target = 1;
            break;
        }
        
        return {
          ...achievement,
          progress: Math.min(current / target, 1),
          current,
          target
        };
      });
    }
    
    // 技能系统核心函数
    function initializeSkillSystem() {
      // 初始化技能冷却
      gameData.skillSystem.skillCooldowns = {};
      gameData.skillSystem.activeSkills = [];
      
      // 初始化技能点（根据游戏进度或成就解锁）
      const completedAchievements = gameData.achievementSystem.achievements.filter(a => a.completed).length;
      gameData.skillSystem.skillPoints = Math.max(0, completedAchievements - 1); // 第一个成就解锁第一个技能点
      
      // 解锁第一个技能
      if (gameData.skillSystem.skills.length > 0) {
        gameData.skillSystem.skills[0].unlocked = true;
      }
      
      console.log('技能系统初始化完成，技能点:', gameData.skillSystem.skillPoints);
    }
    
    function updateSkillSystem() {
      // 更新技能冷却
      const currentTime = Date.now();
      Object.keys(gameData.skillSystem.skillCooldowns).forEach(skillId => {
        const cooldown = gameData.skillSystem.skillCooldowns[skillId];
        if (currentTime >= cooldown.endTime) {
          delete gameData.skillSystem.skillCooldowns[skillId];
        }
      });
      
      // 更新持续技能效果
      gameData.skillSystem.activeSkills = gameData.skillSystem.activeSkills.filter(skill => {
        if (currentTime >= skill.endTime) {
          // 技能效果结束
          endSkillEffect(skill.id);
          return false;
        }
        return true;
      });
      
      // 更新技能按钮状态
      updateSkillButtons();
    }
    
    function useSkill(skillId, targetPosition = null) {
      const skill = gameData.skillSystem.skills.find(s => s.id === skillId);
      if (!skill || !skill.unlocked) {
        console.log('技能未解锁或不存在');
        return false;
      }
      
      // 检查冷却
      if (isSkillOnCooldown(skillId)) {
        console.log('技能正在冷却中');
        return false;
      }
      
      console.log('使用技能:', skill.name);
      
      // 应用技能效果
      switch(skillId) {
        case 'skill_orbital_strike':
          if (targetPosition) {
            activateOrbitalStrike(targetPosition, skill);
          }
          break;
          
        case 'skill_time_freeze':
          activateTimeFreeze(skill);
          break;
          
        case 'skill_money_boost':
          activateMoneyBoost(skill);
          break;
          
        case 'skill_shield_barrier':
          activateShieldBarrier(skill);
          break;
          
        case 'skill_core_heal':
          activateCoreHeal(skill);
          break;
      }
      
      // 设置冷却
      setSkillCooldown(skillId, skill.cooldown);
      
      // 如果是持续技能，添加到活跃技能列表
      if (skill.duration > 0) {
        gameData.skillSystem.activeSkills.push({
          id: skillId,
          startTime: Date.now(),
          endTime: Date.now() + (skill.duration * 1000)
        });
      }
      
      return true;
    }
    
    function activateOrbitalStrike(targetPosition, skill) {
      // 创建轨道打击效果
      const effect = {
        type: 'orbital_strike',
        x: targetPosition.x,
        y: targetPosition.y,
        radius: skill.radius,
        damage: skill.damage,
        time: 0,
        duration: 2
      };
      
      gameData.effects.push(effect);
      
      // 显示技能激活文本
      showFloatingText(targetPosition.x, targetPosition.y - 50, '轨道打击！', '#EF4444', 3);
      
      // 延迟造成伤害
      setTimeout(() => {
        // 对范围内的敌人造成伤害
        gameData.monsters.forEach(monster => {
          const dx = monster.position.x - targetPosition.x;
          const dy = monster.position.y - targetPosition.y;
          const distance = Math.sqrt(dx * dx + dy * dy);
          
          if (distance <= skill.radius) {
            damageMonster(monster, skill.damage, 'orbital_strike');
            
            // 创建爆炸效果
            createExplosion(monster.position.x, monster.position.y, 30);
          }
        });
      }, 1000);
    }
    
    function activateTimeFreeze(skill) {
      // 冻结所有敌人
      gameData.monsters.forEach(monster => {
        monster.isFrozen = true;
        monster.freezeTime = skill.freezeTime;
        monster.freezeStartTime = Date.now();
      });
      
      // 显示技能激活文本
      showFloatingText(canvas.width / 2, 50, '时间冻结！', '#3B82F6', 3);
    }
    
    function activateMoneyBoost(skill) {
      // 增加金钱奖励倍率
      gameData.moneyMultiplier = skill.moneyMultiplier;
      gameData.moneyBoostEndTime = Date.now() + (skill.duration * 1000);
      
      // 显示技能激活文本
      showFloatingText(canvas.width / 2, 50, '经济繁荣！', '#10B981', 3);
    }
    
    function activateShieldBarrier(skill) {
      // 为所有炮塔添加护盾
      gameData.towers.forEach(tower => {
        tower.shield = skill.shieldAmount;
        tower.shieldStartTime = Date.now();
        tower.shieldDuration = skill.duration;
      });
      
      // 显示技能激活文本
      showFloatingText(canvas.width / 2, 50, '护盾屏障！', '#8B5CF6', 3);
    }
    
    function activateCoreHeal(skill) {
      // 恢复核心血量
      const healAmount = skill.healAmount;
      const oldHealth = gameData.coreHealth;
      gameData.coreHealth = Math.min(gameData.maxCoreHealth, gameData.coreHealth + healAmount);
      
      // 显示治疗效果
      const endPoint = gameData.path[gameData.path.length - 1];
      showFloatingText(endPoint.x, endPoint.y, `+${gameData.coreHealth - oldHealth}`, '#10B981', 2);
      
      // 显示技能激活文本
      showFloatingText(canvas.width / 2, 50, '核心修复！', '#10B981', 3);
      
      // 创建治疗效果
      const effect = {
        type: 'heal',
        x: gameData.gridOffset.x + endPoint.x * gameData.cellSize + gameData.cellSize / 2,
        y: gameData.gridOffset.y + endPoint.y * gameData.cellSize + gameData.cellSize / 2,
        size: gameData.cellSize * 2,
        time: 0,
        duration: 1
      };
      
      gameData.effects.push(effect);
    }
    
    function endSkillEffect(skillId) {
      switch(skillId) {
        case 'skill_time_freeze':
          // 解冻所有敌人
          gameData.monsters.forEach(monster => {
            monster.isFrozen = false;
          });
          break;
          
        case 'skill_money_boost':
          // 重置金钱倍率
          gameData.moneyMultiplier = 1.0;
      gameData.moneyBoostEndTime = 0;
          break;
          
        case 'skill_shield_barrier':
          // 移除所有炮塔护盾
          gameData.towers.forEach(tower => {
            tower.shield = 0;
          });
          break;
      }
    }
    
    function isSkillOnCooldown(skillId) {
      return gameData.skillSystem.skillCooldowns.hasOwnProperty(skillId);
    }
    
    function getSkillCooldown(skillId) {
      const cooldown = gameData.skillSystem.skillCooldowns[skillId];
      if (!cooldown) return 0;
      
      const remaining = Math.max(0, cooldown.endTime - Date.now());
      return Math.ceil(remaining / 1000);
    }
    
    function setSkillCooldown(skillId, cooldownSeconds) {
      gameData.skillSystem.skillCooldowns[skillId] = {
        startTime: Date.now(),
        endTime: Date.now() + (cooldownSeconds * 1000)
      };
    }
    
    function upgradeSkill(skillId) {
      const skill = gameData.skillSystem.skills.find(s => s.id === skillId);
      if (!skill || skill.level >= skill.maxLevel || !skill.unlocked) {
        return false;
      }
      
      if (gameData.skillSystem.skillPoints <= 0) {
        return false;
      }
      
      // 升级技能
      skill.level++;
      gameData.skillSystem.skillPoints--;
      
      // 提升技能效果
      switch(skillId) {
        case 'skill_orbital_strike':
          skill.damage = 500 + (skill.level - 1) * 200;
          skill.radius = 3 + (skill.level - 1) * 0.5;
          break;
          
        case 'skill_time_freeze':
          skill.freezeTime = 3 + (skill.level - 1) * 1;
          skill.cooldown = 45 - (skill.level - 1) * 5;
          break;
          
        case 'skill_money_boost':
          skill.moneyMultiplier = 1.5 + (skill.level - 1) * 0.5;
          skill.duration = 20 + (skill.level - 1) * 5;
          break;
          
        case 'skill_shield_barrier':
          skill.shieldAmount = 200 + (skill.level - 1) * 100;
          skill.duration = 15 + (skill.level - 1) * 3;
          break;
          
        case 'skill_core_heal':
          skill.healAmount = 50 + (skill.level - 1) * 25;
          skill.cooldown = 120 - (skill.level - 1) * 20;
          break;
      }
      
      console.log('技能升级:', skill.name, '等级:', skill.level);
      return true;
    }
    
    function unlockSkill(skillId) {
      const skillIndex = gameData.skillSystem.skills.findIndex(s => s.id === skillId);
      if (skillIndex === -1 || gameData.skillSystem.skills[skillIndex].unlocked) {
        return false;
      }
      
      // 检查前置技能是否解锁
      if (skillIndex > 0) {
        const previousSkill = gameData.skillSystem.skills[skillIndex - 1];
        if (!previousSkill.unlocked || previousSkill.level < previousSkill.maxLevel) {
          return false;
        }
      }
      
      if (gameData.skillSystem.skillPoints <= 0) {
        return false;
      }
      
      // 解锁技能
      gameData.skillSystem.skills[skillIndex].unlocked = true;
      gameData.skillSystem.skillPoints--;
      
      console.log('技能解锁:', gameData.skillSystem.skills[skillIndex].name);
      return true;
    }
    
    function updateSkillButtons() {
      // 更新技能按钮状态
      gameData.skillSystem.skills.forEach(skill => {
        const button = document.getElementById('skill_' + skill.id);
        if (!button) return;
        
        if (!skill.unlocked) {
          button.disabled = true;
          button.classList.add('locked');
        } else {
          button.classList.remove('locked');
          const cooldown = getSkillCooldown(skill.id);
          if (cooldown > 0) {
            button.disabled = true;
            button.textContent = `${skill.name} (${cooldown}s)`;
          } else {
            button.disabled = false;
            button.textContent = skill.name;
          }
        }
      });
    }
    
    function renderSkillEffects(ctx) {
      // 渲染技能效果
      gameData.effects.forEach(effect => {
        if (effect.type === 'orbital_strike') {
          renderOrbitalStrikeEffect(ctx, effect);
        } else if (effect.type === 'heal') {
          renderHealEffect(ctx, effect);
        }
      });
      
      // 渲染炮塔护盾
      gameData.towers.forEach(tower => {
        if (tower.shield > 0) {
          renderTowerShield(ctx, tower);
        }
      });
    }
    
    function renderOrbitalStrikeEffect(ctx, effect) {
      const progress = effect.time / effect.duration;
      const alpha = progress < 0.5 ? progress * 2 : (1 - progress) * 2;
      
      ctx.save();
      ctx.globalAlpha = alpha * 0.8;
      ctx.fillStyle = '#EF4444';
      
      // 绘制爆炸圆圈
      ctx.beginPath();
      ctx.arc(effect.x, effect.y, effect.radius * gameData.cellSize, 0, Math.PI * 2);
      ctx.fill();
      
      // 绘制冲击波
      ctx.strokeStyle = '#F59E0B';
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.arc(effect.x, effect.y, effect.radius * gameData.cellSize * (0.5 + progress * 0.5), 0, Math.PI * 2);
      ctx.stroke();
      
      ctx.restore();
    }
    
    function renderHealEffect(ctx, effect) {
      const progress = effect.time / effect.duration;
      const alpha = 1 - progress;
      
      ctx.save();
      ctx.globalAlpha = alpha * 0.6;
      ctx.fillStyle = '#10B981';
      
      // 绘制治疗光环
      ctx.beginPath();
      ctx.arc(effect.x, effect.y, effect.size * (0.8 + progress * 0.4), 0, Math.PI * 2);
      ctx.fill();
      
      ctx.restore();
    }
    
    function renderTowerShield(ctx, tower) {
      const shieldProgress = (Date.now() - tower.shieldStartTime) / (tower.shieldDuration * 1000);
      const alpha = 1 - shieldProgress;
      
      ctx.save();
      ctx.globalAlpha = alpha * 0.4;
      ctx.fillStyle = '#8B5CF6';
      
      // 绘制护盾
      ctx.beginPath();
      ctx.arc(
        tower.position.x, 
        tower.position.y, 
        gameData.cellSize * 0.8, 
        0, 
        Math.PI * 2
      );
      ctx.fill();
      
      ctx.strokeStyle = '#C4B5FD';
      ctx.lineWidth = 2;
      ctx.stroke();
      
      ctx.restore();
    }
    
    function updateGame() {
      // 初始化必要的游戏数据结构（防止数据损坏）
      if (!gameData) {
        console.error('游戏数据不存在！');
        return;
      }
      
      // 确保数组存在且为数组类型
      gameData.towers = Array.isArray(gameData.towers) ? gameData.towers : [];
      gameData.monsters = Array.isArray(gameData.monsters) ? gameData.monsters : [];
      gameData.projectiles = Array.isArray(gameData.projectiles) ? gameData.projectiles : [];
      gameData.effects = Array.isArray(gameData.effects) ? gameData.effects : [];
      gameData.explosions = Array.isArray(gameData.explosions) ? gameData.explosions : [];
      gameData.floatingTexts = Array.isArray(gameData.floatingTexts) ? gameData.floatingTexts : [];
      
      // 初始化新系统数据结构
      gameData.missionSystem = gameData.missionSystem || {
        currentMission: null,
        completedMissions: [],
        availableMissions: [],
        missionProgress: {}
      };
      
      gameData.achievementSystem = gameData.achievementSystem || {
        achievements: [],
        recentlyUnlocked: []
      };
      
      gameData.skillSystem = gameData.skillSystem || {
        skills: [],
        skillPoints: 0,
        activeSkills: [],
        skillCooldowns: {}
      };
      
      gameData.mapSystem = gameData.mapSystem || {
        currentMap: 'default',
        unlockedMaps: ['default'],
        maps: {}
      };
      
      if (gameData.isGameOver || gameData.isVictory) return;
      
      // 定期更新炮塔信息界面（每秒更新10次）
      gameData.uiUpdateTimer = (gameData.uiUpdateTimer || 0) + gameData.deltaTime;
      if (gameData.uiUpdateTimer >= 0.1) {
        if (gameData.selectedTower && !towerInfoScreen.classList.contains('hidden')) {
          // 只在信息发生变化时才更新
          const tower = gameData.selectedTower;
          const currentInfo = {
            level: tower.level,
            damage: tower.damage,
            fireRate: tower.fireRate,
            cooldown: tower.cooldown
          };
          
          // 首次更新时存储当前信息
          if (!gameData.lastTowerInfo) {
            gameData.lastTowerInfo = currentInfo;
            showTowerInfo(tower);
          } else {
            // 比较信息是否有变化
            const infoChanged = Object.keys(currentInfo).some(key => 
              gameData.lastTowerInfo[key] !== currentInfo[key]
            );
            
            if (infoChanged) {
              gameData.lastTowerInfo = currentInfo;
              showTowerInfo(tower);
            }
          }
        }
        gameData.uiUpdateTimer = 0;
      }
      
      // 检查波次是否结束（确保小BOSS也被消灭）
      // 添加防御性检查，特别是针对第16波可能出现的新怪物类型
      if (gameData.isWaveActive && (!gameData.monsters || gameData.monsters.length === 0) && (!gameData.currentBoss)) {
        // 添加延迟检查，防止波次刚开始就结束
        const waveDuration = Date.now() - gameData.waveStartTime;
        if (waveDuration < 2000) {
          // 如果波次刚刚开始且没有怪物，等待一段时间再检查
          setTimeout(() => {
            if (gameData && gameData.isWaveActive && gameData.monsters && gameData.monsters.length === 0) {
              // 执行波次结束逻辑
              gameData.isWaveActive = false;
              gameData.waveStartTime = Date.now();
              
              // 每回合结束时，有核心恢复技能的炮塔为核心回血
              let coreHealAmount = 0;
              if (gameData.towers && Array.isArray(gameData.towers)) {
                gameData.towers.forEach(tower => {
                  if (tower.skill === 'coreHeal') {
                    coreHealAmount += tower.coreHealAmount || 1;
                  }
                });
              }
              
              if (coreHealAmount > 0) {
                // 核心回血
                gameData.coreHealth = Math.min(100, gameData.coreHealth + coreHealAmount);
                updateGameInfo();
                
                // 显示核心回血效果
                if (gameData.path && gameData.path.length > 0) {
                  const endPoint = gameData.path[gameData.path.length - 1];
                  showFloatingText(endPoint.x, endPoint.y, `+${coreHealAmount}`, '#10B981');
                }
              }
              
              // 波次结束奖励
              const waveBonus = 50 + gameData.currentWave * 10;
              gameData.money += waveBonus;
              if (gameData.path && gameData.path.length > 0) {
                const endPoint = gameData.path[gameData.path.length - 1];
                showFloatingText(endPoint.x, endPoint.y, `+${waveBonus} 金钱`, '#F59E0B');
              }
              
              // 更新游戏信息
              updateGameInfo();
              
              // 检查是否胜利
              if (gameData.waveSettings && gameData.currentWave >= gameData.waveSettings.maxBaseWave && !gameData.waveSettings.endlessMode) {
                gameData.isVictory = true;
                gameData.gameState = 'victory';
              }
            }
          }, 1000);
          return;
        }
        
        gameData.isWaveActive = false;
        gameData.waveStartTime = Date.now();
        
        // 每回合结束时，有核心恢复技能的炮塔为核心回血
        let coreHealAmount = 0;
        gameData.towers.forEach(tower => {
          if (tower.skill === 'coreHeal') {
            coreHealAmount += tower.coreHealAmount || 1;
          }
        });
        
        if (coreHealAmount > 0) {
          // 核心回血
          gameData.coreHealth = Math.min(100, gameData.coreHealth + coreHealAmount);
          updateGameInfo();
          
          // 显示核心回血效果
          const endPoint = gameData.path[gameData.path.length - 1];
          showFloatingText(endPoint.x, endPoint.y, `+${coreHealAmount}`, '#10B981');
          
          // 创建核心回血效果
          const effect = {
            type: 'hit',
            x: gameData.gridOffset.x + endPoint.x * gameData.cellSize + gameData.cellSize / 2,
            y: gameData.gridOffset.y + endPoint.y * gameData.cellSize + gameData.cellSize / 2,
            size: gameData.cellSize * 1.5,
            time: 0
          };
          
          gameData.effects.push(effect);
        }
        
        // 检查是否是最后一波
        if (gameData.currentWave === gameData.waveSettings.bossWave) {
          // 胜利
          gameData.isVictory = true;
          changeGameState('victory');
          return;
        }
        
        // 显示波次结束通知
        showFloatingText(gameData.gridSize.width / 2, gameData.gridSize.height / 2, `第${gameData.currentWave}波完成！`, '#F59E0B', 2);
        
        // 更新任务进度 - 波次完成
        updateMissionProgress('wave_completed');
      }
      
      // 检查是否开始下一波
      if (!gameData.isWaveActive && Date.now() - gameData.waveStartTime >= gameData.waveDelay) {
        // 增加波次
        gameData.currentWave++;
        
        // 确保波次不超过100（防止数值异常）
        if (gameData.currentWave > 100) {
          gameData.currentWave = 100;
        }
        
        console.log('开始新波次:', gameData.currentWave);
        startWave();
      }
      
      // 更新炮塔
      updateTowers();
      
      // 更新怪物
      updateMonsters();
      
      // 更新己方单位
      updateAllies();
      
      // 怪物攻击炮塔
      monstersAttackTowers();
      
      // 更新 projectile
      updateProjectiles();
      
      // 更新爆炸效果
      updateExplosions();
      
      // 更新特效
      updateEffects();
      
      // 更新浮动文本
      updateFloatingTexts();
      
      // 更新技能系统
      updateSkillSystem();
      
      // 更新技能快捷栏
      updateSkillHotbar();
      
      // 检查游戏结束
      if (gameData.coreHealth <= 0) {
        gameData.isGameOver = true;
        changeGameState('game-over');
      }
    }
    
    // 处理能量增幅塔的效果
    function handleAmplifierTowers() {
      // 收集所有能量增幅塔
      const amplifierTowers = gameData.towers.filter(tower => tower.type === 'amplifier');
      
      // 为每个能量增幅塔创建能量粒子效果
      amplifierTowers.forEach(amplifier => {
        // 初始化粒子数组
        if (!amplifier.energyParticles) {
          amplifier.energyParticles = [];
        }
        
        // 添加新粒子
        if (Math.random() < 0.3) {
          amplifier.energyParticles.push({
            x: (Math.random() - 0.5) * gameData.cellSize * 6,
            y: (Math.random() - 0.5) * gameData.cellSize * 6,
            size: 1 + Math.random() * 3,
            life: 1 + Math.random() * 2
          });
        }
        
        // 更新粒子
        amplifier.energyParticles.forEach((particle, index) => {
          particle.life -= gameData.deltaTime;
          
          // 粒子向中心移动
          const dx = -particle.x;
          const dy = -particle.y;
          const distance = Math.sqrt(dx * dx + dy * dy);
          if (distance > 0) {
            particle.x += dx / distance * 50 * gameData.deltaTime;
            particle.y += dy / distance * 50 * gameData.deltaTime;
          }
          
          // 移除死亡粒子
          if (particle.life <= 0) {
            amplifier.energyParticles.splice(index, 1);
          }
        });
        
        // 为3×3范围内的炮塔提供伤害加成
        gameData.towers.forEach(tower => {
          // 跳过自身和其他特殊炮台
          if (tower === amplifier || tower.type === 'amplifier' || tower.type === 'repair') {
            return;
          }
          
          // 计算距离
          const dx = Math.abs(tower.position.x - amplifier.position.x);
          const dy = Math.abs(tower.position.y - amplifier.position.y);
          
          // 如果在3×3范围内
          if (dx <= 3 && dy <= 3) {
            // 添加伤害加成标记
            tower.hasAmplifierBonus = true;
            
            // 存储原始伤害值
            if (!tower.originalDamage) {
              tower.originalDamage = tower.damage;
            }
            
            // 应用25%伤害加成
            tower.damage = Math.floor(tower.originalDamage * 1.25);
            
            // 显示伤害加成效果
            if (!tower.amplifierEffectTime || tower.amplifierEffectTime <= 0) {
              showFloatingText(tower.position.x, tower.position.y - 1, '伤害+25%', '#3B82F6');
              tower.amplifierEffectTime = 1; // 1秒内不重复显示
            } else {
              tower.amplifierEffectTime -= gameData.deltaTime;
            }
          } else if (tower.hasAmplifierBonus && tower.originalDamage) {
            // 如果不在范围内且有加成，恢复原始伤害
            tower.damage = tower.originalDamage;
            tower.hasAmplifierBonus = false;
          }
        });
      });
      
      // 对于不在任何能量增幅塔范围内的炮塔，恢复原始伤害
      gameData.towers.forEach(tower => {
        if (tower.type !== 'amplifier' && tower.type !== 'repair' && 
            tower.hasAmplifierBonus && !isTowerInAmplifierRange(tower)) {
          tower.damage = tower.originalDamage;
          tower.hasAmplifierBonus = false;
        }
      });
    }
    
    // 检查炮塔是否在任何能量增幅塔范围内
    function isTowerInAmplifierRange(tower) {
      const amplifierTowers = gameData.towers.filter(t => t.type === 'amplifier');
      
      return amplifierTowers.some(amplifier => {
        const dx = Math.abs(tower.position.x - amplifier.position.x);
        const dy = Math.abs(tower.position.y - amplifier.position.y);
        return dx <= 3 && dy <= 3;
      });
    }
    
    // 处理修复塔的效果
    function handleRepairTowers() {
      // 收集所有修复塔
      const repairTowers = gameData.towers.filter(tower => tower.type === 'repair');
      
      // 初始化修复计时器
      repairTowers.forEach(repairTower => {
        if (!repairTower.repairTimer) {
          repairTower.repairTimer = 0;
        }
        
        // 更新修复计时器
        repairTower.repairTimer += gameData.deltaTime;
        
        // 每3秒修复一次
        if (repairTower.repairTimer >= 3) {
          // 寻找3×3范围内需要修复的炮塔
          const damagedTowers = gameData.towers.filter(tower => {
            // 跳过自身和其他特殊炮台
            if (tower === repairTower || tower.type === 'amplifier' || tower.type === 'repair') {
              return false;
            }
            
            // 检查是否在3×3范围内
            const dx = Math.abs(tower.position.x - repairTower.position.x);
            const dy = Math.abs(tower.position.y - repairTower.position.y);
            
            // 检查是否受损（生命值低于最大生命值）
            return dx <= 3 && dy <= 3 && tower.health < tower.maxHealth;
          });
          
          // 如果有需要修复的炮塔
          if (damagedTowers.length > 0) {
            // 选择一个炮塔进行修复
            const targetTower = damagedTowers[Math.floor(Math.random() * damagedTowers.length)];
            
            // 修复10点生命值
            const repairAmount = 10;
            targetTower.health = Math.min(targetTower.maxHealth, targetTower.health + repairAmount);
            
            // 显示修复效果
            showFloatingText(targetTower.position.x, targetTower.position.y - 1, `+${repairAmount} HP`, '#10B981');
            
            // 设置当前修复目标（用于绘制修复光束）
            repairTower.repairingTower = targetTower;
            
            // 重置修复计时器
            repairTower.repairTimer = 0;
          } else {
            // 没有需要修复的炮塔
            repairTower.repairingTower = null;
          }
        }
      });
    }
    
    // 处理烈火炮的防冻保护效果
    function handleFlameTowerProtection() {
      // 找出所有未被冻结的烈火炮
      const activeFlameTowers = gameData.towers.filter(tower => 
        tower.type === 'flame' && !tower.isFrozen
      );
      
      // 为每个未被冻结的烈火炮创建保护区域
      activeFlameTowers.forEach(flameTower => {
        const { x, y } = flameTower.position;
        
        // 检查3x3范围内的所有炮塔
        for (let dx = -1; dx <= 1; dx++) {
          for (let dy = -1; dy <= 1; dy++) {
            const targetX = x + dx;
            const targetY = y + dy;
            
            // 查找该位置的炮塔
            const protectedTower = gameData.towers.find(tower => 
              tower.position.x === targetX && tower.position.y === targetY
            );
            
            if (protectedTower) {
              // 设置保护标记，防止被冻结
              protectedTower.isProtectedByFlame = true;
            }
          }
        }
      });
      
      // 为所有炮塔清除保护标记（下一轮会重新设置）
      gameData.towers.forEach(tower => {
        if (tower.isProtectedByFlame) {
          tower.isProtectedByFlame = false;
        }
      });
    }
    
    // 更新炮塔
    function updateTowers() {
      // 添加数据有效性检查
      if (!gameData || !gameData.towers || !Array.isArray(gameData.towers)) {
        console.error('炮塔数据损坏！', {
          gameDataExists: !!gameData,
          towersExists: !!gameData?.towers,
          towersIsArray: Array.isArray(gameData?.towers)
        });
        return;
      }
      
      // 确保所有炮塔都有必要的属性
      gameData.towers.forEach(tower => {
        if (!tower.fireTimer) tower.fireTimer = 0;
        if (!tower.quantumAoeChance) tower.quantumAoeChance = 0.2;
      });
      
      // 先处理烈火炮的防冻保护效果
      handleFlameTowerProtection();
      
      // 先处理能量增幅塔的效果
      handleAmplifierTowers();
      
      // 处理修复塔的效果
      handleRepairTowers();
      
      gameData.towers.forEach(tower => {
        // 检查炮塔对象是否有效
        if (!tower || !tower.position || typeof tower.position.x !== 'number' || typeof tower.position.y !== 'number') {
          console.error('无效的炮塔对象！', tower);
          return;
        }
        
        // 初始化量子塔特殊属性
        if (tower.type === 'quantum') {
          if (!tower.quantumAoeChance) tower.quantumAoeChance = 0.2;
          if (!tower.fireTimer) tower.fireTimer = 0;
        }
        // 处理烈火炮的解冻逻辑
        if (tower.type === 'flame' && tower.isFrozen && tower.frozenTimer > 0) {
          tower.frozenTimer -= gameData.deltaTime;
          if (tower.frozenTimer <= 0) {
            tower.isFrozen = false;
            tower.frozenTimer = 0;
          }
        }
        
        // 处理加农炮的冷却时间 - 即使被冻结也要更新
        if (tower.type === 'howitzer' && tower.cooldown !== undefined) {
          tower.cooldown -= gameData.deltaTime;
          if (tower.cooldown < 0) {
            tower.cooldown = 0;
          }
        }
        
        if (tower.isFrozen) return;
        
        // 更新射击计时器
        tower.fireTimer += gameData.deltaTime;
        
        // 检查是否可以射击
        if (tower.fireTimer >= tower.fireRate) {
          // 寻找目标
          const target = findTarget(tower);
          
          if (target) {
            // 射击目标
            shootTarget(tower, target);
            
            // 重置射击计时器
            tower.fireTimer = 0;
          }
        }
        
        // 量子炮特殊处理
        if (tower.type === 'quantum') {
          // 量子炮的特殊攻击逻辑
          tower.fireTimer += gameData.deltaTime;
          
          if (tower.fireTimer >= tower.fireRate) {
            // 寻找目标，优先攻击BOSS和精英怪物
            const target = findQuantumTarget(tower);
            
            if (target) {
              // 量子炮发射
              fireQuantumProjectile(tower, target);
              
              // 重置射击计时器
              tower.fireTimer = 0;
            }
          }
          return; // 量子炮使用特殊逻辑，跳过常规射击
        }
        
        // 特殊炮台不参与常规射击逻辑
        if (tower.type === 'amplifier' || tower.type === 'repair') {
          return;
        }
      });
    }
    
    // 处理能量增幅塔的效果
    function handleAmplifierTowers() {
      // 收集所有能量增幅塔
      const amplifierTowers = gameData.towers.filter(tower => tower.type === 'amplifier');
      
      // 为每个能量增幅塔创建能量粒子效果
      amplifierTowers.forEach(amplifier => {
        // 初始化粒子数组
        if (!amplifier.energyParticles) {
          amplifier.energyParticles = [];
        }
        
        // 添加新粒子
        if (Math.random() < 0.3) {
          amplifier.energyParticles.push({
            x: (Math.random() - 0.5) * gameData.cellSize * 6,
            y: (Math.random() - 0.5) * gameData.cellSize * 6,
            size: 1 + Math.random() * 3,
            life: 1 + Math.random() * 2
          });
        }
        
        // 更新粒子
        amplifier.energyParticles.forEach((particle, index) => {
          particle.life -= gameData.deltaTime;
          
          // 粒子向中心移动
          const dx = -particle.x;
          const dy = -particle.y;
          const distance = Math.sqrt(dx * dx + dy * dy);
          if (distance > 0) {
            particle.x += dx / distance * 50 * gameData.deltaTime;
            particle.y += dy / distance * 50 * gameData.deltaTime;
          }
          
          // 移除死亡粒子
          if (particle.life <= 0) {
            amplifier.energyParticles.splice(index, 1);
          }
        });
        
        // 为3×3范围内的炮塔提供伤害加成
        gameData.towers.forEach(tower => {
          // 跳过自身和其他特殊炮台
          if (tower === amplifier || tower.type === 'amplifier' || tower.type === 'repair') {
            return;
          }
          
          // 计算距离
          const dx = Math.abs(tower.position.x - amplifier.position.x);
          const dy = Math.abs(tower.position.y - amplifier.position.y);
          
          // 如果在3×3范围内
          if (dx <= 3 && dy <= 3) {
            // 添加伤害加成标记
            tower.hasAmplifierBonus = true;
            
            // 存储原始伤害值
            if (!tower.originalDamage) {
              tower.originalDamage = tower.damage;
            }
            
            // 应用25%伤害加成
            tower.damage = Math.floor(tower.originalDamage * 1.25);
            
            // 显示伤害加成效果
            if (!tower.amplifierEffectTime || tower.amplifierEffectTime <= 0) {
              showFloatingText(tower.position.x, tower.position.y - 1, '伤害+25%', '#3B82F6');
              tower.amplifierEffectTime = 1; // 1秒内不重复显示
            } else {
              tower.amplifierEffectTime -= gameData.deltaTime;
            }
          } else if (tower.hasAmplifierBonus && tower.originalDamage) {
            // 如果不在范围内且有加成，恢复原始伤害
            tower.damage = tower.originalDamage;
            tower.hasAmplifierBonus = false;
          }
        });
      });
      
      // 对于不在任何能量增幅塔范围内的炮塔，恢复原始伤害
      gameData.towers.forEach(tower => {
        if (tower.type !== 'amplifier' && tower.type !== 'repair' && 
            tower.hasAmplifierBonus && !isTowerInAmplifierRange(tower)) {
          tower.damage = tower.originalDamage;
          tower.hasAmplifierBonus = false;
        }
      });
    }
    
    // 检查炮塔是否在任何能量增幅塔范围内
    function isTowerInAmplifierRange(tower) {
      const amplifierTowers = gameData.towers.filter(t => t.type === 'amplifier');
      
      return amplifierTowers.some(amplifier => {
        const dx = Math.abs(tower.position.x - amplifier.position.x);
        const dy = Math.abs(tower.position.y - amplifier.position.y);
        return dx <= 3 && dy <= 3;
      });
    }
    
    // 处理修复塔的效果
    function handleRepairTowers() {
      // 收集所有修复塔
      const repairTowers = gameData.towers.filter(tower => tower.type === 'repair');
      
      // 初始化修复计时器
      repairTowers.forEach(repairTower => {
        if (!repairTower.repairTimer) {
          repairTower.repairTimer = 0;
        }
        
        // 更新修复计时器
        repairTower.repairTimer += gameData.deltaTime;
        
        // 每3秒修复一次
        if (repairTower.repairTimer >= 3) {
          // 寻找3×3范围内需要修复的炮塔
          const damagedTowers = gameData.towers.filter(tower => {
            // 跳过自身和其他特殊炮台
            if (tower === repairTower || tower.type === 'amplifier' || tower.type === 'repair') {
              return false;
            }
            
            // 检查是否在3×3范围内
            const dx = Math.abs(tower.position.x - repairTower.position.x);
            const dy = Math.abs(tower.position.y - repairTower.position.y);
            
            // 检查是否受损（生命值低于最大生命值）
            return dx <= 3 && dy <= 3 && tower.health < tower.maxHealth;
          });
          
          // 如果有需要修复的炮塔
          if (damagedTowers.length > 0) {
            // 选择一个炮塔进行修复
            const targetTower = damagedTowers[Math.floor(Math.random() * damagedTowers.length)];
            
            // 修复10点生命值
            const repairAmount = 10;
            targetTower.health = Math.min(targetTower.maxHealth, targetTower.health + repairAmount);
            
            // 显示修复效果
            showFloatingText(targetTower.position.x, targetTower.position.y - 1, `+${repairAmount} HP`, '#10B981');
            
            // 设置当前修复目标（用于绘制修复光束）
            repairTower.repairingTower = targetTower;
            
            // 重置修复计时器
            repairTower.repairTimer = 0;
          } else {
            // 没有需要修复的炮塔
            repairTower.repairingTower = null;
          }
        }
      });
    }
    
    // 处理烈火炮的防冻保护效果
    function handleFlameTowerProtection() {
      // 收集所有活跃的烈火炮（未被冻结的）
      const activeFlameTowers = gameData.towers.filter(tower => 
        tower.type === 'flame' && !tower.isFrozen
      );
      
      // 为每个烈火炮保护的3×3范围内的炮塔添加防冻标记
      gameData.towers.forEach(tower => {
        // 跳过烈火炮本身
        if (tower.type === 'flame') return;
        
        // 检查是否在任何活跃烈火炮的3×3范围内
        let isProtected = false;
        for (const flameTower of activeFlameTowers) {
          const dx = Math.abs(tower.position.x - flameTower.position.x);
          const dy = Math.abs(tower.position.y - flameTower.position.y);
          
          if (dx <= 1 && dy <= 1) {
            isProtected = true;
            break;
          }
        }
        
        tower.isProtectedByFlame = isProtected;
      });
    }
    
    // 寻找目标
    function findTarget(tower) {
      let bestTarget = null;
      let shortestTimeToCore = Infinity;
      
      // 遍历所有怪物
      for (const monster of gameData.monsters) {
        // 检查怪物是否在射程内
        const dx = monster.position.x - tower.position.x;
        const dy = monster.position.y - tower.position.y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        
        if (distance <= tower.range) {
          // 防空炮只攻击无人机
          if (tower.type === 'anti-air' && monster.type !== 'drone') {
            continue;
          }
          
          // 计算怪物到达核心的剩余时间
          const timeToCore = calculateTimeToCore(monster);
          
          // 哨兵炮特殊逻辑：优先攻击精英怪物和小BOSS
          if (tower.type === 'sentinel') {
            if (monster.isElite || monster.isMiniBoss) {
              // 精英怪物和小BOSS威胁值极高，给予极大的优先级
              if (timeToCore < shortestTimeToCore) {
                shortestTimeToCore = timeToCore;
                bestTarget = monster;
              }
            } else {
              // 其他怪物按到达时间排序
              if (timeToCore < shortestTimeToCore) {
                shortestTimeToCore = timeToCore;
                bestTarget = monster;
              }
            }
          } else {
            // 其他炮塔按到达时间排序
            if (timeToCore < shortestTimeToCore) {
              shortestTimeToCore = timeToCore;
              bestTarget = monster;
            }
          }
        }
      }
      
      return bestTarget;
    }
    
    // 计算怪物到达核心的剩余时间
    function calculateTimeToCore(monster) {
      // 如果怪物已经到达终点，返回0
      if (monster.pathIndex >= gameData.path.length - 1 && monster.progress >= 1) {
        return 0;
      }
      
      // 获取当前和下一个路径点
      const currentPoint = gameData.path[monster.pathIndex];
      const nextPoint = gameData.path[monster.pathIndex + 1];
      
      // 计算当前路径段的剩余距离
      const segmentDistance = Math.sqrt(
        Math.pow(nextPoint.x - currentPoint.x, 2) + 
        Math.pow(nextPoint.y - currentPoint.y, 2)
      );
      const remainingSegmentDistance = segmentDistance * (1 - monster.progress);
      
      // 计算剩余路径段的总距离
      let remainingPathDistance = remainingSegmentDistance;
      for (let i = monster.pathIndex + 1; i < gameData.path.length - 1; i++) {
        const point1 = gameData.path[i];
        const point2 = gameData.path[i + 1];
        remainingPathDistance += Math.sqrt(
          Math.pow(point2.x - point1.x, 2) + 
          Math.pow(point2.y - point1.y, 2)
        );
      }
      
      // 考虑减速效果
      let effectiveSpeed = monster.speed;
      if (monster.isSlowed) {
        effectiveSpeed = monster.speed * 0.5; // 假设减速50%
      }
      
      // 计算剩余时间（秒）
      return remainingPathDistance / effectiveSpeed;
    }
    
    // 计算距离核心的距离
    function getDistanceToCore(x, y) {
      const endPoint = gameData.path[gameData.path.length - 1];
      const dx = x - endPoint.x;
      const dy = y - endPoint.y;
      return Math.sqrt(dx * dx + dy * dy);
    }
    
    // 射击目标
    function shootTarget(tower, target) {
      // 根据炮塔类型创建不同的 projectile
      switch (tower.type) {
        case 'energy':
        case 'rapid':
        case 'ice':
        case 'titan':
        case 'sniper':
        case 'anti-air':
          // 创建普通 projectile
          createProjectile(tower, target);
          break;
          
        case 'gravity':
          // 重力炮：创建重力波
          createGravityWave(tower, target);
          break;
          
        case 'pulse':
          // 脉冲炮：创建脉冲波
          createPulseWave(tower, target);
          break;
          
        case 'plasma':
          // 等离子炮：创建等离子球
          createPlasmaBall(tower, target);
          break;
          
        case 'ion':
          // 离子炮：创建离子束
          createIonBeam(tower, target);
          break;
          
        case 'missile':
          // 导弹塔：创建追踪导弹
          createMissile(tower, target);
          break;
          
        case 'pierce':
          // 创建穿透 projectile
          createPierceProjectile(tower, target);
          break;
          
        case 'laser':
          // 创建激光
          createLaserEffect(tower);
          break;
          
        case 'rocket':
          // 创建火箭 projectile
          createRocketProjectile(tower, target);
          break;
          
        case 'electro':
          // 创建电磁 projectile
          createElectroProjectile(tower, target);
          break;
          
        case 'flame':
          // 创建炮塔特殊效果：保护周围3x3范围内的炮塔不被冻结
          if (!tower.isFrozen) {
            gameData.towers.forEach(otherTower => {
              const dx = otherTower.position.x - tower.position.x;
              const dy = otherTower.position.y - tower.position.y;
              if (Math.abs(dx) <= 1 && Math.abs(dy) <= 1) {
                otherTower.isProtected = true;
              }
            });
          }
          
          // 创建普通 projectile
          createProjectile(tower, target);
          break;
          
        case 'howitzer':
          // 加农炮需要手动发射，这里不自动发射
          break;
          
        case 'toxin':
          // 创建毒素 projectile
          createToxinProjectile(tower, target);
          break;
          
        case 'sentinel':
          // 哨兵炮特殊逻辑：优先攻击精英怪物和小BOSS，对精英怪物伤害提升50%
          if (target && (target.isElite || target.isMiniBoss)) {
            // 对精英怪物和小BOSS伤害提升50%
            const projectile = {
              type: 'normal',
              towerType: tower.type,
              damage: tower.damage * 1.5, // 伤害提升50%
              position: { ...tower.position },
              target: { ...target.position },
              speed: 12, // 速度更快
              tower: tower
            };
            
            gameData.projectiles.push(projectile);
            
            // 显示精英伤害提升提示
            showFloatingText(target.position.x, target.position.y - 1, '精英伤害+50%', '#F59E0B');
          } else {
            // 创建普通 projectile
            createProjectile(tower, target);
          }
          break;
          
        case 'nano-repair':
          // 纳米修复塔：治疗周围炮塔并提供护盾
          healNearbyTowers(tower);
          break;
          
        case 'emp':
          // EMP电磁脉冲塔：创建EMP波
          createEMPWave(tower, target);
          break;
          
        case 'beacon':
          // 信标塔：不发射弹药，提供光环效果
          break;
          

      }
    }
    
    // 治疗周围炮塔
    function healNearbyTowers(tower) {
      // 获取纳米修复塔的治疗量（每2秒20点）
      const healAmount = 20;
      
      // 遍历所有炮塔
      gameData.towers.forEach(otherTower => {
        // 跳过自己
        if (otherTower.id === tower.id) return;
        
        // 计算距离
        const dx = otherTower.position.x - tower.position.x;
        const dy = otherTower.position.y - tower.position.y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        
        // 如果在3x3范围内
        if (distance <= 1.5) { // 3x3范围
          // 确保生命值属性存在
          if (otherTower.health === undefined) {
            otherTower.health = 100;
            otherTower.maxHealth = 100;
          }
          
          // 治疗炮塔
          if (otherTower.health < otherTower.maxHealth) {
            // 恢复生命值
            otherTower.health = Math.min(otherTower.health + healAmount, otherTower.maxHealth);
            
            // 显示治疗效果
            createHealEffect(otherTower.position.x, otherTower.position.y);
            
            // 显示恢复数值
            showFloatingText(otherTower.position.x, otherTower.position.y - 1, `+${healAmount}`, '#10B981');
          } else {
            // 为满血炮塔提供临时护盾
            if (!otherTower.shieldTimer || otherTower.shieldTimer <= 0) {
              otherTower.hasShield = true;
              otherTower.shieldTimer = 10; // 护盾持续10秒
              showFloatingText(otherTower.position.x, otherTower.position.y - 1, '护盾+', '#3B82F6');
            }
          }
        }
      });
    }
    
    // 创建重力波
    function createGravityWave(tower, target) {
      const projectile = {
        type: 'gravity',
        towerType: tower.type,
        damage: tower.damage,
        position: { ...tower.position },
        target: { ...target.position },
        speed: 6, // 格/秒
        tower: tower
      };
      
      gameData.projectiles.push(projectile);
    }
    
    // 创建脉冲波
    function createPulseWave(tower, target) {
      const projectile = {
        type: 'pulse',
        towerType: tower.type,
        damage: tower.damage,
        position: { ...tower.position },
        direction: { x: 0, y: -1 }, // 默认向上
        speed: 8, // 格/秒
        distance: 0,
        maxDistance: tower.range,
        tower: tower
      };
      
      // 使用传入的目标设置方向
      if (target) {
        const dx = target.position.x - tower.position.x;
        const dy = target.position.y - tower.position.y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        projectile.direction = { x: dx / distance, y: dy / distance };
      }
      
      gameData.projectiles.push(projectile);
    }
    
    // 创建等离子球
    function createPlasmaBall(tower, target) {
      const projectile = {
        type: 'plasma',
        towerType: tower.type,
        damage: tower.damage,
        position: { ...tower.position },
        target: { ...target.position },
        speed: 7, // 格/秒
        tower: tower
      };
      
      gameData.projectiles.push(projectile);
    }
    
    // 创建离子束
    function createIonBeam(tower, target) {
      // 创建离子束效果
      const startX = gameData.gridOffset.x + tower.position.x * gameData.cellSize + gameData.cellSize / 2;
      const startY = gameData.gridOffset.y + tower.position.y * gameData.cellSize + gameData.cellSize / 2;
      const endX = gameData.gridOffset.x + target.position.x * gameData.cellSize + gameData.cellSize / 2;
      const endY = gameData.gridOffset.y + target.position.y * gameData.cellSize + gameData.cellSize / 2;
      
      // 创建蓝色离子束效果
      const ionBeam = {
        type: 'ionBeam',
        x: startX,
        y: startY,
        length: Math.sqrt((endX - startX) ** 2 + (endY - startY) ** 2),
        angle: Math.atan2(endY - startY, endX - startX),
        time: 0,
        startGridX: tower.position.x,
        startGridY: tower.position.y,
        endGridX: target.position.x,
        endGridY: target.position.y
      };
      
      gameData.effects.push(ionBeam);
      
      // 对目标造成伤害
      damageMonster(target, tower.damage, tower.type);
      
      // 30%几率穿透目标攻击后续敌人
      if (Math.random() < 0.3) {
        // 计算穿透方向
        const dx = target.position.x - tower.position.x;
        const dy = target.position.y - tower.position.y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        const direction = { x: dx / distance, y: dy / distance };
        
        // 寻找穿透路径上的下一个敌人
        let nextTarget = null;
        let minDistance = Infinity;
        
        gameData.monsters.forEach(monster => {
          if (monster === target) return;
          
          // 计算怪物到离子束起点的向量
          const mx = monster.position.x - tower.position.x;
          const my = monster.position.y - tower.position.y;
          
          // 计算点积
          const dot = mx * direction.x + my * direction.y;
          
          // 如果点积小于0，怪物在反方向
          if (dot < distance) return;
          
          // 计算投影长度
          const projectionLength = dot;
          
          // 如果投影长度大于激光长度，怪物在激光范围外
          if (projectionLength > tower.range) return;
          
          // 计算怪物到离子束的距离
          const cross = mx * direction.y - my * direction.x;
          const distanceToLine = Math.abs(cross);
          
          // 如果距离小于0.5格，怪物在离子束上
          if (distanceToLine < 0.5) {
            const monsterDistance = Math.sqrt(mx * mx + my * my);
            if (monsterDistance < minDistance && monsterDistance > distance) {
              minDistance = monsterDistance;
              nextTarget = monster;
            }
          }
        });
        
        if (nextTarget) {
          // 对穿透目标造成80%的伤害
          damageMonster(nextTarget, tower.damage * 0.8, tower.type);
          showFloatingText(nextTarget.position.x, nextTarget.position.y - 1, '穿透!', '#3B82F6');
        }
      }
    }
    
    // 创建追踪导弹（使用对象池）
    function createMissile(tower, target) {
      let projectile = getFromPool('projectiles');
      
      if (!projectile) {
        projectile = {
          type: '',
          towerType: '',
          damage: 0,
          position: { x: 0, y: 0 },
          target: { x: 0, y: 0 },
          speed: 0,
          tower: null,
          distance: 0,
          maxDistance: 0,
          direction: { x: 0, y: 0 }
        };
      }
      
      projectile.type = 'missile';
      projectile.towerType = tower.type;
      projectile.damage = tower.damage;
      projectile.position = { ...tower.position };
      projectile.target = { ...target.position };
      projectile.speed = 5; // 格/秒
      projectile.tower = tower;
      
      gameData.projectiles.push(projectile);
    }
    
    // 创建EMP波（使用对象池）
    function createEMPWave(tower, target) {
      let projectile = getFromPool('projectiles');
      
      if (!projectile) {
        projectile = {
          type: '',
          towerType: '',
          damage: 0,
          position: { x: 0, y: 0 },
          target: { x: 0, y: 0 },
          speed: 0,
          tower: null,
          distance: 0,
          maxDistance: 0,
          direction: { x: 0, y: 0 }
        };
      }
      
      projectile.type = 'emp';
      projectile.towerType = tower.type;
      projectile.damage = tower.damage;
      projectile.position = { ...tower.position };
      projectile.target = { ...target.position };
      projectile.speed = 6; // 格/秒
      projectile.tower = tower;
      
      gameData.projectiles.push(projectile);
    }
    
    // 创建治疗效果（使用对象池）
    function createHealEffect(gridX, gridY) {
      const x = gameData.gridOffset.x + gridX * gameData.cellSize + gameData.cellSize / 2;
      const y = gameData.gridOffset.y + gridY * gameData.cellSize + gameData.cellSize / 2;
      
      let effect = getFromPool('effects');
      
      if (!effect) {
        effect = {
          type: '',
          x: 0,
          y: 0,
          size: 0,
          time: 0,
          length: 0,
          angle: 0,
          startGridX: 0,
          startGridY: 0,
          endGridX: 0,
          endGridY: 0
        };
      }
      
      effect.type = 'heal';
      effect.x = x;
      effect.y = y;
      effect.size = gameData.cellSize;
      effect.time = 0;
      
      gameData.effects.push(effect);
    }
    
    // 创建普通 projectile（使用对象池）
    function createProjectile(tower, target) {
      let projectile = getFromPool('projectiles');
      
      if (!projectile) {
        projectile = {
          type: '',
          towerType: '',
          damage: 0,
          position: { x: 0, y: 0 },
          target: { x: 0, y: 0 },
          speed: 0,
          tower: null,
          distance: 0,
          maxDistance: 0,
          direction: { x: 0, y: 0 },
          sourceType: '',
          lifeTime: 0,
          maxLifeTime: 3 // 最大生命周期3秒，防止projectile无限存在
        };
      }
      
      projectile.type = 'normal';
      projectile.towerType = tower.type;
      projectile.damage = tower.damage;
      projectile.position = { ...tower.position };
      projectile.target = { ...target.position };
      projectile.speed = tower.type === 'ice' ? 8 : 10; // 冰锥炮速度稍慢
      projectile.tower = tower;
      projectile.sourceType = tower.type;
      projectile.lifeTime = 0;
      projectile.maxLifeTime = 3;
      
      gameData.projectiles.push(projectile);
    }
    
    // 创建穿透 projectile（使用对象池）
    function createPierceProjectile(tower, target) {
      let projectile = getFromPool('projectiles');
      
      if (!projectile) {
        projectile = {
          type: '',
          towerType: '',
          damage: 0,
          position: { x: 0, y: 0 },
          target: { x: 0, y: 0 },
          speed: 0,
          tower: null,
          distance: 0,
          maxDistance: 0,
          direction: { x: 0, y: 0 },
          sourceType: ''
        };
      }
      
      projectile.type = 'pierce';
      projectile.towerType = tower.type;
      projectile.damage = tower.damage;
      projectile.position = { ...tower.position };
      projectile.direction = { x: 0, y: -1 }; // 默认向上
      projectile.speed = 8; // 格/秒
      projectile.distance = 0;
      projectile.maxDistance = tower.range;
      projectile.tower = tower;
      
      // 使用传入的目标设置方向
      if (target) {
        const dx = target.position.x - tower.position.x;
        const dy = target.position.y - tower.position.y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        projectile.direction = { x: dx / distance, y: dy / distance };
      }
      
      gameData.projectiles.push(projectile);
    }
    
    // 创建激光效果
    function createLaserEffect(tower) {
      // 寻找目标
      const target = findTarget(tower);
      if (!target) return;
      
      // 创建激光效果
      const startX = gameData.gridOffset.x + tower.position.x * gameData.cellSize + gameData.cellSize / 2;
      const startY = gameData.gridOffset.y + tower.position.y * gameData.cellSize + gameData.cellSize / 2;
      const endX = gameData.gridOffset.x + target.position.x * gameData.cellSize + gameData.cellSize / 2;
      const endY = gameData.gridOffset.y + target.position.y * gameData.cellSize + gameData.cellSize / 2;
      
      createLaser(startX, startY, endX, endY);
      
      // 对目标造成伤害
      damageMonster(target, tower.damage, tower.type);
      
      // 穿透效果：伤害路径上的所有怪物
      const dx = target.position.x - tower.position.x;
      const dy = target.position.y - tower.position.y;
      const distance = Math.sqrt(dx * dx + dy * dy);
      const direction = { x: dx / distance, y: dy / distance };
      
      // 检查路径上的其他怪物
      gameData.monsters.forEach(monster => {
        if (monster === target) return;
        
        // 计算怪物到激光起点的向量
        const mx = monster.position.x - tower.position.x;
        const my = monster.position.y - tower.position.y;
        
        // 计算点积
        const dot = mx * direction.x + my * direction.y;
        
        // 如果点积小于0，怪物在反方向
        if (dot < 0) return;
        
        // 计算投影长度
        const projectionLength = dot;
        
        // 如果投影长度大于激光长度，怪物在激光范围外
        if (projectionLength > tower.range) return;
        
        // 计算怪物到激光线的距离
        const cross = mx * direction.y - my * direction.x;
        const distanceToLine = Math.abs(cross);
        
        // 如果距离小于0.5格，怪物在激光线上
        if (distanceToLine < 0.5) {
          damageMonster(monster, tower.damage * gameData.deltaTime * 5);
        }
      });
    }
    
    // 创建火箭 projectile
    function createRocketProjectile(tower, target) {
      const projectile = {
        type: 'rocket',
        towerType: tower.type,
        damage: tower.damage,
        position: { ...tower.position },
        target: { ...target.position },
        speed: 5, // 格/秒
        tower: tower
      };
      
      gameData.projectiles.push(projectile);
    }
    
    // 创建电磁 projectile
    function createElectroProjectile(tower, target) {
      const projectile = {
        type: 'electro',
        towerType: tower.type,
        damage: tower.damage,
        position: { ...tower.position },
        target: { ...target.position },
        speed: 7, // 格/秒
        tower: tower
      };
      
      gameData.projectiles.push(projectile);
    }
    
    // 创建防空炮炮 projectile
    function createAAProjectile(tower, target) {
      const projectile = {
        type: 'aa',
        towerType: tower.type,
        damage: tower.damage,
        position: { ...tower.position },
        target: { ...target.position },
        speed: 15, // 格/秒，防空炮炮炮弹速度更快
        tower: tower
      };
      
      gameData.projectiles.push(projectile);
    }
    
    // 创建毒素 projectile
    function createToxinProjectile(tower, target) {
      const projectile = {
        type: 'toxin',
        towerType: tower.type,
        damage: tower.damage,
        position: { ...tower.position },
        target: { ...target.position },
        speed: 8, // 格/秒
        tower: tower
      };
      
      gameData.projectiles.push(projectile);
    }
    
    // 更新 projectile
    function updateProjectiles() {
      if (!gameData.projectiles) gameData.projectiles = [];
      
      // 限制projectile数量，防止性能问题
      if (gameData.projectiles.length > 500) {
        console.warn('Projectile数量过多，清理多余的projectile');
        gameData.projectiles = gameData.projectiles.slice(-200); // 只保留最近的200个
      }
      
      for (let i = gameData.projectiles.length - 1; i >= 0; i--) {
        const projectile = gameData.projectiles[i];
        
        // 检查projectile对象有效性
        if (!projectile || !projectile.position || !projectile.target) {
          console.error('无效的projectile对象！', projectile);
          gameData.projectiles.splice(i, 1);
          continue;
        }
        
        switch (projectile.type) {
          case 'normal':
          case 'rocket':
          case 'electro':
          case 'aa':
          case 'howitzer':
          case 'toxin':
          case 'gravity':
          case 'plasma':
          case 'missile':
          case 'emp':
            // 更新生命周期
            projectile.lifeTime += gameData.deltaTime;
            if (projectile.lifeTime >= projectile.maxLifeTime) {
              // 生命周期结束，移除projectile
              gameData.projectiles.splice(i, 1);
              continue;
            }
            
            // 检查目标是否有效
            if (!projectile.target.x || !projectile.target.y) {
              gameData.projectiles.splice(i, 1);
              continue;
            }
            
            // 更新位置
            const dx = projectile.target.x - projectile.position.x;
            const dy = projectile.target.y - projectile.position.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            // 限制projectile的最大飞行距离，防止从四面八方飞来
            if (projectile.distanceTraveled === undefined) projectile.distanceTraveled = 0;
            projectile.distanceTraveled += projectile.speed * gameData.deltaTime;
            
            // 如果飞行距离过长或位置异常，移除projectile
            if (projectile.distanceTraveled > 50 || (Math.abs(projectile.position.x) > 100 || Math.abs(projectile.position.y) > 100)) {
              gameData.projectiles.splice(i, 1);
              continue;
            }
            
            if (distance < 0.1) {
              // 命中目标
              handleProjectileHit(projectile);
              
              // 移除 projectile
              gameData.projectiles.splice(i, 1);
            } else {
              // 移动 projectile
              const speed = projectile.speed * gameData.deltaTime;
              projectile.position.x += (dx / distance) * speed;
              projectile.position.y += (dy / distance) * speed;
              
              // 如果是追踪 projectile，更新目标位置
              if (projectile.type === 'rocket' || projectile.type === 'electro' || projectile.type === 'aa') {
                const target = findTarget(projectile.tower);
                if (target) {
                  projectile.target = { ...target.position };
                }
              }
            }
            break;
            
          case 'pierce':
          case 'pulse':
            // 检查projectile对象有效性
            if (!projectile || !projectile.position || !projectile.direction) {
              gameData.projectiles.splice(i, 1);
              continue;
            }
            
            // 更新位置
            projectile.position.x += projectile.direction.x * projectile.speed * gameData.deltaTime;
            projectile.position.y += projectile.direction.y * projectile.speed * gameData.deltaTime;
            
            // 更新距离
            projectile.distance += projectile.speed * gameData.deltaTime;
            
            // 检查是否超出最大距离
            if (projectile.distance >= projectile.maxDistance) {
              gameData.projectiles.splice(i, 1);
              continue;
            }
            
            // 检查是否命中怪物
            let hitMonster = false;
            for (const monster of gameData.monsters) {
              if (!monster || !monster.position) continue;
              
              const dx = monster.position.x - projectile.position.x;
              const dy = monster.position.y - projectile.position.y;
              const distance = Math.sqrt(dx * dx + dy * dy);
              
              if (distance < 0.5) {
                // 处理炮塔组合效果
                handleTowerComboEffect(monster, projectile);
                // 命中怪物
                damageMonster(monster, projectile.damage, projectile.sourceType || 'projectile');
                hitMonster = true;
              }
            }
            
            // 如果是速射炮或穿刺炮，穿透效果不消失
            if ((projectile.towerType !== 'rapid' && projectile.towerType !== 'pierce') && hitMonster) {
              gameData.projectiles.splice(i, 1);
            }
            break;
        }
      }
    }
    
    // 处理炮塔组合效果
    function handleTowerComboEffect(monster, projectile) {
      // 检查参数有效性
      if (!monster || !projectile) {
        return;
      }
      
      // 检查怪物身上的状态
      if (!monster.comboEffects) {
        monster.comboEffects = {};
      }
      
      // 记录当前炮塔类型的攻击
      if (!monster.comboEffects[projectile.towerType]) {
        monster.comboEffects[projectile.towerType] = {
          lastHitTime: Date.now(),
          hitCount: 1
        };
      } else {
        monster.comboEffects[projectile.towerType].lastHitTime = Date.now();
        monster.comboEffects[projectile.towerType].hitCount++;
      }
      
      // 清理过期的组合效果（5秒内没有攻击则清除）
      const currentTime = Date.now();
      Object.keys(monster.comboEffects).forEach(type => {
        if (currentTime - monster.comboEffects[type].lastHitTime > 5000) {
          delete monster.comboEffects[type];
        }
      });
      
      // 检查组合效果
      const activeTypes = Object.keys(monster.comboEffects);
      
      // 1. 冰火双重打击：火焰+冰冻
      if (activeTypes.includes('flame') && activeTypes.includes('ice')) {
        // 造成额外的蒸汽伤害和减速
        const steamDamage = Math.floor(projectile.damage * 0.5);
        damageMonster(monster, steamDamage, 'combo_steam');
        showFloatingText(monster.position.x, monster.position.y, `蒸汽+${steamDamage}`, '#06B6D4');
        
        // 强化减速效果
        monster.isSlowed = true;
        monster.slowDuration = Math.max(monster.slowDuration || 0, 3);
        
        // 显示组合效果
        if (!monster.lastComboEffect || monster.lastComboEffect !== 'steam') {
          showFloatingText(monster.position.x, monster.position.y, '冰火双重打击!', '#06B6D4', 2);
          monster.lastComboEffect = 'steam';
        }
      }
      
      // 2. 电磁风暴：电磁+激光
      if (activeTypes.includes('electro') && activeTypes.includes('laser')) {
        // 造成额外的电磁风暴伤害和眩晕
        const stormDamage = Math.floor(projectile.damage * 0.8);
        damageMonster(monster, stormDamage, 'combo_storm');
        showFloatingText(monster.position.x, monster.position.y, `风暴+${stormDamage}`, '#8B5CF6');
        
        // 造成短暂眩晕
        monster.isStunned = true;
        monster.stunDuration = Math.max(monster.stunDuration || 0, 1);
        
        // 显示组合效果
        if (!monster.lastComboEffect || monster.lastComboEffect !== 'storm') {
          showFloatingText(monster.position.x, monster.position.y, '电磁风暴!', '#8B5CF6', 2);
          monster.lastComboEffect = 'storm';
        }
      }
      
      // 3. 火箭齐射：火箭+导弹
      if (activeTypes.includes('rocket') && activeTypes.includes('missile')) {
        // 造成额外的爆炸伤害
        const explosionDamage = Math.floor(projectile.damage * 1.0);
        damageMonster(monster, explosionDamage, 'combo_explosion');
        showFloatingText(monster.position.x, monster.position.y, `爆炸+${explosionDamage}`, '#F59E0B');
        
        // 对周围怪物造成溅射伤害
        gameData.monsters.forEach(otherMonster => {
          if (!otherMonster || !otherMonster.id || !otherMonster.position || otherMonster.id === monster.id) {
            return;
          }
          const dx = otherMonster.position.x - monster.position.x;
          const dy = otherMonster.position.y - monster.position.y;
          const distance = Math.sqrt(dx * dx + dy * dy);
          
          if (distance <= 1.5) {
            const splashDamage = Math.floor(explosionDamage * 0.5);
            damageMonster(otherMonster, splashDamage, 'combo_explosion');
            showFloatingText(otherMonster.position.x, otherMonster.position.y, `溅射+${splashDamage}`, '#F59E0B');
          }
        });
        
        // 显示组合效果
        if (!monster.lastComboEffect || monster.lastComboEffect !== 'explosion') {
          showFloatingText(monster.position.x, monster.position.y, '火箭齐射!', '#F59E0B', 2);
          monster.lastComboEffect = 'explosion';
        }
      }
      
      // 4. 毒素腐蚀：毒素+腐蚀
      if (activeTypes.includes('toxin') && activeTypes.includes('corruptor')) {
        // 强化中毒效果
        if (!monster.isPoisoned || monster.poisonDamage < 40) {
          monster.isPoisoned = true;
          monster.poisonDamage = 40; // 每秒伤害提升
          monster.poisonDuration = 8; // 持续时间延长
          
          showFloatingText(monster.position.x, monster.position.y, '强化中毒!', '#10B981');
        }
        
        // 显示组合效果
        if (!monster.lastComboEffect || monster.lastComboEffect !== 'toxin') {
          showFloatingText(monster.position.x, monster.position.y, '毒素腐蚀!', '#10B981', 2);
          monster.lastComboEffect = 'toxin';
        }
      }
      
      // 5. 精准打击：狙击+穿刺
      if (activeTypes.includes('sniper') && activeTypes.includes('pierce')) {
        // 增加暴击率和穿透力
        const critChance = 0.5; // 50%暴击率
        if (Math.random() < critChance) {
          const critDamage = Math.floor(projectile.damage * 2);
          damageMonster(monster, critDamage, 'combo_crit');
          showFloatingText(monster.position.x, monster.position.y, `暴击!+${critDamage}`, '#EF4444');
        }
        
        // 显示组合效果
        if (!monster.lastComboEffect || monster.lastComboEffect !== 'precision') {
          showFloatingText(monster.position.x, monster.position.y, '精准打击!', '#EF4444', 2);
          monster.lastComboEffect = 'precision';
        }
      }
    }
    
    // 处理 projectile 命中
    function handleProjectileHit(projectile) {
      // 检查projectile对象有效性
      if (!projectile || !projectile.position) {
        return;
      }
      
      // 处理BOSS火箭弹，摧毁目标位置的炮塔
      if (projectile.isBossRocket) {
        // 寻找目标位置的炮塔
        if (!gameData.towers) gameData.towers = [];
        for (let j = gameData.towers.length - 1; j >= 0; j--) {
          const tower = gameData.towers[j];
          if (!tower || !tower.position) continue;
          
          const dx = tower.position.x - projectile.position.x;
          const dy = tower.position.y - projectile.position.y;
          const distance = Math.sqrt(dx * dx + dy * dy);
          
          if (distance <= 0.5) {
            // 从阻挡单元格中移除
            gameData.blockedCells.delete(`${tower.position.x},${tower.position.y}`);
            
            // 移除炮台
            gameData.towers.splice(j, 1);
          }
        }
        
        // 创建爆炸效果
        createExplosion(projectile.position.x, projectile.position.y, 1.5);
        
        // 伤害范围内的所有怪物
        gameData.monsters.forEach(monster => {
          if (!monster || !monster.position) return;
          
          const dx = monster.position.x - projectile.position.x;
          const dy = monster.position.y - projectile.position.y;
          const distance = Math.sqrt(dx * dx + dy * dy);
          
          if (distance <= 1.5) {
            damageMonster(monster, projectile.damage, projectile.sourceType || 'projectile');
          }
        });
        
        return;
      }
      
      // 处理新增炮台的特殊效果
      switch (projectile.type) {
        case 'gravity':
          // 重力波：范围减速和伤害
          createExplosion(projectile.position.x, projectile.position.y, 1);
          
          // 对范围内的怪物造成伤害并减速70%
          gameData.monsters.forEach(monster => {
            if (!monster || !monster.position) return;
            
            const dx = monster.position.x - projectile.position.x;
            const dy = monster.position.y - projectile.position.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            if (distance <= 1) {
              damageMonster(monster, projectile.damage, projectile.sourceType || 'projectile');
              
              // 减速效果
              if (!monster.isSlowed && monster.type !== 'mech') {
                monster.isSlowed = true;
                monster.originalSpeed = monster.speed;
                monster.speed *= 0.3; // 减速70%
                monster.slowDuration = 3; // 持续3秒
                
                // 创建重力效果
                showFloatingText(monster.position.x, monster.position.y - 1, '重力减速!', '#3B82F6');
              }
            }
          });
          break;
          
        case 'pulse':
          // 脉冲波：直线穿透并造成短暂停顿
          if (!projectile.tower || !projectile.tower.position || !projectile.direction) {
            break;
          }
          
          gameData.monsters.forEach(monster => {
            if (!monster || !monster.position) return;
            
            // 计算怪物到脉冲起点的向量
            const mx = monster.position.x - projectile.tower.position.x;
            const my = monster.position.y - projectile.tower.position.y;
            
            // 计算点积
            const dot = mx * projectile.direction.x + my * projectile.direction.y;
            
            // 如果点积小于0，怪物在反方向
            if (dot < 0) return;
            
            // 计算投影长度
            const projectionLength = dot;
            
            // 如果投影长度大于脉冲长度，怪物在脉冲范围外
            if (projectionLength > projectile.tower.range) return;
            
            // 计算怪物到脉冲线的距离
            const cross = mx * projectile.direction.y - my * projectile.direction.x;
            const distanceToLine = Math.abs(cross);
            
            // 如果距离小于0.5格，怪物在脉冲线上
            if (distanceToLine < 0.5) {
              damageMonster(monster, projectile.damage, projectile.sourceType || 'projectile');
              
              // 短暂停顿效果
              if (!monster.isStunned && monster.type !== 'mech') {
                monster.isStunned = true;
                monster.stunDuration = 0.5; // 短暂停顿0.5秒
                
                // 创建停顿效果
                showFloatingText(monster.position.x, monster.position.y - 1, '停顿!', '#F59E0B');
              }
            }
          });
          break;
          
        case 'plasma':
          // 等离子球：爆炸并造成灼烧效果
          createExplosion(projectile.position.x, projectile.position.y, 0.8);
          
          // 伤害范围内的所有怪物
          gameData.monsters.forEach(monster => {
            if (!monster || !monster.position) return;
            
            const dx = monster.position.x - projectile.position.x;
            const dy = monster.position.y - projectile.position.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            if (distance <= 0.8) {
              // 处理炮塔组合效果
              handleTowerComboEffect(monster, projectile);
              damageMonster(monster, projectile.damage, projectile.sourceType || 'projectile');
              
              // 灼烧效果
              if (!monster.isBurning) {
                monster.isBurning = true;
                monster.burnDamage = 15; // 每秒15点伤害
                monster.burnDuration = 4; // 持续4秒
                
                // 创建灼烧效果
                showFloatingText(monster.position.x, monster.position.y - 1, '灼烧!', '#EF4444');
              }
            }
          });
          break;
          
        case 'missile':
          // 导弹：高伤害，50%几率范围爆炸
          if (Math.random() < 0.5) {
            // 范围爆炸
            createExplosion(projectile.position.x, projectile.position.y, 1.2);
            
            // 伤害范围内的所有怪物
            gameData.monsters.forEach(monster => {
              const dx = monster.position.x - projectile.position.x;
              const dy = monster.position.y - projectile.position.y;
              const distance = Math.sqrt(dx * dx + dy * dy);
              
              if (distance <= 1.2) {
                damageMonster(monster, projectile.damage, projectile.sourceType || 'projectile');
              }
            });
            
            showFloatingText(projectile.position.x, projectile.position.y, '爆炸!', '#F59E0B');
          } else {
            // 单体高伤害
            const targetMonster = findClosestMonster(projectile.position.x, projectile.position.y, 0.5);
            if (targetMonster) {
              damageMonster(targetMonster, projectile.damage);
              showFloatingText(targetMonster.position.x, targetMonster.position.y, `-${projectile.damage}`, '#EF4444');
            }
          }
          break;
          
        case 'emp':
          // EMP波：对机械单位造成双倍伤害并瘫痪
          createExplosion(projectile.position.x, projectile.position.y, 1);
          
          // 伤害范围内的所有怪物
          gameData.monsters.forEach(monster => {
            const dx = monster.position.x - projectile.position.x;
            const dy = monster.position.y - projectile.position.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            if (distance <= 1) {
              // 对机械单位造成双倍伤害
              const damage = (monster.type === 'mech' || monster.type === 'spider' || monster.type === 'juggernaut') ? 
                            projectile.damage * 2 : projectile.damage;
              
              damageMonster(monster, damage);
              
              // 瘫痪效果
              if (!monster.isStunned && monster.type !== 'mech') {
                monster.isStunned = true;
                monster.stunDuration = 2; // 瘫痪2秒
                
                // 创建瘫痪效果
                showFloatingText(monster.position.x, monster.position.y - 1, 'EMP瘫痪!', '#8B5CF6');
              }
            }
          });
          break;
      }
      
      switch (projectile.type) {
        case 'normal':
          // 寻找附近的怪物
          const targetMonster = findClosestMonster(projectile.position.x, projectile.position.y, 0.5);
          if (targetMonster) {
            // 造成伤害
            damageMonster(targetMonster, projectile.damage);
            
            // 特殊效果
            if (projectile.towerType === 'ice') {
              // 减速效果
              if (!targetMonster.isSlowed && targetMonster.type !== 'mech') {
                targetMonster.isSlowed = true;
                targetMonster.originalSpeed = targetMonster.speed;
                targetMonster.speed *= 0.5;
                targetMonster.slowDuration = 5; // 5秒
                
                // 创建冻结效果
                createFreezeEffect(targetMonster.position.x, targetMonster.position.y);
              }
            } else if (projectile.towerType === 'sniper') {
              // 25%概率造成双倍伤害
              if (Math.random() < 0.25) {
                damageMonster(targetMonster, projectile.damage);
                showFloatingText(targetMonster.position.x, targetMonster.position.y, '暴击!', '#F59E0B');
              }
            }
          }
          break;
          
        case 'rocket':
          // 创建爆炸效果
          createExplosion(projectile.position.x, projectile.position.y, 0.3);
          
          // 伤害范围内的所有怪物
          gameData.monsters.forEach(monster => {
            const dx = monster.position.x - projectile.position.x;
            const dy = monster.position.y - projectile.position.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            if (distance <= 0.3) {
              damageMonster(monster, projectile.damage, projectile.sourceType || 'projectile');
            }
          });
          break;
          
        case 'electro':
          // 创建爆炸效果
          createExplosion(projectile.position.x, projectile.position.y, 0.2);
          
          // 伤害范围内的所有怪物并造成眩晕
          gameData.monsters.forEach(monster => {
            const dx = monster.position.x - projectile.position.x;
            const dy = monster.position.y - projectile.position.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            if (distance <= 0.2) {
              damageMonster(monster, projectile.damage, projectile.sourceType || 'projectile');
              
              // 眩晕效果
              if (!monster.isStunned && monster.type !== 'mech') {
                monster.isStunned = true;
                monster.stunDuration = 1; // 1秒
                
                // 创建眩晕效果
                createStunEffect(monster.position.x, monster.position.y);
              }
            }
          });
          break;
          
        case 'howitzer':
          // 创建超大爆炸效果（半径3）
          createExplosion(projectile.position.x, projectile.position.y, 3);
          
          // 伤害7x7范围内的所有怪物
          gameData.monsters.forEach(monster => {
            const dx = Math.abs(monster.position.x - projectile.position.x);
            const dy = Math.abs(monster.position.y - projectile.position.y);
            
            if (dx <= 3 && dy <= 3) {
              damageMonster(monster, projectile.damage, projectile.sourceType || 'projectile');
              showFloatingText(monster.position.x, monster.position.y, `-${projectile.damage}`, '#EF4444');
            }
          });
          
          // 显示超大范围伤害提示
          showFloatingText(projectile.position.x, projectile.position.y, '超大范围伤害!', '#F59E0B', 2);
          break;
          
        case 'toxin':
          // 寻找附近的怪物
          const toxinTarget = findClosestMonster(projectile.position.x, projectile.position.y, 0.5);
          if (toxinTarget) {
            // 造成伤害
            damageMonster(toxinTarget, projectile.damage);
            showFloatingText(toxinTarget.position.x, toxinTarget.position.y, `-${projectile.damage}`, '#EF4444');
            
            // 中毒效果
            if (!toxinTarget.isPoisoned) {
              toxinTarget.isPoisoned = true;
              toxinTarget.poisonDamage = 20; // 每秒伤害
              toxinTarget.poisonDuration = 5; // 5秒
              
              // 显示中毒提示
              showFloatingText(toxinTarget.position.x, toxinTarget.position.y, '中毒!', '#10B981');
            }
          }
          break;
      }
    }
    
    // 寻找最近的怪物
    function findClosestMonster(x, y, radius) {
      let closestMonster = null;
      let closestDistance = Infinity;
      
      gameData.monsters.forEach(monster => {
        const dx = monster.position.x - x;
        const dy = monster.position.y - y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        
        if (distance < closestDistance && distance <= radius) {
          closestDistance = distance;
          closestMonster = monster;
        }
      });
      
      return closestMonster;
    }
    
    // 小BOSS死亡时召唤怪物
    function summonMonstersOnDeath(miniBoss) {
      const summonCount = miniBoss.deathSummonCount || 8;
      const availableTypes = ['normal', 'fast', 'heavy', 'spider', 'swarmer', 'shield', 'healer', 'drone'];
      
      showFloatingText(miniBoss.position.x, miniBoss.position.y - 3, '临终召唤！', '#EF4444', 3);
      
      for (let i = 0; i < summonCount; i++) {
        // 随机选择怪物类型
        const summonType = availableTypes[Math.floor(Math.random() * availableTypes.length)];
        const monsterData = gameData.monsterTypes.find(m => m.id === summonType);
        
        if (monsterData) {
          const difficulty = gameData.difficultySettings && gameData.difficultySettings[gameData.difficulty] ? gameData.difficultySettings[gameData.difficulty] : gameData.difficultySettings.normal;
          const currentWaveMultiplier = 1 + gameData.currentWave * 0.1;
          
          const summonMonster = {
            id: `death-summon-${Date.now()}-${i}`,
            type: summonType,
            name: monsterData.name,
            health: monsterData.health * difficulty.monsterHealthMultiplier * currentWaveMultiplier * 0.6, // 血量降低40%
            maxHealth: monsterData.health * difficulty.monsterHealthMultiplier * currentWaveMultiplier * 0.6,
            speed: monsterData.speed * difficulty.monsterSpeedMultiplier * 1.2, // 速度提升20%
            coreDamage: monsterData.coreDamage * difficulty.monsterCoreDamageMultiplier,
            position: { 
              x: miniBoss.position.x + (Math.random() - 0.5) * 4, 
              y: miniBoss.position.y + (Math.random() - 0.5) * 4 
            },
            pathIndex: miniBoss.pathIndex,
            progress: miniBoss.progress,
            isFlying: summonType === 'drone',
            isStunned: false,
            isSlowed: false,
            slowDuration: 0,
            isElite: Math.random() < 0.3, // 30%几率是精英
            reward: monsterData.reward,
            isInvulnerable: false,
            invulnerableDuration: 0,
            canAttackTowers: true,
            // 死亡召唤的特殊标记
            isDeathSummon: true
          };
          
          gameData.monsters.push(summonMonster);
        }
      }
    }
    
    // 处理怪物特殊能力
    function handleMonsterSpecialAbilities(monster, deltaTime) {
      // 小BOSS特殊能力
      if (monster.isMiniBoss) {
        // 召唤小怪
        if (!monster.summonTimer) monster.summonTimer = 0;
        monster.summonTimer += deltaTime;
        
        if (monster.summonTimer >= 8 && monster.summonCount < monster.maxSummons) { // 每8秒召唤一次，最多3次
          monster.summonTimer = 0;
          monster.summonCount++;
          
          // 开始召唤动画
          monster.isSummoning = true;
          monster.summonProgress = 0;
          monster.summonDuration = 2; // 2秒召唤时间
          
          // 显示召唤提示
          showFloatingText(monster.position.x, monster.position.y - 2, '正在召唤小怪...', '#F59E0B');
        }
        
        // 处理召唤进度
        if (monster.isSummoning) {
          if (!monster.summonProgress) monster.summonProgress = 0;
          monster.summonProgress += deltaTime;
          
          if (monster.summonProgress >= monster.summonDuration) {
            // 召唤完成，生成小怪
            monster.isSummoning = false;
            
            // 生成3-6只不同种类的小怪
            const summonCount = 3 + Math.floor(Math.random() * 4);
            const summonTypes = ['normal', 'fast', 'heavy', 'spider', 'swarmer', 'shield', 'healer', 'drone'];
            
            for (let i = 0; i < summonCount; i++) {
              const summonType = summonTypes[Math.floor(Math.random() * summonTypes.length)];
              const monsterData = gameData.monsterTypes.find(m => m.id === summonType);
              
              if (monsterData) {
                const difficulty = gameData.difficultySettings && gameData.difficultySettings[gameData.difficulty] ? gameData.difficultySettings[gameData.difficulty] : gameData.difficultySettings.normal;
                const currentWaveMultiplier = 1 + gameData.currentWave * 0.1;
                
                const summonMonster = {
                  id: `summon-${Date.now()}-${i}`,
                  type: summonType,
                  name: monsterData.name,
                  health: monsterData.health * difficulty.monsterHealthMultiplier * currentWaveMultiplier * 0.7, // 召唤的怪物血量降低30%
                  maxHealth: monsterData.health * difficulty.monsterHealthMultiplier * currentWaveMultiplier * 0.7,
                  speed: monsterData.speed * difficulty.monsterSpeedMultiplier,
                  coreDamage: monsterData.coreDamage * difficulty.monsterCoreDamageMultiplier,
                  position: { 
                    x: monster.position.x + (Math.random() - 0.5) * 2, 
                    y: monster.position.y + (Math.random() - 0.5) * 2 
                  },
                  pathIndex: monster.pathIndex,
                  progress: monster.progress,
                  isFlying: summonType === 'drone',
                  isStunned: false,
                  isSlowed: false,
                  slowDuration: 0,
                  isElite: false,
                  reward: monsterData.reward,
                  isInvulnerable: false,
                  invulnerableDuration: 0,
                  canAttackTowers: true
                };
                
                gameData.monsters.push(summonMonster);
              }
            }
            
            // 显示召唤完成提示
            showFloatingText(monster.position.x, monster.position.y - 2, '小怪已召唤！', '#EF4444');
          }
        }
        
        // 护盾效果
        if (monster.isShielded && monster.shieldHealth > 0) {
          // 护盾减少50%伤害
          monster.damageReduction = 0.5;
        } else {
          monster.damageReduction = 0;
        }
      }
      
      switch(monster.type) {
        case 'corruptor':
          // 腐蚀者：腐蚀炮台装甲，使炮台攻击力降低30%，持续8秒
          if (!monster.corruptionTimer) monster.corruptionTimer = 0;
          monster.corruptionTimer += deltaTime;
          
          if (monster.corruptionTimer >= 3) { // 每3秒触发一次
            monster.corruptionTimer = 0;
            
            // 寻找附近的炮台
            const nearbyTowers = gameData.towers.filter(tower => {
              if (tower.isDestroyed) return false;
              const distance = Math.sqrt(
                Math.pow(tower.position.x - monster.position.x, 2) + 
                Math.pow(tower.position.y - monster.position.y, 2)
              );
              return distance <= 2; // 2格范围内的炮台
            });
            
            nearbyTowers.forEach(tower => {
              // 保存基础攻击力
              if (!tower.baseDamage) {
                tower.baseDamage = tower.damage;
              }
              
              // 应用腐蚀效果
              tower.damage = Math.floor(tower.baseDamage * 0.7); // 降低30%攻击力
              tower.corruptionEndTime = Date.now() + 8000; // 持续8秒
              
              // 显示腐蚀效果
              showFloatingText(tower.position.x, tower.position.y, '腐蚀!', '#EF4444');
            });
          }
          break;
          
        case 'juggernaut':
          // 重装战车：高防御，免疫减速效果
          monster.isSlowed = false; // 免疫减速
          monster.slowDuration = 0;
          
          // 每5秒对周围炮台造成伤害
          if (!monster.attackTimer) monster.attackTimer = 0;
          monster.attackTimer += deltaTime;
          
          if (monster.attackTimer >= 5) {
            monster.attackTimer = 0;
            
            // 对周围2格内的炮台造成伤害
            gameData.towers.forEach(tower => {
              if (tower.isDestroyed) return;
              const distance = Math.sqrt(
                Math.pow(tower.position.x - monster.position.x, 2) + 
                Math.pow(tower.position.y - monster.position.y, 2)
              );
              
              if (distance <= 2) {
                damageTower(tower, 20); // 造成20点伤害
                showFloatingText(tower.position.x, tower.position.y, '碾压!', '#EF4444');
              }
            });
          }
          break;
          
        case 'swarmer':
          // 蜂群无人机：优先攻击炮台
          monster.canAttackTowers = true;
          monster.towerAttackDamage = 5; // 对炮台伤害
          monster.towerAttackRange = 1; // 攻击范围
          monster.towerAttackCooldown = 1000; // 1秒攻击间隔
          break;
      }
    }
    
    // 更新己方单位
    function updateAllies(deltaTime) {
      try {
        // 检查数据有效性
        if (!gameData.allies || !Array.isArray(gameData.allies)) {
          gameData.allies = [];
          return;
        }
        
        if (!gameData.monsters || !Array.isArray(gameData.monsters)) {
          gameData.monsters = [];
          return;
        }
        
        // 确保deltaTime存在
        if (!deltaTime) {
          deltaTime = gameData.deltaTime || 0.016;
        }
        
        for (let i = gameData.allies.length - 1; i >= 0; i--) {
          const ally = gameData.allies[i];
          
          // 检查单位对象有效性
          if (!ally || typeof ally.x !== 'number' || typeof ally.y !== 'number') {
            console.error('无效的单位对象！', ally);
            gameData.allies.splice(i, 1);
            continue;
          }
          
          // 初始化单位属性
          if (!ally.attackTimer) ally.attackTimer = 0;
          if (!ally.pathIndex) ally.pathIndex = 0;
          if (ally.attackRange === undefined) {
            // 根据单位类型设置正确的攻击范围
            const defaultRanges = {
              archer: 4,
              mage: 3.5,
              spearman: 2.5,
              swordsman: 1.5,
              converter: 0,
              healer: 3,
              corrupted_minion: 2,
              converted: 2
            };
            ally.attackRange = defaultRanges[ally.type] || 1.5;
          }
          if (ally.attackSpeed === undefined) {
            // 根据单位类型设置正确的攻击速度
            const defaultSpeeds = {
              archer: 1.5,
              mage: 0.8,
              spearman: 1.0,
              swordsman: 1.2,
              converter: 0,
              healer: 0,
              corrupted_minion: 1.0,
              converted: 1.0
            };
            ally.attackSpeed = defaultSpeeds[ally.type] || 1;
          }
          if (ally.damage === undefined) {
            // 根据单位类型设置正确的伤害
            const defaultDamages = {
              archer: 25,
              mage: 40,
              spearman: 20,
              swordsman: 30,
              converter: 0,
              healer: 0,
              corrupted_minion: 15,
              converted: 15
            };
            ally.damage = defaultDamages[ally.type] || 10;
          }
          if (!ally.speed) {
            // 根据单位类型设置正确的速度
            const defaultSpeeds = {
              archer: 2,
              mage: 2.0,
              spearman: 2.2,
              swordsman: 2.5,
              converter: 3.5,
              healer: 2.0,
              corrupted_minion: 1.5,
              converted: 1.5
            };
            ally.speed = defaultSpeeds[ally.type] || 1;
          }
          if (ally.health === undefined) ally.health = 100;
          if (ally.maxHealth === undefined) ally.maxHealth = 100;
          if (!ally.healTimer) ally.healTimer = 0;
          if (!ally.selfHealTimer) ally.selfHealTimer = 0;
          
          // 检查单位是否死亡
          if (ally.health <= 0) {
            // 转换者特殊能力：死亡时将周围2格范围内的怪物变为己方单位
            if (ally.type === 'converter') {
              const convertRadius = 2;
              for (let j = gameData.monsters.length - 1; j >= 0; j--) {
                const monster = gameData.monsters[j];
                if (monster && monster.position && typeof monster.position.x === 'number' && typeof monster.position.y === 'number') {
                  const dx = monster.position.x - ally.x;
                  const dy = monster.position.y - ally.y;
                  const distance = Math.sqrt(dx * dx + dy * dy);
                  
                  if (distance <= convertRadius) {
                    // 创建新的己方单位（转换的怪物）
                    const convertedAlly = {
                      id: `converted_${Date.now()}_${j}`,
                      type: 'converted',
                      x: monster.position.x,
                      y: monster.position.y,
                      health: monster.health || 50,
                      maxHealth: monster.health || 50,
                      damage: monster.damage || 10,
                      speed: monster.speed || 1,
                      attackRange: 2,
                      attackSpeed: 1,
                      attackTimer: 0,
                      healTimer: 0,
                      selfHealTimer: 0
                    };
                    
                    gameData.allies.push(convertedAlly);
                    
                    // 显示转换效果
                    showFloatingText(monster.position.x, monster.position.y, '已转换', '#8B5CF6');
                    
                    // 移除被转换的怪物
                    gameData.monsters.splice(j, 1);
                  }
                }
              }
            }
            
            // 显示死亡效果
            const deathEffect = {
              type: 'unit_death',
              x: ally.x * gameData.cellSize + gameData.gridOffset.x + gameData.cellSize / 2,
              y: ally.y * gameData.cellSize + gameData.gridOffset.y + gameData.cellSize / 2,
              size: gameData.cellSize * 1.5,
              time: 0,
              duration: 1
            };
            gameData.effects.push(deathEffect);
            
            // 移除死亡的单位
            gameData.allies.splice(i, 1);
            continue;
          }
          
          // 转换者特殊处理：不攻击，只移动
          if (ally.type === 'converter') {
            // 转换者不需要攻击，直接沿路径移动
            if (gameData.path && Array.isArray(gameData.path)) {
              // 确保pathIndex有效
              if (ally.pathIndex < 0) ally.pathIndex = 0;
              if (ally.pathIndex >= gameData.path.length - 1) {
                continue;
              }
              
              const target = gameData.path[ally.pathIndex + 1];
              if (target && typeof target.x === 'number' && typeof target.y === 'number') {
                const dx = target.x - ally.x;
                const dy = target.y - ally.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance < 0.1) {
                  // 到达路径点，移动到下一个
                  ally.pathIndex++;
                  ally.x = target.x;
                  ally.y = target.y;
                } else {
                  // 向目标移动
                  const moveDistance = ally.speed * deltaTime * 0.15;
                  ally.x += (dx / distance) * moveDistance;
                  ally.y += (dy / distance) * moveDistance;
                }
              }
            }
            continue;
          }
          
          // 医疗兵特殊处理：治疗友方单位
          if (ally.type === 'healer') {
            ally.healTimer += deltaTime;
            if (ally.healTimer >= 2) { // 每2秒治疗一次
              for (const otherAlly of gameData.allies) {
                if (otherAlly !== ally && otherAlly.health < otherAlly.maxHealth && otherAlly.type !== 'converter') {
                  const dx = otherAlly.x - ally.x;
                  const dy = otherAlly.y - ally.y;
                  const distance = Math.sqrt(dx * dx + dy * dy);
                  
                  if (distance <= ally.attackRange) {
                    const healAmount = 20;
                    otherAlly.health = Math.min(otherAlly.maxHealth, otherAlly.health + healAmount);
                    
                    // 显示治疗文字
                    showFloatingText(otherAlly.x, otherAlly.y, `+${healAmount}`, '#10B981');
                    
                    // 创建治疗效果
                    const effect = {
                      type: 'heal',
                      x: otherAlly.x * gameData.cellSize + gameData.gridOffset.x + gameData.cellSize / 2,
                      y: otherAlly.y * gameData.cellSize + gameData.gridOffset.y + gameData.cellSize / 2,
                      size: 20,
                      time: 0
                    };
                    gameData.effects.push(effect);
                  }
                }
              }
              ally.healTimer = 0;
            }
            
            // 医疗兵沿路径移动
            if (gameData.path && Array.isArray(gameData.path)) {
              // 确保pathIndex有效
              if (ally.pathIndex < 0) ally.pathIndex = 0;
              if (ally.pathIndex >= gameData.path.length - 1) {
                continue;
              }
              
              const target = gameData.path[ally.pathIndex + 1];
              if (target && typeof target.x === 'number' && typeof target.y === 'number') {
                const dx = target.x - ally.x;
                const dy = target.y - ally.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance < 0.1) {
                  // 到达路径点，移动到下一个
                  ally.pathIndex++;
                  ally.x = target.x;
                  ally.y = target.y;
                } else {
                  // 向目标移动
                  const moveDistance = ally.speed * deltaTime * 0.15;
                  ally.x += (dx / distance) * moveDistance;
                  ally.y += (dy / distance) * moveDistance;
                }
              }
            }
            continue;
          }
          
          // 战斗单位的攻击和移动逻辑（弓箭手、剑士、法师、枪兵等）
          if (ally.attackRange > 0 && ally.damage > 0) {
            // 寻找敌人
            let closestMonster = null;
            let closestDistance = Infinity;
            
            // 遍历所有怪物，找到最近的可攻击目标
            for (let j = 0; j < gameData.monsters.length; j++) {
              const monster = gameData.monsters[j];
              
              // 检查怪物对象有效性
              if (!monster || !monster.position || typeof monster.position.x !== 'number' || 
                  typeof monster.position.y !== 'number' || typeof monster.health !== 'number' || 
                  monster.health <= 0) {
                continue;
              }
              
              const dx = monster.position.x - ally.x;
              const dy = monster.position.y - ally.y;
              const distance = Math.sqrt(dx * dx + dy * dy);
              
              if (distance <= ally.attackRange && distance < closestDistance) {
                closestMonster = monster;
                closestDistance = distance;
              }
            }
            
            // 如果找到攻击目标
            if (closestMonster) {
              // 攻击逻辑
              ally.attackTimer += deltaTime;
              const attackInterval = 1 / Math.max(0.1, ally.attackSpeed);
              
              if (ally.attackTimer >= attackInterval) {
                // 再次检查怪物是否仍然有效
                const currentDx = closestMonster.position.x - ally.x;
                const currentDy = closestMonster.position.y - ally.y;
                const currentDistance = Math.sqrt(currentDx * currentDx + currentDy * currentDy);
                
                if (closestMonster.health > 0 && currentDistance <= ally.attackRange && gameData.monsters.includes(closestMonster)) {
                  // 造成伤害
                  damageMonster(closestMonster, ally.damage, 'unit');
                  
                  // 法师特殊能力：范围伤害
                  if (ally.type === 'mage') {
                    const splashDamage = Math.floor(ally.damage * 0.5);
                    
                    for (const otherMonster of gameData.monsters) {
                      if (otherMonster && otherMonster !== closestMonster && otherMonster.health > 0 && 
                          otherMonster.position && closestMonster.position) {
                        const dx = otherMonster.position.x - closestMonster.position.x;
                        const dy = otherMonster.position.y - closestMonster.position.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        
                        if (distance <= 1) {
                          damageMonster(otherMonster, splashDamage, 'unit_splash');
                        }
                      }
                    }
                  }
                  
                  // 创建攻击效果
                  const attackEffect = {
                    type: 'attack',
                    x: ally.x * gameData.cellSize + gameData.gridOffset.x + gameData.cellSize / 2,
                    y: ally.y * gameData.cellSize + gameData.gridOffset.y + gameData.cellSize / 2,
                    targetX: closestMonster.position.x * gameData.cellSize + gameData.gridOffset.x + gameData.cellSize / 2,
                    targetY: closestMonster.position.y * gameData.cellSize + gameData.gridOffset.y + gameData.cellSize / 2,
                    duration: 0.3,
                    time: 0
                  };
                  gameData.effects.push(attackEffect);
                  
                  ally.attackTimer = 0;
                }
              }
              
              // 如果在攻击范围内，停止移动
              if (closestDistance <= 0.3) {
                continue;
              }
            }
            
            // 移动逻辑：如果没有攻击目标或目标太远，沿路径移动
            if (gameData.path && Array.isArray(gameData.path)) {
              // 确保pathIndex有效
              if (ally.pathIndex < 0) ally.pathIndex = 0;
              if (ally.pathIndex >= gameData.path.length - 1) {
                continue;
              }
              
              const target = gameData.path[ally.pathIndex + 1];
              if (target && typeof target.x === 'number' && typeof target.y === 'number') {
                const dx = target.x - ally.x;
                const dy = target.y - ally.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance < 0.1) {
                  // 到达路径点，移动到下一个
                  ally.pathIndex++;
                  ally.x = target.x;
                  ally.y = target.y;
                } else {
                  // 向目标移动
                  const moveDistance = ally.speed * deltaTime * 0.15;
                  ally.x += (dx / distance) * moveDistance;
                  ally.y += (dy / distance) * moveDistance;
                }
              }
            }
          }
        }
      } catch (error) {
        console.error('更新单位时出错:', error);
      }
    }
    
    function updateMonsters() {
      // 预缓存盾牌怪物列表，提高后续查询性能
      gameData.shieldMonsters = [];
      if (!gameData.monsters) gameData.monsters = [];
      for (let i = 0; i < gameData.monsters.length; i++) {
        if (gameData.monsters[i].type === 'shield' && gameData.monsters[i].health > 0) {
          gameData.shieldMonsters.push(gameData.monsters[i]);
        }
      }
      
      if (!gameData.monsters) gameData.monsters = [];
      for (let i = gameData.monsters.length - 1; i >= 0; i--) {
        const monster = gameData.monsters[i];
        
        // 检查怪物对象有效性
        if (!monster || !monster.position || typeof monster.position.x !== 'number' || typeof monster.position.y !== 'number') {
          console.error('无效的怪物对象！', monster);
          gameData.monsters.splice(i, 1);
          continue;
        }
        
        // 初始化怪物属性
        if (!monster.attackTimer) monster.attackTimer = 0;
        if (!monster.attackRange) monster.attackRange = 1.5;
        if (!monster.attackSpeed) monster.attackSpeed = 1;
        
        // 根据怪物类型设置特定属性
        if (monster.type === 'heavy') {
          monster.damage = 30; // 重装士兵伤害更高
          monster.attackRange = 1.5;
          monster.attackSpeed = 0.8; // 攻击速度稍慢
        } else if (!monster.damage) {
          monster.damage = 20; // 默认伤害
        }
        
        if (!monster.speed) monster.speed = 1;
        
        // 寻找附近的单位进行攻击
        let closestAlly = null;
        let closestDistance = Infinity;
        
        if (gameData.allies && Array.isArray(gameData.allies)) {
          for (const ally of gameData.allies) {
            if (!ally || typeof ally.x !== 'number' || typeof ally.y !== 'number' || typeof ally.health !== 'number') {
              continue;
            }
            
            // 允许重装士兵攻击转换者
            // 移除之前的限制
            
            const dx = ally.x - monster.position.x;
            const dy = ally.y - monster.position.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            if (distance <= monster.attackRange && distance < closestDistance) {
              closestAlly = ally;
              closestDistance = distance;
            }
          }
        }
        
        // 如果找到单位，攻击单位
        if (closestAlly) {
          monster.attackTimer += 0.016; // 假设60FPS，deltaTime约为0.016
          
          const attackInterval = 1 / monster.attackSpeed;
          
          if (monster.attackTimer >= attackInterval) {
            // 对单位造成伤害
            console.log('怪物攻击单位，造成伤害:', monster.damage, '单位类型:', closestAlly.type, '攻击前生命值:', closestAlly.health);
            
            // 对所有单位造成正常伤害
            const damageDealt = monster.damage;
            closestAlly.health = Math.max(0, closestAlly.health - damageDealt);
            
            // 显示伤害文本
            showFloatingText(closestAlly.x, closestAlly.y, `-${Math.round(damageDealt)}`, '#EF4444');
            
            console.log('攻击后生命值:', closestAlly.health);
            
            // 创建攻击效果
            const attackEffect = {
              type: 'monster_attack',
              x: monster.position.x * gameData.cellSize + gameData.gridOffset.x + gameData.cellSize / 2,
              y: monster.position.y * gameData.cellSize + gameData.gridOffset.y + gameData.cellSize / 2,
              targetX: closestAlly.x * gameData.cellSize + gameData.gridOffset.x + gameData.cellSize / 2,
              targetY: closestAlly.y * gameData.cellSize + gameData.gridOffset.y + gameData.cellSize / 2,
              duration: 0.3,
              time: 0
            };
            gameData.effects.push(attackEffect);
            
            monster.attackTimer = 0;
          }
        }
        
        // 处理特殊怪物能力
        handleMonsterSpecialAbilities(monster, 0.016); // 假设60FPS，deltaTime约为0.016
        
        // 检查是否死亡
        if (monster.health <= 0) {
          // 检查是否是爆破兵
          if (monster.type === 'bomber' && !monster.isBomberActivated) {
            // 不爆炸
          }
          
          // 添加金钱
          let money = (gameData.difficultySettings && gameData.difficultySettings[gameData.difficulty] ? gameData.difficultySettings[gameData.difficulty].moneyPerKill : 20);
          
          // 根据怪物类型调整金钱奖励
          if (monster.isMiniBoss) {
            // 小BOSS奖励：基础值 + 波数 * 100
            money = 2000 + gameData.currentWave * 100;
          } else if (monster.isElite) {
            // 精英怪物奖励：基础值 * 5
            money *= 5;
          } else if (monster.type === 'boss') {
            // 最终BOSS奖励：基础值 * 10
            money *= 10;
          } else if (['stealth', 'reaper', 'assassin', 'charger', 'juggernaut', 'corruptor'].includes(monster.type)) {
            // 稀有怪物奖励：基础值 * 3
            money *= 3;
          } else if (['heavy', 'shield', 'healer', 'drone', 'bomber', 'mech', 'thief', 'spider', 'swarmer'].includes(monster.type)) {
            // 特殊怪物奖励：基础值 * 2
            money *= 2;
          }
          
          // 应用难度系数
          money = Math.floor(money * (gameData.difficultySettings && gameData.difficultySettings[gameData.difficulty] ? gameData.difficultySettings[gameData.difficulty].moneyMultiplier : 1.0));
          
          gameData.money += money;
          updateGameInfo();
          
          // 显示浮动文本
          showFloatingText(monster.position.x, monster.position.y, `+${money}`, '#10B981');
          
          // 更新任务进度 - 怪物击杀
          updateMissionProgress('monster_killed', { killerType: monster.lastKillerType || 'unknown' });
          
          // 添加科技点
          let techPoints = 0;
          
          // 根据怪物类型调整科技点奖励
          if (monster.isMiniBoss) {
            // 小BOSS奖励：大量科技点
            techPoints = gameData.techSystem.techPointsPerKill['mini-boss'];
          } else if (monster.type === 'boss') {
            // 最终BOSS奖励：海量科技点
            techPoints = gameData.techSystem.techPointsPerKill.boss;
          } else if (['stealth', 'reaper', 'assassin', 'charger'].includes(monster.type)) {
            // 稀有怪物奖励：较多科技点
            techPoints = gameData.techSystem.techPointsPerKill[monster.type] || 3;
          } else if (['heavy', 'shield', 'healer', 'drone', 'bomber', 'mech', 'thief'].includes(monster.type)) {
            // 特殊怪物奖励：中等科技点
            techPoints = gameData.techSystem.techPointsPerKill[monster.type] || 2;
          } else {
            // 普通怪物奖励：少量科技点
            techPoints = gameData.techSystem.techPointsPerKill[monster.type] || 1;
          }
          
          // 精英怪物额外奖励
          if (monster.isElite) {
            techPoints *= 2;
          }
          
          // 应用难度系数（难度越高，科技点越多）
          const difficultyMultipliers = {
            easy: 0.8,
            normal: 1.0,
            hard: 1.2,
            hell: 1.5
          };
          techPoints = Math.floor(techPoints * difficultyMultipliers[gameData.difficulty] || 1.0);
          
          gameData.techSystem.techPoints += techPoints;
          
          // 显示科技点浮动文本
          showFloatingText(monster.position.x, monster.position.y - 20, `+${techPoints}科技点`, '#8B5CF6');
          
          // 更新科技点显示
          updateTechPointsDisplay();
          
          // 播放敌人死亡音效
          soundManager.playSound('enemyDieSound');
          
          // 检查是否是BOSS
          if (monster.type === gameData.waveSettings.bossMonster) {
            // 隐藏BOSS血条
            bossHealthBar.classList.add('hidden');
            bossHealthText.classList.add('hidden');
            gameData.currentBoss = null;
          }
          
          // 检查是否是小BOSS
          if (monster.isMiniBoss) {
            // 增加量子炮解锁计数器
            gameData.quantumTowerUnlockedCount = gameData.quantumTowerUnlockedCount+ 1;
            
            // 显示小BOSS击杀通知
            showFloatingText(monster.position.x, monster.position.y, 'BOSS已击败！', '#F59E0B', 2);
            
            // 播放BOSS死亡音效
            soundManager.playSound('bossDieSound');
            
            // 死亡时召唤大量怪物
            summonMonstersOnDeath(monster);
            
            // 检查是否解锁量子炮
            if (gameData.quantumTowerUnlockedCount >= 5) {
              // 解锁量子炮
              gameData.towerTypes.forEach(tower => {
                if (tower.id === 'quantum') {
                  tower.unlocked = true;
                }
              });
              
              // 检查是否已经显示过解锁通知
              if (!gameData.quantumTowerNotificationShown) {
                // 量子塔解锁通知函数
                function showQuantumTowerUnlockedNotification() {
                  const notification = document.createElement('div');
                  notification.className = 'quantum-unlock-notification';
                  notification.innerHTML = `
                    <div class="quantum-unlock-content">
                      <h3>🎉 量子塔已解锁！</h3>
                      <p>恭喜你获得了传说中的量子塔！</p>
                      <p>这个强大的炮塔可以操控时间和空间！</p>
                    </div>
                  `;
                  
                  // 添加样式
                  Object.assign(notification.style, {
                    position: 'fixed',
                    top: '0',
                    left: '0',
                    width: '100%',
                    height: '100%',
                    backgroundColor: 'rgba(0, 0, 0, 0.8)',
                    display: 'flex',
                    justifyContent: 'center',
                    alignItems: 'center',
                    zIndex: '10000',
                    animation: 'fadeIn 0.5s ease-in-out'
                  });
                  
                  Object.assign(notification.querySelector('.quantum-unlock-content').style, {
                    backgroundColor: '#1e293b',
                    padding: '2rem',
                    borderRadius: '1rem',
                    textAlign: 'center',
                    color: 'white',
                    maxWidth: '400px',
                    boxShadow: '0 0 20px rgba(139, 92, 246, 0.5)'
                  });
                  
                  document.body.appendChild(notification);
                  
                  // 3秒后自动关闭
                  setTimeout(() => {
                    notification.style.animation = 'fadeOut 0.5s ease-in-out';
                    setTimeout(() => {
                      if (notification.parentNode) {
                        notification.parentNode.removeChild(notification);
                      }
                    }, 500);
                  }, 3000);
                }
                
                // 显示解锁通知
                showQuantumTowerUnlockedNotification();
                gameData.quantumTowerNotificationShown = true;
              }
              
              // 更新游戏信息
              updateGameInfo();
            } else {
              // 更新游戏信息，显示解锁进度
              updateGameInfo();
            }
          }
          
          // 移除怪物（在所有奖励处理完成后）
          gameData.monsters.splice(i, 1);
          
          continue;
        }
        
        // 检查状态效果
        if (monster.isStunned) {
          monster.stunDuration -= gameData.deltaTime;
          if (monster.stunDuration <= 0) {
            monster.isStunned = false;
          } else {
            // 眩晕状态下不移动
            continue;
          }
        }
        
        if (monster.isSlowed) {
          monster.slowDuration -= gameData.deltaTime;
          if (monster.slowDuration <= 0) {
            monster.isSlowed = false;
            monster.speed = monster.originalSpeed;
          }
        }
        
        if (monster.isPoisoned) {
          monster.poisonDuration -= gameData.deltaTime;
          // 每秒造成伤害
          damageMonster(monster, monster.poisonDamage * gameData.deltaTime);
          
          // 显示中毒伤害文本
          if (Math.random() < 0.2) { // 减少文本数量，避免过多
            showFloatingText(monster.position.x, monster.position.y, `-${Math.round(monster.poisonDamage * gameData.deltaTime)}`, '#10B981', 0.5);
          }
          
          if (monster.poisonDuration <= 0) {
            monster.isPoisoned = false;
          }
        }
        
        if (monster.isBurning) {
          monster.burnDuration -= gameData.deltaTime;
          // 每秒造成伤害
          damageMonster(monster, monster.burnDamage * gameData.deltaTime);
          
          // 显示灼烧伤害文本
          if (Math.random() < 0.2) { // 减少文本数量，避免过多
            showFloatingText(monster.position.x, monster.position.y, `-${Math.round(monster.burnDamage * gameData.deltaTime)}`, '#EF4444', 0.5);
          }
          
          if (monster.burnDuration <= 0) {
            monster.isBurning = false;
          }
        }
        
        if (monster.isInvulnerable) {
          monster.invulnerableDuration -= gameData.deltaTime;
          if (monster.invulnerableDuration <= 0) {
            monster.isInvulnerable = false;
            // 恢复原来的速度
            if (monster.originalSpeed !== undefined) {
              monster.speed = monster.originalSpeed;
              monster.originalSpeed = undefined;
            }
          }
        }
        
        // 更新刺客无敌技能冷却时间
        if (monster.type === 'assassin' && monster.invulnerableCooldown > 0) {
          monster.invulnerableCooldown -= gameData.deltaTime;
        }
        
        // 特殊怪物效果
        if (monster.type === 'spider') {
          // 机械蜘蛛：20%几率闪避攻击
          monster.dodgeChance = 0.2;
        } else if (monster.type === 'juggernaut') {
          // 重装战车：免疫减速效果
          monster.isSlowed = false;
        } else if (monster.type === 'swarmer') {
          // 蜂群无人机：优先攻击炮台
          // 在怪物攻击炮塔函数中处理
        } else if (monster.type === 'corruptor') {
          // 腐蚀者：腐蚀炮台装甲
          monster.corruptionTimer = (monster.corruptionTimer || 0) + gameData.deltaTime;
          if (monster.corruptionTimer >= 3) { // 每3秒触发一次
            monster.corruptionTimer = 0;
            
            // 寻找附近的炮台
            gameData.towers.forEach(tower => {
              const dx = tower.position.x - monster.position.x;
              const dy = tower.position.y - monster.position.y;
              const distance = Math.sqrt(dx * dx + dy * dy);
              
              if (distance <= 2) { // 2格范围内
                // 降低炮台攻击力30%，持续8秒
                if (!tower.isCorrupted) {
                  tower.isCorrupted = true;
                  tower.originalDamage = tower.damage;
                  tower.damage *= 0.7;
                  tower.corruptionDuration = 8;
                  
                  // 显示腐蚀效果
                  showFloatingText(tower.position.x, tower.position.y - 1, '装甲腐蚀!', '#8B5CF6');
                }
              }
            });
          }
        } else if (monster.type === 'bomber') {
          // 爆破兵倒计时
          monster.bomberTimer -= gameData.deltaTime;
          if (monster.bomberTimer <= 0 && !monster.isBomberActivated) {
            monster.isBomberActivated = true;
            
            // 创建爆炸效果
            createExplosion(monster.position.x, monster.position.y, 1.5);
            
            // 摧毁3x3范围内的炮台
            if (!gameData.towers) gameData.towers = [];
        for (let j = gameData.towers.length - 1; j >= 0; j--) {
              const tower = gameData.towers[j];
              const dx = tower.position.x - monster.position.x;
              const dy = tower.position.y - monster.position.y;
              const distance = Math.sqrt(dx * dx + dy * dy);
              
              if (distance <= 1.5) {
                // 从阻挡单元格中移除
                gameData.blockedCells.delete(`${tower.position.x},${tower.position.y}`);
                
                // 移除炮台
                gameData.towers.splice(j, 1);
              }
            }
            
            // 移除怪物
            gameData.monsters.splice(i, 1);
            continue;
          }
        } else if (monster.type === 'healer') {
          // 医疗兵治疗
          monster.healerTimer -= gameData.deltaTime;
          if (monster.healerTimer <= 0) {
            // 治疗全场怪物
            gameData.monsters.forEach(m => {
              if (m.health < m.maxHealth) {
                m.health = Math.min(m.maxHealth, m.health + 15);
              }
            });
            
            monster.healerTimer = 1; // 每秒治疗一次
          }
        } else if (monster.type === 'reaper') {
          // 收割者发射激光
          monster.reaperTimer -= gameData.deltaTime;
          if (monster.reaperTimer <= 0) {
            // 随机方向
            const directions = [
              { x: 0, y: -1 }, // 上
              { x: 0, y: 1 },  // 下
              { x: -1, y: 0 }, // 左
              { x: 1, y: 0 }   // 右
            ];
            const direction = directions[Math.floor(Math.random() * directions.length)];
            
            // 创建激光效果
            const startX = gameData.gridOffset.x + monster.position.x * gameData.cellSize + gameData.cellSize / 2;
            const startY = gameData.gridOffset.y + monster.position.y * gameData.cellSize + gameData.cellSize / 2;
            const endX = startX + direction.x * 3 * gameData.cellSize;
            const endY = startY + direction.y * 3 * gameData.cellSize;
            
            createLaser(startX, startY, endX, endY);
            
            // 摧毁激光路径上的炮台
            for (let j = 1; j <= 3; j++) {
              const x = monster.position.x + direction.x * j;
              const y = monster.position.y + direction.y * j;
              
              // 检查是否在网格范围内
              if (x >= 0 && x < gameData.gridSize.width && y >= 0 && y < gameData.gridSize.height) {
                // 检查是否有炮台
                if (!gameData.towers) gameData.towers = [];
                for (let k = gameData.towers.length - 1; k >= 0; k--) {
                  const tower = gameData.towers[k];
                  if (tower.position.x === x && tower.position.y === y) {
                    // 从阻挡单元格中移除
                    gameData.blockedCells.delete(`${tower.position.x},${tower.position.y}`);
                    
                    // 移除炮台
                    gameData.towers.splice(k, 1);
                    break;
                  }
                }
              }
            }
            
            monster.reaperTimer = 3; // 每3秒发射一次
          }
        } else if (monster.type === gameData.waveSettings.bossMonster) {
          // BOSS特殊效果 - 优化性能
          // 减少召唤频率和数量
          monster.summonTimer -= gameData.deltaTime;
          if (monster.summonTimer <= 0 && gameData.monsters && gameData.monsters.length < 30) { // 限制最多30个怪物同时存在
            // 随机选择一个怪物类型
            const monsterType = gameData.waveSettings.allMonsters[Math.floor(Math.random() * gameData.waveSettings.allMonsters.length)];
            const monsterData = gameData.monsterTypes.find(m => m.id === monsterType);
            
            // 应用难度乘数
            const difficulty = gameData.difficultySettings && gameData.difficultySettings[gameData.difficulty] ? gameData.difficultySettings[gameData.difficulty] : gameData.difficultySettings.normal;
            const health = monsterData.health * difficulty.monsterHealthMultiplier * (1 + gameData.currentWave * 0.05);
            const speed = monsterData.speed * difficulty.monsterSpeedMultiplier;
            const coreDamage = monsterData.coreDamage * difficulty.monsterCoreDamageMultiplier;
            
            // 创建怪物
            const newMonster = {
              id: `monster-${Date.now()}-${gameData.monsters ? gameData.monsters.length : 0}`,
              type: monsterType,
              name: monsterData.name,
              health: health,
              maxHealth: health,
              speed: speed,
              coreDamage: coreDamage,
              position: { x: monster.position.x, y: monster.position.y },
              pathIndex: monster.pathIndex,
              progress: monster.progress,
              isFlying: monsterType === 'drone',
              isStunned: false,
              isSlowed: false,
              slowDuration: 0,
              isInvulnerable: false,
              invulnerableDuration: 0,
              isBomberActivated: false,
              bomberTimer: 5,
              healerTimer: 0,
              reaperTimer: 0,
              iceMageTimer: 0
            };
            
            gameData.monsters.push(newMonster);
            
            monster.summonTimer = 8; // 增加召唤间隔到8秒
          }
          
          // 发射火箭弹 - 减少发射频率和数量
          monster.rocketTimer -= gameData.deltaTime;
          if (monster.rocketTimer <= 0 && gameData.towers && gameData.towers.length > 0) {
            // 选择1-2个炮台，减少火箭弹数量
            const rocketCount = gameData.towers && gameData.towers.length > 5 ? 2 : 1;
            const targetTowers = [];
            const availableTowers = [...gameData.towers];
            
            for (let j = 0; j < rocketCount && availableTowers.length > 0; j++) {
              const index = Math.floor(Math.random() * availableTowers.length);
              targetTowers.push(availableTowers[index]);
              availableTowers.splice(index, 1);
            }
            
            // 发射火箭弹
            targetTowers.forEach(tower => {
              const projectile = {
                type: 'rocket',
                towerType: 'rocket',
                damage: 1000, // 极高伤害，通常一击摧毁炮台
                position: { ...monster.position },
                target: { ...tower.position },
                speed: 3.5, // 格/秒
                isBossRocket: true
              };
              
              gameData.projectiles.push(projectile);
            });
            
            monster.rocketTimer = 8; // 增加发射间隔到8秒
          }
          
          // 更新BOSS血条（使用deltaTime控制更新频率，避免使用Date.now()）
          if (!gameData.lastBossHealthUpdate) gameData.lastBossHealthUpdate = 0;
          gameData.lastBossHealthUpdate += gameData.deltaTime;
          if (gameData.lastBossHealthUpdate >= 0.2) { // 每0.2秒更新一次
            updateBossHealthBar();
            gameData.lastBossHealthUpdate = 0;
          }
        }
        
        // 移动怪物（如果没有正在攻击单位）
        if (!monster.isStunned && !closestAlly) {
          if (monster.isFlying) {
            // 飞行怪物直接飞向终点
            const endPoint = gameData.path[gameData.path.length - 1];
            const dx = endPoint.x - monster.position.x;
            const dy = endPoint.y - monster.position.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            if (distance < 0.3) {
              // 到达终点
              damageCore(monster.coreDamage);
              gameData.monsters.splice(i, 1);
            } else {
              // 移动怪物 - 调整速度
              const speed = monster.speed * gameData.deltaTime * 0.15;
              monster.position.x += (dx / distance) * speed;
              monster.position.y += (dy / distance) * speed;
            }
          } else {
            // 地面怪物沿路径移动
            if (monster.pathIndex < gameData.path.length - 1) {
              const currentPoint = gameData.path[monster.pathIndex];
              const nextPoint = gameData.path[monster.pathIndex + 1];
              
              // 计算方向
              const dx = nextPoint.x - currentPoint.x;
              const dy = nextPoint.y - currentPoint.y;
              const distance = Math.sqrt(dx * dx + dy * dy);
              
              // 更新进度 - 调整速度
              monster.progress += monster.speed * gameData.deltaTime * 0.15;
              
              // 检查是否到达下一个点
              if (monster.progress >= distance) {
                monster.pathIndex++;
                monster.progress = 0;
              } else {
                // 计算当前位置
                const progressRatio = monster.progress / distance;
                monster.position.x = currentPoint.x + dx * progressRatio;
                monster.position.y = currentPoint.y + dy * progressRatio;
              }
            } else {
              // 到达终点
              damageCore(monster.coreDamage);
              gameData.monsters.splice(i, 1);
            }
          }
        }
      }
    }
    
    // 伤害怪物
    function damageMonster(monster, damage, sourceType = 'unknown') {
      // 检查怪物对象有效性
      if (!monster || typeof monster.health !== 'number') {
        console.error('无效的怪物对象:', monster);
        return;
      }
      
      if (monster.isInvulnerable) return;
      
      console.log(`对怪物造成伤害: ${damage} (来源: ${sourceType})`);
      console.log(`怪物当前生命值: ${monster.health}`);
      
      // 检查是否有盾牌士兵保护 - 优化性能
      let isProtected = false;
      if (monster.type !== 'shield' && gameData.shieldMonsters && gameData.shieldMonsters.length > 0) {
        // 使用预缓存的盾牌怪物列表
        for (let i = 0; i < gameData.shieldMonsters.length; i++) {
          const shieldMonster = gameData.shieldMonsters[i];
          if (!shieldMonster || shieldMonster.health <= 0) continue;
          
          // 检查位置属性是否存在
          if (monster.position && shieldMonster.position) {
            const dx = monster.position.x - shieldMonster.position.x;
            const dy = monster.position.y - shieldMonster.position.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            if (distance <= 1) {
              isProtected = true;
              console.log('怪物受到盾牌保护，伤害减免90%');
              break; // 找到一个就够了
            }
          }
        }
      }
      
      // 应用伤害
      let actualDamage = damage;
      if (isProtected) {
        actualDamage = damage * 0.1; // 90%免伤
        monster.health -= actualDamage;
      } else if (monster.isMiniBoss && monster.isShielded) {
        // 记录最后一次造成伤害的来源类型
        monster.lastKillerType = sourceType;
        // 小BOSS护盾效果
        if (monster.shieldHealth > 0) {
          // 护盾吸收伤害
          monster.shieldHealth -= damage;
          actualDamage = 0; // 护盾吸收所有伤害
          
          console.log(`小BOSS护盾吸收伤害: ${damage}, 剩余护盾值: ${monster.shieldHealth}`);
          
          // 显示护盾伤害文本
          if (monster.position) {
            showFloatingText(monster.position.x, monster.position.y, `-${Math.round(damage)}`, '#3B82F6');
          }
          
          // 创建小BOSS击中效果
          if (monster.position && typeof createMiniBossHitEffect === 'function') {
            createMiniBossHitEffect(monster.position.x, monster.position.y);
          }
          
          // 检查护盾是否被打破
          if (monster.shieldHealth <= 0) {
            monster.isShielded = false;
            monster.shieldHealth = 0;
            console.log('小BOSS护盾已打破!');
            
            // 显示护盾打破通知
            if (monster.position) {
              showFloatingText(monster.position.x, monster.position.y, '护盾已打破!', '#EF4444');
            }
          }
          
          return; // 不减少生命值
        } else {
          // 护盾已打破，直接伤害生命值
          monster.health -= damage;
          // 记录最后一次造成伤害的来源类型
          monster.lastKillerType = sourceType;
        }
      } else {
        monster.health -= damage;
        // 记录最后一次造成伤害的来源类型
        monster.lastKillerType = sourceType;
      }
      
      // 确保怪物生命值不会低于0
      monster.health = Math.max(0, monster.health);
      
      console.log(`怪物受到实际伤害: ${actualDamage}, 剩余生命值: ${monster.health}`);
      
      // 显示伤害文本
      if (monster.position && !isProtected && !(monster.isMiniBoss && monster.isShielded)) {
        showFloatingText(monster.position.x, monster.position.y, `-${Math.round(damage)}`, '#EF4444');
      }
      
      // 播放敌人被击中音效
      if (soundManager && soundManager.playSound) {
        soundManager.playSound('enemyHitSound');
      }
      
      // 检查怪物是否死亡
      if (monster.health <= 0) {
        console.log(`怪物 ${monster.type} 已死亡! 生命值: ${monster.health}, 来源: ${sourceType}`);
        
        // 找到怪物在数组中的索引并移除
        const monsterIndex = gameData.monsters.indexOf(monster);
        if (monsterIndex !== -1) {
          console.log(`从怪物数组中移除怪物，索引: ${monsterIndex}, 类型: ${monster.type}`);
          
          // 添加金钱
          let money = (gameData.difficultySettings && gameData.difficultySettings[gameData.difficulty] ? gameData.difficultySettings[gameData.difficulty].moneyPerKill : 20);
          
          // 根据怪物类型调整金钱奖励
          if (monster.isMiniBoss) {
            // 小BOSS奖励：基础值 + 波数 * 100
            money = 2000 + gameData.currentWave * 100;
          } else if (monster.isElite) {
            // 精英怪物奖励：基础值 * 5
            money *= 5;
          } else if (monster.type === 'boss') {
            // 最终BOSS奖励：基础值 * 10
            money *= 10;
          } else if (['stealth', 'reaper', 'assassin', 'charger', 'juggernaut', 'corruptor'].includes(monster.type)) {
            // 稀有怪物奖励：基础值 * 3
            money *= 3;
          } else if (['heavy', 'shield', 'healer', 'drone', 'bomber', 'mech', 'thief', 'spider', 'swarmer'].includes(monster.type)) {
            // 特殊怪物奖励：基础值 * 2
            money *= 2;
          }
          
          // 应用难度系数
          money = Math.floor(money * (gameData.difficultySettings && gameData.difficultySettings[gameData.difficulty] ? gameData.difficultySettings[gameData.difficulty].moneyMultiplier : 1.0));
          
          gameData.money += money;
          updateGameInfo();
          
          // 显示浮动文本
          if (monster.position) {
            showFloatingText(monster.position.x, monster.position.y, `+${money}`, '#10B981');
          }
          
          // 更新任务进度 - 怪物击杀
          updateMissionProgress('monster_killed', { killerType: monster.lastKillerType || 'unknown' });
          
          // 添加科技点
          let techPoints = 0;
          
          // 根据怪物类型调整科技点奖励
          if (monster.isMiniBoss) {
            // 小BOSS奖励：大量科技点
            techPoints = gameData.techSystem.techPointsPerKill['mini-boss'];
          } else if (monster.type === 'boss') {
            // 最终BOSS奖励：海量科技点
            techPoints = gameData.techSystem.techPointsPerKill.boss;
          } else if (['stealth', 'reaper', 'assassin', 'charger'].includes(monster.type)) {
            // 稀有怪物奖励：较多科技点
            techPoints = gameData.techSystem.techPointsPerKill[monster.type] || 3;
          } else if (['heavy', 'shield', 'healer', 'drone', 'bomber', 'mech', 'thief'].includes(monster.type)) {
            // 特殊怪物奖励：中等科技点
            techPoints = gameData.techSystem.techPointsPerKill[monster.type] || 2;
          } else {
            // 普通怪物奖励：少量科技点
            techPoints = gameData.techSystem.techPointsPerKill[monster.type] || 1;
          }
          
          // 精英怪物额外奖励
          if (monster.isElite) {
            techPoints *= 2;
          }
          
          // 应用难度系数（难度越高，科技点越多）
          const difficultyMultipliers = {
            easy: 0.8,
            normal: 1.0,
            hard: 1.2,
            hell: 1.5
          };
          techPoints = Math.floor(techPoints * difficultyMultipliers[gameData.difficulty] || 1.0);
          
          gameData.techSystem.techPoints += techPoints;
          
          // 显示科技点浮动文本
          if (monster.position) {
            showFloatingText(monster.position.x, monster.position.y - 20, `+${techPoints}科技点`, '#8B5CF6');
          }
          
          // 更新科技点显示
          updateTechPointsDisplay();
          
          // 播放敌人死亡音效
          if (soundManager && soundManager.playSound) {
            soundManager.playSound('enemyDieSound');
          }
          
          // 检查是否是BOSS
          if (monster.type === gameData.waveSettings.bossMonster) {
            // 隐藏BOSS血条
            if (bossHealthBar && bossHealthText) {
              bossHealthBar.classList.add('hidden');
              bossHealthText.classList.add('hidden');
            }
            gameData.currentBoss = null;
          }
          
          // 检查是否是小BOSS
          if (monster.isMiniBoss) {
            // 增加量子炮解锁计数器
            gameData.quantumTowerUnlockedCount = (gameData.quantumTowerUnlockedCount || 0) + 1;
            
            // 显示小BOSS击杀通知
            if (monster.position) {
              showFloatingText(monster.position.x, monster.position.y, 'BOSS已击败！', '#F59E0B', 2);
            }
            
            // 播放BOSS死亡音效
            if (soundManager && soundManager.playSound) {
              soundManager.playSound('bossDieSound');
            }
            
            // 死亡时召唤大量怪物
            if (typeof summonMonstersOnDeath === 'function') {
              summonMonstersOnDeath(monster);
            }
          }
          
          // 创建死亡特效
          if (monster.position) {
            const deathEffect = {
              type: 'monster_death',
              x: monster.position.x * gameData.cellSize + gameData.gridOffset.x + gameData.cellSize / 2,
              y: monster.position.y * gameData.cellSize + gameData.gridOffset.y + gameData.cellSize / 2,
              size: gameData.cellSize * 2,
              time: 0,
              duration: 1
            };
            gameData.effects.push(deathEffect);
          }
          
          // 移除怪物
          gameData.monsters.splice(monsterIndex, 1);
        }
      }
      
      // 特殊怪物效果
      if (monster.type === 'charger') {
        // 冲锋兵受到伤害后加速
        if (!monster.isCharging) {
          monster.isCharging = true;
          monster.originalSpeed = monster.speed;
          monster.speed = 6; // 速度变为6（原速度3）
        }
      } else if (monster.type === 'assassin') {
        // 刺客受到伤害后无敌
        if (!monster.isInvulnerable && (!monster.invulnerableCooldown || monster.invulnerableCooldown <= 0)) {
          monster.isInvulnerable = true;
          monster.invulnerableDuration = 5; // 5秒
          monster.invulnerableCooldown = 15; // 15秒冷却（5秒无敌+10秒冷却）
          monster.originalSpeed = monster.speed;
          monster.speed = 8; // 速度变为8（原速度5）
        }
      }
      
      // 创建受击效果
      const x = gameData.gridOffset.x + monster.position.x * gameData.cellSize + gameData.cellSize / 2;
      const y = gameData.gridOffset.y + monster.position.y * gameData.cellSize + gameData.cellSize / 2;
      
      const effect = {
        type: 'hit',
        x,
        y,
        size: gameData.cellSize,
        time: 0
      };
      
      gameData.effects.push(effect);
    }
    
    // 伤害核心
    function damageCore(amount) {
      gameData.coreHealth -= amount;
      gameData.coreHealth = Math.max(0, gameData.coreHealth); // 确保生命值不会低于0
      updateGameInfo();
      
      // 显示浮动文本
      const endPoint = gameData.path[gameData.path.length - 1];
      showFloatingText(endPoint.x, endPoint.y, `-${amount}`, '#EF4444');
      
      // 创建核心受击效果
      const effect = {
        type: 'hit',
        x: gameData.gridOffset.x + endPoint.x * gameData.cellSize + gameData.cellSize / 2,
        y: gameData.gridOffset.y + endPoint.y * gameData.cellSize + gameData.cellSize / 2,
        size: gameData.cellSize * 1.5,
        time: 0
      };
      
      gameData.effects.push(effect);
    }
    
    // 更新爆炸效果
    function updateExplosions() {
      for (let i = gameData.explosions.length - 1; i >= 0; i--) {
        const explosion = gameData.explosions[i];
        
        explosion.time += gameData.deltaTime;
        
        if (explosion.time >= 0.5) {
          gameData.explosions.splice(i, 1);
        }
      }
    }
    
    // 更新特效
    function updateEffects() {
      // 添加数据有效性检查
      if (!gameData || !gameData.effects || !Array.isArray(gameData.effects)) {
        console.error('特效数据损坏！', {
          gameDataExists: !!gameData,
          effectsExists: !!gameData?.effects,
          effectsIsArray: Array.isArray(gameData?.effects)
        });
        return;
      }
      
      for (let i = gameData.effects.length - 1; i >= 0; i--) {
        const effect = gameData.effects[i];
        // 检查特效对象是否有效
        if (!effect) {
          console.error('无效的特效对象！', effect);
          gameData.effects.splice(i, 1);
          continue;
        }
        
        effect.time += gameData.deltaTime;
        
        switch (effect.type) {
          case 'laser':
            if (effect.time >= 0.3) {
              // 将特效对象返回对象池
              returnToPool('effects', effect);
              gameData.effects.splice(i, 1);
            }
            break;
            
          case 'freeze':
          case 'stun':
          case 'hit':
          case 'smoke':
            if (effect.time >= 1) {
              // 将特效对象返回对象池
              returnToPool('effects', effect);
              gameData.effects.splice(i, 1);
            }
            break;
        }
      }
    }
    
    // 更新浮动文本（使用对象池回收）
    function updateFloatingTexts() {
      for (let i = gameData.floatingTexts.length - 1; i >= 0; i--) {
        const text = gameData.floatingTexts[i];
        
        text.time += gameData.deltaTime;
        text.y -= 30 * gameData.deltaTime; // 向上移动
        
        if (text.time >= 1) {
          // 将对象返回对象池
          returnToPool('floatingTexts', text);
          gameData.floatingTexts.splice(i, 1);
        }
      }
    }
    
    // 渲染游戏
    function renderGame() {
      // 确保游戏数据和上下文存在
      if (!gameData || !ctx) {
        console.error('游戏数据或渲染上下文不存在！');
        return;
      }
      
      // 确保数组存在且为数组类型
      gameData.towers = Array.isArray(gameData.towers) ? gameData.towers : [];
      gameData.monsters = Array.isArray(gameData.monsters) ? gameData.monsters : [];
      gameData.projectiles = Array.isArray(gameData.projectiles) ? gameData.projectiles : [];
      gameData.effects = Array.isArray(gameData.effects) ? gameData.effects : [];
      gameData.explosions = Array.isArray(gameData.explosions) ? gameData.explosions : [];
      gameData.floatingTexts = Array.isArray(gameData.floatingTexts) ? gameData.floatingTexts : [];
      
      // 绘制网格
      try {
        renderGrid();
      } catch (error) {
        console.error('渲染网格时出错:', error);
      }
      
      // 绘制路径
      try {
        renderPath();
      } catch (error) {
        console.error('渲染路径时出错:', error);
      }
      
      // 绘制炮塔 - 添加防御性检查
      try {
        renderTowers();
      } catch (error) {
        console.error('渲染炮塔时出错:', error);
        console.error('炮塔数量:', gameData.towers ? gameData.towers.length : '未知');
        
        // 尝试清理无效的炮塔对象
        if (gameData.towers && Array.isArray(gameData.towers)) {
          gameData.towers = gameData.towers.filter(tower => {
            if (!tower || !tower.position || typeof tower.position.x !== 'number' || typeof tower.position.y !== 'number') {
              console.warn('移除无效的炮塔对象:', tower);
              return false;
            }
            return true;
          });
        }
      }
      
      // 绘制怪物 - 添加防御性检查
      try {
        renderMonsters();
      } catch (error) {
        console.error('渲染怪物时出错:', error);
        console.error('当前波次:', gameData.currentWave);
        console.error('怪物数量:', gameData.monsters ? gameData.monsters.length : '未知');
        
        // 尝试清理无效的怪物对象
        if (gameData.monsters && Array.isArray(gameData.monsters)) {
          gameData.monsters = gameData.monsters.filter(monster => {
            if (!monster || !monster.position || typeof monster.position.x !== 'number' || typeof monster.position.y !== 'number') {
              console.warn('移除无效的怪物对象:', monster);
              return false;
            }
            return true;
          });
        }
      }
      
      // 绘制己方单位 - 添加防御性检查
      try {
        renderAllies();
      } catch (error) {
        console.error('渲染己方单位时出错:', error);
        console.error('己方单位数量:', gameData.allies ? gameData.allies.length : '未知');
        
        // 尝试清理无效的己方单位对象
        if (gameData.allies && Array.isArray(gameData.allies)) {
          gameData.allies = gameData.allies.filter(ally => {
            if (!ally || typeof ally.x !== 'number' || typeof ally.y !== 'number') {
              console.warn('移除无效的己方单位对象:', ally);
              return false;
            }
            return true;
          });
        }
      }
      
      // 绘制projectile - 添加防御性检查
      try {
        renderProjectiles();
      } catch (error) {
        console.error('渲染projectile时出错:', error);
        console.error('projectile数量:', gameData.projectiles ? gameData.projectiles.length : '未知');
        
        // 尝试清理无效的projectile对象
        if (gameData.projectiles && Array.isArray(gameData.projectiles)) {
          gameData.projectiles = gameData.projectiles.filter(projectile => {
            if (!projectile || !projectile.position || typeof projectile.position.x !== 'number' || typeof projectile.position.y !== 'number') {
              console.warn('移除无效的projectile对象:', projectile);
              return false;
            }
            return true;
          });
        }
      }
      
      // 绘制爆炸效果 - 添加防御性检查
      try {
        renderExplosions();
      } catch (error) {
        console.error('渲染爆炸效果时出错:', error);
        console.error('爆炸效果数量:', gameData.explosions ? gameData.explosions.length : '未知');
        
        // 尝试清理无效的爆炸效果对象
        if (gameData.explosions && Array.isArray(gameData.explosions)) {
          gameData.explosions = gameData.explosions.filter(explosion => {
            if (!explosion || !explosion.position || typeof explosion.position.x !== 'number' || typeof explosion.position.y !== 'number') {
              console.warn('移除无效的爆炸效果对象:', explosion);
              return false;
            }
            return true;
          });
        }
      }
      
      // 绘制特效 - 添加防御性检查
      try {
        renderEffects();
      } catch (error) {
        console.error('渲染特效时出错:', error);
        console.error('特效数量:', gameData.effects ? gameData.effects.length : '未知');
        
        // 尝试清理无效的特效对象
        if (gameData.effects && Array.isArray(gameData.effects)) {
          gameData.effects = gameData.effects.filter(effect => {
            if (!effect || typeof effect.x !== 'number' || typeof effect.y !== 'number') {
              console.warn('移除无效的特效对象:', effect);
              return false;
            }
            return true;
          });
        }
      }
      
      // 绘制浮动文本 - 添加防御性检查
      try {
        renderFloatingTexts();
      } catch (error) {
        console.error('渲染浮动文本时出错:', error);
        console.error('浮动文本数量:', gameData.floatingTexts ? gameData.floatingTexts.length : '未知');
        
        // 尝试清理无效的浮动文本对象
        if (gameData.floatingTexts && Array.isArray(gameData.floatingTexts)) {
          gameData.floatingTexts = gameData.floatingTexts.filter(text => {
            if (!text || typeof text.x !== 'number' || typeof text.y !== 'number') {
              console.warn('移除无效的浮动文本对象:', text);
              return false;
            }
            return true;
          });
        }
      }
      
      // 绘制选中的格子 - 添加防御性检查
      try {
        renderSelectedCell();
      } catch (error) {
        console.error('渲染选中格子时出错:', error);
      }
    }
    
    // 绘制网格
    function renderGrid() {
      ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
      ctx.lineWidth = 1;
      
      // 绘制垂直线
      for (let x = 0; x <= gameData.gridSize.width; x++) {
        ctx.beginPath();
        ctx.moveTo(gameData.gridOffset.x + x * gameData.cellSize, gameData.gridOffset.y);
        ctx.lineTo(gameData.gridOffset.x + x * gameData.cellSize, gameData.gridOffset.y + gameData.gridSize.height * gameData.cellSize);
        ctx.stroke();
      }
      
      // 绘制水平线
      for (let y = 0; y <= gameData.gridSize.height; y++) {
        ctx.beginPath();
        ctx.moveTo(gameData.gridOffset.x, gameData.gridOffset.y + y * gameData.cellSize);
        ctx.lineTo(gameData.gridOffset.x + gameData.gridSize.width * gameData.cellSize, gameData.gridOffset.y + y * gameData.cellSize);
        ctx.stroke();
      }
      
      // 绘制禁止放置区域
      ctx.fillStyle = 'rgba(239, 68, 68, 0.2)';
      
      // 左上角3x3区域
      for (let x = 0; x < 3; x++) {
        for (let y = 0; y < 3; y++) {
          ctx.fillRect(
            gameData.gridOffset.x + x * gameData.cellSize,
            gameData.gridOffset.y + y * gameData.cellSize,
            gameData.cellSize,
            gameData.cellSize
          );
        }
      }
      
      // 右下角3x3区域
      for (let x = gameData.gridSize.width - 3; x < gameData.gridSize.width; x++) {
        for (let y = gameData.gridSize.height - 3; y < gameData.gridSize.height; y++) {
          ctx.fillRect(
            gameData.gridOffset.x + x * gameData.cellSize,
            gameData.gridOffset.y + y * gameData.cellSize,
            gameData.cellSize,
            gameData.cellSize
          );
        }
      }
    }
    
    // 绘制路径
    function renderPath() {
      // 添加数据有效性检查
      if (!gameData || !gameData.path || !Array.isArray(gameData.path) || gameData.path.length === 0) {
        console.error('路径数据损坏！', {
          gameDataExists: !!gameData,
          pathExists: !!gameData?.path,
          pathIsArray: Array.isArray(gameData?.path),
          pathLength: gameData?.path?.length
        });
        return;
      }
      
      // 绘制路径
      ctx.fillStyle = 'rgba(107, 114, 128, 0.3)';
      gameData.path.forEach(point => {
        ctx.fillRect(
          gameData.gridOffset.x + point.x * gameData.cellSize,
          gameData.gridOffset.y + point.y * gameData.cellSize,
          gameData.cellSize,
          gameData.cellSize
        );
      });
      
      // 绘制起点
      ctx.fillStyle = 'rgba(16, 185, 129, 0.7)';
      const startPoint = gameData.path[0];
      ctx.fillRect(
        gameData.gridOffset.x + startPoint.x * gameData.cellSize,
        gameData.gridOffset.y + startPoint.y * gameData.cellSize,
        gameData.cellSize,
        gameData.cellSize
      );
      
      // 绘制起点图标
      ctx.fillStyle = 'white';
      ctx.font = '20px FontAwesome';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText('\uf0d0', gameData.gridOffset.x + startPoint.x * gameData.cellSize + gameData.cellSize / 2, 
              gameData.gridOffset.y + startPoint.y * gameData.cellSize + gameData.cellSize / 2);
      
      // 绘制终点（核心）
      ctx.fillStyle = 'rgba(239, 68, 68, 0.7)';
      const endPoint = gameData.path[gameData.path.length - 1];
      ctx.fillRect(
        gameData.gridOffset.x + endPoint.x * gameData.cellSize,
        gameData.gridOffset.y + endPoint.y * gameData.cellSize,
        gameData.cellSize,
        gameData.cellSize
      );
      
      // 绘制核心图标
      ctx.fillStyle = 'white';
      ctx.font = '24px FontAwesome';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText('\uf0e7', gameData.gridOffset.x + endPoint.x * gameData.cellSize + gameData.cellSize / 2, 
              gameData.gridOffset.y + endPoint.y * gameData.cellSize + gameData.cellSize / 2);
      
      // 绘制核心生命值
      ctx.fillStyle = 'white';
      ctx.font = '12px Arial';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'top';
      ctx.fillText(`${gameData.coreHealth}/100`, 
              gameData.gridOffset.x + endPoint.x * gameData.cellSize + gameData.cellSize / 2, 
              gameData.gridOffset.y + endPoint.y * gameData.cellSize - 15);
    }
    
    // 绘制炮塔
    function renderTowers() {
      gameData.towers.forEach(tower => {
        const x = gameData.gridOffset.x + tower.position.x * gameData.cellSize;
        const y = gameData.gridOffset.y + tower.position.y * gameData.cellSize;
        
        // 绘制炮塔底座
        ctx.fillStyle = '#374151';
        ctx.fillRect(x, y, gameData.cellSize, gameData.cellSize);
        
        // 绘制炮塔主体
        switch (tower.type) {
          case 'energy':
            ctx.fillStyle = '#3B82F6';
            break;
          case 'rapid':
            ctx.fillStyle = '#10B981';
            break;
          case 'ice':
            ctx.fillStyle = '#60A5FA';
            break;
          case 'pierce':
            ctx.fillStyle = '#8B5CF6';
            break;
          case 'laser':
            ctx.fillStyle = '#EC4899';
            break;
          case 'rocket':
            ctx.fillStyle = '#EF4444';
            break;
          case 'electro':
            ctx.fillStyle = '#F59E0B';
            break;
          case 'titan':
            ctx.fillStyle = '#1F2937';
            break;
          case 'sniper':
            ctx.fillStyle = '#4B5563';
            break;
          case 'aa':
            ctx.fillStyle = '#3B82F6';
            break;
          case 'flame':
            ctx.fillStyle = '#F59E0B';
            break;
          case 'howitzer':
            ctx.fillStyle = '#DC2626';
            break;
          case 'toxin':
            ctx.fillStyle = '#10B981';
            break;
          case 'sentinel':
            ctx.fillStyle = '#6366F1';
            break;
          case 'quantum':
            ctx.fillStyle = '#8B5CF6';
            break;
          case 'amplifier':
            ctx.fillStyle = '#3B82F6';
            break;
          case 'repair':
            ctx.fillStyle = '#10B981';
            break;
          case 'moneycow':
            ctx.fillStyle = '#F59E0B'; // 金钱牛使用黄色
            break;

        }
        
        // 如果被冻结，添加蓝色滤镜
        if (tower.isFrozen) {
          ctx.fillStyle = `rgba(96, 165, 250, 0.7)`;
        }
        
        ctx.beginPath();
        ctx.arc(x + gameData.cellSize / 2, y + gameData.cellSize / 2, gameData.cellSize / 3, 0, Math.PI * 2);
        ctx.fill();
        
        // 对于无法发射炮弹的特殊炮台，不绘制炮管
        if (tower.type !== 'amplifier' && tower.type !== 'repair' && tower.type !== 'moneycow') {
          // 绘制炮管
          ctx.fillStyle = '#1F2937';
          ctx.save();
          ctx.translate(x + gameData.cellSize / 2, y + gameData.cellSize / 2);
        
        // 寻找目标并指向目标
        let angle = 0;
        const target = findTarget(tower);
        if (target) {
          const dx = target.position.x - tower.position.x;
          const dy = target.position.y - tower.position.y;
          angle = Math.atan2(dy, dx);
        }
        
        ctx.rotate(angle);
        ctx.fillRect(gameData.cellSize / 3, -2, gameData.cellSize / 3, 4);
        ctx.restore();
        }
        
        // 绘制等级
        ctx.fillStyle = 'white';
        ctx.font = '12px Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(`Lv${tower.level}`, x + gameData.cellSize / 2, y + gameData.cellSize - 10);
        
        // 如果是选中的炮塔，绘制范围
        if (gameData.selectedTower && gameData.selectedTower.id === tower.id) {
          // 特殊炮台显示作用范围，普通炮台显示射程
          const range = (tower.type === 'amplifier' || tower.type === 'repair') ? 3 : tower.range;
          
          ctx.strokeStyle = tower.type === 'amplifier' ? 'rgba(59, 130, 246, 0.5)' : 
                          tower.type === 'repair' ? 'rgba(16, 185, 129, 0.5)' : 
                          'rgba(59, 130, 246, 0.5)';
          
          ctx.lineWidth = 2;
          ctx.setLineDash([5, 5]);
          ctx.beginPath();
          ctx.arc(
            x + gameData.cellSize / 2,
            y + gameData.cellSize / 2,
            range * gameData.cellSize,
            0,
            Math.PI * 2
          );
          ctx.stroke();
          ctx.setLineDash([]);
        }
        
        // 绘制特殊炮台的效果范围
        if (tower.type === 'amplifier') {
          // 能量增幅塔的光环效果
          ctx.strokeStyle = 'rgba(59, 130, 246, 0.3)';
          ctx.lineWidth = 3;
          ctx.beginPath();
          ctx.arc(
            x + gameData.cellSize / 2,
            y + gameData.cellSize / 2,
            3 * gameData.cellSize,
            0,
            Math.PI * 2
          );
          ctx.stroke();
          
          // 绘制能量粒子效果
          if (tower.energyParticles && tower.energyParticles.length > 0) {
            ctx.fillStyle = 'rgba(59, 130, 246, 0.7)';
            tower.energyParticles.forEach(particle => {
              ctx.beginPath();
              ctx.arc(
                x + gameData.cellSize / 2 + particle.x,
                y + gameData.cellSize / 2 + particle.y,
                particle.size,
                0,
                Math.PI * 2
              );
              ctx.fill();
            });
          }
        } else if (tower.type === 'repair') {
          // 修复塔的光环效果
          ctx.strokeStyle = 'rgba(16, 185, 129, 0.3)';
          ctx.lineWidth = 3;
          ctx.beginPath();
          ctx.arc(
            x + gameData.cellSize / 2,
            y + gameData.cellSize / 2,
            3 * gameData.cellSize,
            0,
            Math.PI * 2
          );
          ctx.stroke();
          
          // 绘制修复光束效果
          if (tower.repairingTower) {
            const targetTower = tower.repairingTower;
            const targetX = gameData.gridOffset.x + targetTower.position.x * gameData.cellSize + gameData.cellSize / 2;
            const targetY = gameData.gridOffset.y + targetTower.position.y * gameData.cellSize + gameData.cellSize / 2;
            
            // 绘制光束
            ctx.strokeStyle = 'rgba(16, 185, 129, 0.7)';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(x + gameData.cellSize / 2, y + gameData.cellSize / 2);
            ctx.lineTo(targetX, targetY);
            ctx.stroke();
            
            // 绘制光束粒子
            ctx.fillStyle = 'rgba(16, 185, 129, 0.9)';
            for (let i = 0; i < 5; i++) {
              const t = i / 5;
              const particleX = x + gameData.cellSize / 2 + (targetX - (x + gameData.cellSize / 2)) * t + (Math.random() - 0.5) * 10;
              const particleY = y + gameData.cellSize / 2 + (targetY - (y + gameData.cellSize / 2)) * t + (Math.random() - 0.5) * 10;
              
              ctx.beginPath();
              ctx.arc(particleX, particleY, 2 + Math.random() * 2, 0, Math.PI * 2);
              ctx.fill();
            }
          }
        }
      });
    }
    
    // 获取怪物边框颜色
    function getMonsterBorderColor(type, isElite) {
      if (isElite) {
        return 'rgba(255, 215, 0, 0.9)'; // 精英怪物使用金色边框
      }
      
      switch (type) {
        case 'normal': return 'rgba(255, 255, 255, 0.7)'; // 白色边框
        case 'fast': return 'rgba(255, 255, 0, 0.7)'; // 黄色边框
        case 'heavy': return 'rgba(128, 128, 128, 0.7)'; // 灰色边框
        case 'shield': return 'rgba(0, 255, 0, 0.7)'; // 绿色边框
        case 'healer': return 'rgba(255, 0, 255, 0.7)'; // 紫色边框
        case 'drone': return 'rgba(255, 165, 0, 0.7)'; // 橙色边框
        case 'bomber': return 'rgba(255, 0, 0, 0.7)'; // 红色边框
        case 'mech': return 'rgba(0, 0, 255, 0.7)'; // 蓝色边框
        case 'thief': return 'rgba(0, 255, 255, 0.7)'; // 青色边框
        case 'charger': return 'rgba(255, 105, 180, 0.7)'; // 粉色边框
        case 'assassin': return 'rgba(128, 0, 128, 0.7)'; // 深紫色边框
        case 'reaper': return 'rgba(0, 0, 0, 0.7)'; // 黑色边框
        default: return 'rgba(255, 255, 255, 0.7)'; // 默认白色边框
      }
    }
    
    // 颜色变亮函数
    function lightenColor(color, percent) {
      // 如果是rgb颜色
      if (color.startsWith('rgb')) {
        const rgbMatch = color.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)(?:,\s*[\d.]+)?\)/);
        if (rgbMatch) {
          let r = parseInt(rgbMatch[1]);
          let g = parseInt(rgbMatch[2]);
          let b = parseInt(rgbMatch[3]);
          
          r = Math.min(255, r + percent);
          g = Math.min(255, g + percent);
          b = Math.min(255, b + percent);
          
          return `rgb(${r}, ${g}, ${b})`;
        }
      }
      
      // 如果是十六进制颜色
      if (color.startsWith('#')) {
        let r = parseInt(color.substring(1, 3), 16);
        let g = parseInt(color.substring(3, 5), 16);
        let b = parseInt(color.substring(5, 7), 16);
        
        r = Math.min(255, r + percent);
        g = Math.min(255, g + percent);
        b = Math.min(255, b + percent);
        
        return `#${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}`;
      }
      
      return color;
    }
    
    // 绘制己方单位
    function renderAllies() {
      // 添加数据有效性检查
      if (!gameData || !gameData.allies || !Array.isArray(gameData.allies)) {
        return;
      }
      
      gameData.allies.forEach(ally => {
        const screenX = gameData.gridOffset.x + ally.x * gameData.cellSize;
        const screenY = gameData.gridOffset.y + ally.y * gameData.cellSize;
        
        // 绘制单位
        ctx.fillStyle = '#10B981'; // 绿色表示友方
        ctx.fillRect(screenX - 10, screenY - 10, 20, 20);
        
        // 绘制单位类型标识
        ctx.fillStyle = 'white';
        ctx.font = '12px Arial';
        ctx.textAlign = 'center';
        ctx.fillText(ally.type.charAt(0).toUpperCase(), screenX, screenY + 4);
        
        // 绘制血条
        const healthPercent = ally.health / ally.maxHealth;
        ctx.fillStyle = '#374151';
        ctx.fillRect(screenX - 12, screenY - 18, 24, 4);
        ctx.fillStyle = healthPercent > 0.5 ? '#10B981' : healthPercent > 0.25 ? '#F59E0B' : '#EF4444';
        ctx.fillRect(screenX - 12, screenY - 18, 24 * healthPercent, 4);
      });
    }
    
    // 绘制怪物
    function renderMonsters() {
      gameData.monsters.forEach(monster => {
        const x = gameData.gridOffset.x + monster.position.x * gameData.cellSize;
        const y = gameData.gridOffset.y + monster.position.y * gameData.cellSize;
        
        // 绘制怪物
        let baseColor = '#9CA3AF'; // 默认颜色
        switch (monster.type) {
          case 'normal':
            baseColor = '#9CA3AF';
            break;
          case 'fast':
            baseColor = '#10B981';
            break;
          case 'heavy':
            baseColor = '#4B5563';
            break;
          case 'shield':
            baseColor = '#3B82F6';
            break;
          case 'healer':
            baseColor = '#8B5CF6';
            break;
          case 'drone':
            baseColor = '#EC4899';
            break;
          case 'bomber':
            baseColor = '#EF4444';
            break;
          case 'mech':
            baseColor = '#1F2937';
            break;
          case 'thief':
            baseColor = '#F59E0B';
            break;
          case 'charger':
            baseColor = '#60A5FA';
            break;
          case 'assassin':
            baseColor = '#8B5CF6';
            break;
          case 'reaper':
            baseColor = '#1F2937';
            break;
          case 'stealth':
            baseColor = '#6366F1'; // 靛蓝色
            break;
          default:
            baseColor = '#9CA3AF';
        }
        
        // 如果是精英怪物，使用金色边框和更亮的颜色
        if (monster.isElite) {
          // 使用更亮的颜色
          baseColor = lightenColor(baseColor, 30);
        }
        
        // 应用状态效果
        ctx.fillStyle = baseColor;
        
        // 隐形刺客特殊处理
        if (monster.type === 'stealth') {
          // 如果处于隐形状态，使用半透明效果
          if (monster.isInvisible) {
            // 半透明效果，根据隐形时间变化透明度
            const alpha = 0.2 + 0.3 * Math.sin(monster.invisibleTime * 10); // 轻微闪烁效果
            ctx.fillStyle = `rgba(99, 102, 241, ${alpha})`;
            
            // 绘制隐形轮廓
            ctx.strokeStyle = `rgba(99, 102, 241, ${alpha + 0.2})`;
            ctx.lineWidth = 2;
            ctx.setLineDash([3, 3]);
            ctx.beginPath();
            ctx.arc(x + gameData.cellSize / 2, y + gameData.cellSize / 2, gameData.cellSize * 0.5, 0, Math.PI * 2);
            ctx.stroke();
            ctx.setLineDash([]);
          } else {
            // 非隐形状态下，绘制能量流动效果
            ctx.fillStyle = '#6366F1';
            
            // 绘制能量流动效果
            const time = Date.now() / 1000;
            const gradient = ctx.createRadialGradient(
              x + gameData.cellSize / 2 + Math.sin(time * 3) * 5,
              y + gameData.cellSize / 2 + Math.cos(time * 3) * 5,
              0,
              x + gameData.cellSize / 2,
              y + gameData.cellSize / 2,
              gameData.cellSize * 0.5
            );
            gradient.addColorStop(0, '#818CF8');
            gradient.addColorStop(1, '#4F46E5');
            ctx.fillStyle = gradient;
          }
        }
        
        // 如果被减速，添加蓝色滤镜
        if (monster.isSlowed) {
          ctx.fillStyle = `rgba(96, 165, 250, 0.9)`;
        }
        
        // 如果被眩晕，添加黄色滤镜
        if (monster.isStunned) {
          ctx.fillStyle = `rgba(245, 158, 11, 0.9)`;
        }
        
        // 如果无敌，添加闪烁效果
        if (monster.isInvulnerable) {
          if (Math.floor(monster.invulnerableDuration * 10) % 2 === 0) {
            ctx.fillStyle = `rgba(255, 255, 255, 0.9)`;
          } else {
            ctx.fillStyle = baseColor;
          }
        }
        
        // 绘制怪物形状 - 圆形无图案
        // 绘制怪物形状
        if (monster.isElite) {
          // 小BOSS独特外观
          if (monster.isMiniBoss) {
            // 绘制小BOSS主体
            ctx.fillStyle = '#8B5CF6'; // 紫色
            ctx.beginPath();
            ctx.arc(x + gameData.cellSize / 2, y + gameData.cellSize / 2, gameData.cellSize * 0.7, 0, Math.PI * 2);
            ctx.fill();
            
            // 绘制小BOSS外边框
            ctx.strokeStyle = '#EC4899'; // 粉色
            ctx.lineWidth = 4;
            ctx.beginPath();
            ctx.arc(x + gameData.cellSize / 2, y + gameData.cellSize / 2, gameData.cellSize * 0.7, 0, Math.PI * 2);
            ctx.stroke();
            
            // 绘制小BOSS内边框
            ctx.strokeStyle = '#F59E0B'; // 金色
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(x + gameData.cellSize / 2, y + gameData.cellSize / 2, gameData.cellSize * 0.6, 0, Math.PI * 2);
            ctx.stroke();
            
            // 绘制BOSS标记
            ctx.fillStyle = 'white';
            ctx.font = `${gameData.cellSize * 0.3}px Arial`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('BOSS', x + gameData.cellSize / 2, y + gameData.cellSize / 2);
            
            // 绘制护盾效果
            if (monster.isShielded) {
              ctx.strokeStyle = 'rgba(59, 130, 246, 0.7)';
              ctx.lineWidth = 3;
              ctx.beginPath();
              ctx.arc(x + gameData.cellSize / 2, y + gameData.cellSize / 2, gameData.cellSize * 0.8, 0, Math.PI * 2);
              ctx.stroke();
              
              // 绘制护盾生命值
              const shieldPercentage = monster.shieldHealth / monster.maxShieldHealth;
              ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
              ctx.fillRect(x - gameData.cellSize * 0.1, y - gameData.cellSize * 0.3, gameData.cellSize * 1.2, 3);
              ctx.fillStyle = '#3B82F6';
              ctx.fillRect(x - gameData.cellSize * 0.1, y - gameData.cellSize * 0.3, gameData.cellSize * 1.2 * shieldPercentage, 3);
            }
            
            // 绘制召唤动画
            if (monster.isSummoning) {
              const alpha = 0.7 - 0.7 * monster.summonProgress / monster.summonDuration;
              ctx.fillStyle = `rgba(245, 158, 11, ${alpha})`;
              ctx.beginPath();
              ctx.arc(x + gameData.cellSize / 2, y + gameData.cellSize / 2, gameData.cellSize * (1 + monster.summonProgress / monster.summonDuration), 0, Math.PI * 2);
              ctx.fill();
              
              // 绘制召唤进度条
              const progress = monster.summonProgress / monster.summonDuration;
              ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
              ctx.fillRect(x - gameData.cellSize * 0.2, y + gameData.cellSize * 0.6, gameData.cellSize * 1.4, 4);
              ctx.fillStyle = '#F59E0B';
              ctx.fillRect(x - gameData.cellSize * 0.2, y + gameData.cellSize * 0.6, gameData.cellSize * 1.4 * progress, 4);
              
              // 绘制召唤文字
              ctx.fillStyle = 'white';
              ctx.font = '10px Arial';
              ctx.textAlign = 'center';
              ctx.textBaseline = 'middle';
              ctx.fillText('召唤中...', x + gameData.cellSize / 2, y + gameData.cellSize * 0.8);
            }
          } else {
            // 普通精英怪物
            ctx.beginPath();
            ctx.arc(x + gameData.cellSize / 2, y + gameData.cellSize / 2, gameData.cellSize * 0.6, 0, Math.PI * 2);
            ctx.fill();
            
            // 绘制精英怪物金色边框
            ctx.strokeStyle = 'gold';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.arc(x + gameData.cellSize / 2, y + gameData.cellSize / 2, gameData.cellSize * 0.6, 0, Math.PI * 2);
            ctx.stroke();
            
            // 绘制精英标记
            ctx.fillStyle = 'gold';
            ctx.font = `${gameData.cellSize * 0.4}px Arial`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('★', x + gameData.cellSize / 2, y + gameData.cellSize / 2);
          }
        } else {
          ctx.beginPath();
          ctx.arc(x + gameData.cellSize / 2, y + gameData.cellSize / 2, gameData.cellSize * 0.5, 0, Math.PI * 2);
          ctx.fill();
          
          // 为不同类型怪物添加不同的边框颜色，增强辨识度
          ctx.strokeStyle = getMonsterBorderColor(monster.type);
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.arc(x + gameData.cellSize / 2, y + gameData.cellSize / 2, gameData.cellSize * 0.5, 0, Math.PI * 2);
          ctx.stroke();
        }
        
        // 绘制特殊标记
        if (monster.type === 'shield') {
          // 盾牌边框
          ctx.strokeStyle = 'white';
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.rect(x + gameData.cellSize * 0.2, y + gameData.cellSize * 0.2, gameData.cellSize * 0.6, gameData.cellSize * 0.6);
          ctx.stroke();
        } else if (monster.type === 'bomber') {
          // 爆炸倒计时
          ctx.fillStyle = 'white';
          ctx.font = '10px Arial';
          ctx.textAlign = 'center';
          ctx.textBaseline = 'bottom';
          ctx.fillText(`${Math.ceil(monster.bomberTimer)}`, x + gameData.cellSize / 2, y + gameData.cellSize * 0.8);
        } else if (monster.type === 'stealth') {
          // 隐形刺客特殊标记
          if (monster.isInvisible) {
            // 隐形状态下显示"隐形"文字
            ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
            ctx.font = '8px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'bottom';
            ctx.fillText('隐形', x + gameData.cellSize / 2, y + gameData.cellSize * 0.8);
          } else {
            // 非隐形状态下显示倒计时
            const cooldown = Math.max(0, 8 - monster.stealthCooldown);
            if (cooldown < 3) { // 最后3秒显示倒计时
              ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
              ctx.font = '10px Arial';
              ctx.textAlign = 'center';
              ctx.textBaseline = 'bottom';
              ctx.fillText(`隐身: ${cooldown.toFixed(1)}`, x + gameData.cellSize / 2, y + gameData.cellSize * 0.8);
            }
          }
        }
        
        // 绘制血条
        const healthPercentage = monster.health / monster.maxHealth;
        ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
        ctx.fillRect(x, y - 5, gameData.cellSize, 4);
        ctx.fillStyle = healthPercentage > 0.5 ? '#10B981' : healthPercentage > 0.25 ? '#F59E0B' : '#EF4444';
        ctx.fillRect(x, y - 5, gameData.cellSize * healthPercentage, 4);
        
        // 绘制怪物名称
        ctx.fillStyle = 'white';
        ctx.font = '8px Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'top';
        
        // 根据不同怪物类型转换为中文名称
        let monsterName = '';
        switch (monster.type) {
          case 'normal': monsterName = '普通士兵'; break;
          case 'fast': monsterName = '极速士兵'; break;
          case 'heavy': monsterName = '重型士兵'; break;
          case 'shield': monsterName = '护盾士兵'; break;
          case 'healer': monsterName = '医疗兵'; break;
          case 'drone': monsterName = '无人机'; break;
          case 'bomber': monsterName = '爆破兵'; break;
          case 'mech': monsterName = '机械士兵'; break;
          case 'thief': monsterName = '窃取者'; break;
          case 'charger': monsterName = '冲锋兵'; break;
          case 'assassin': monsterName = '刺客'; break;
          case 'reaper': monsterName = '收割者'; break;
          case 'ice-mage': monsterName = '冰霜法师'; break;
          case 'boss': monsterName = '最终BOSS'; break;
          case 'mini-boss': monsterName = 'BOSS'; break;
          default: monsterName = '未知怪';
        }
        
        ctx.fillText(monsterName, x + gameData.cellSize / 2, y + gameData.cellSize + 2);
      });
    }
    
    // 绘制 projectile
    function renderProjectiles() {
      gameData.projectiles.forEach(projectile => {
        const x = gameData.gridOffset.x + projectile.position.x * gameData.cellSize + gameData.cellSize / 2;
        const y = gameData.gridOffset.y + projectile.position.y * gameData.cellSize + gameData.cellSize / 2;
        
        // 绘制 projectile
        switch (projectile.type) {
          case 'normal':
            switch (projectile.towerType) {
              case 'energy':
                ctx.fillStyle = '#3B82F6';
                break;
              case 'rapid':
                ctx.fillStyle = '#10B981';
                break;
              case 'ice':
                ctx.fillStyle = '#60A5FA';
                break;
              case 'titan':
                ctx.fillStyle = '#1F2937';
                break;
              case 'sniper':
                ctx.fillStyle = '#4B5563';
                break;
            }
            
            ctx.beginPath();
            ctx.arc(x, y, 5, 0, Math.PI * 2);
            ctx.fill();
            break;
            
          case 'pierce':
            ctx.fillStyle = '#8B5CF6';
            
            ctx.save();
            ctx.translate(x, y);
            
            // 计算方向
            let angle = 0;
            if (projectile.direction) {
              angle = Math.atan2(projectile.direction.y, projectile.direction.x);
            }
            
            ctx.rotate(angle);
            ctx.beginPath();
            ctx.moveTo(0, -3);
            ctx.lineTo(8, 0);
            ctx.lineTo(0, 3);
            ctx.closePath();
            ctx.fill();
            ctx.restore();
            break;
            
          case 'rocket':
            ctx.fillStyle = '#EF4444';
            
            ctx.save();
            ctx.translate(x, y);
            
            // 计算方向
            let rocketAngle = 0;
            if (projectile.target) {
              const dx = projectile.target.x - projectile.position.x;
              const dy = projectile.target.y - projectile.position.y;
              rocketAngle = Math.atan2(dy, dx);
            }
            
            ctx.rotate(rocketAngle);
            ctx.beginPath();
            ctx.moveTo(0, -4);
            ctx.lineTo(10, 0);
            ctx.lineTo(0, 4);
            ctx.closePath();
            ctx.fill();
            
            // 尾焰
            ctx.fillStyle = '#F59E0B';
            ctx.beginPath();
            ctx.moveTo(-5, -3);
            ctx.lineTo(0, 0);
            ctx.lineTo(-5, 3);
            ctx.closePath();
            ctx.fill();
            ctx.restore();
            break;
            
          case 'electro':
            ctx.fillStyle = '#F59E0B';
            
            ctx.beginPath();
            ctx.arc(x, y, 6, 0, Math.PI * 2);
            ctx.fill();
            
            // 电击效果
            ctx.strokeStyle = '#F59E0B';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(x, y, 8, 0, Math.PI * 2);
            ctx.stroke();
            break;
            
          case 'howitzer':
            ctx.fillStyle = '#DC2626';
            
            ctx.save();
            ctx.translate(x, y);
            
            // 计算方向
            let howitzerAngle = 0;
            if (projectile.target) {
              const dx = projectile.target.x - projectile.position.x;
              const dy = projectile.target.y - projectile.position.y;
              howitzerAngle = Math.atan2(dy, dx);
            }
            
            ctx.rotate(howitzerAngle);
            ctx.beginPath();
            ctx.moveTo(0, -6);
            ctx.lineTo(12, 0);
            ctx.lineTo(0, 6);
            ctx.closePath();
            ctx.fill();
            
            // 尾焰
            ctx.fillStyle = '#F59E0B';
            ctx.beginPath();
            ctx.moveTo(-8, -4);
            ctx.lineTo(0, 0);
            ctx.lineTo(-8, 4);
            ctx.closePath();
            ctx.fill();
            ctx.restore();
            break;
            
          case 'pulse':
            // 脉冲炮
            ctx.fillStyle = '#8B5CF6';
            
            ctx.save();
            ctx.translate(x, y);
            
            // 脉冲波效果
            ctx.beginPath();
            ctx.arc(0, 0, 8, 0, Math.PI * 2);
            ctx.fill();
            
            // 脉冲环
            ctx.strokeStyle = '#C4B5FD';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(0, 0, 12, 0, Math.PI * 2);
            ctx.stroke();
            
            ctx.restore();
            break;
            
          case 'gravity':
            // 重力炮
            ctx.fillStyle = '#10B981';
            
            ctx.save();
            ctx.translate(x, y);
            
            // 重力球
            ctx.beginPath();
            ctx.arc(0, 0, 6, 0, Math.PI * 2);
            ctx.fill();
            
            // 重力场效果
            ctx.strokeStyle = '#34D399';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(0, 0, 10, 0, Math.PI * 2);
            ctx.stroke();
            
            ctx.restore();
            break;
            
          case 'plasma':
            // 等离子炮
            ctx.fillStyle = '#EC4899';
            
            ctx.save();
            ctx.translate(x, y);
            
            // 等离子球
            ctx.beginPath();
            ctx.arc(0, 0, 7, 0, Math.PI * 2);
            ctx.fill();
            
            // 等离子光晕
            ctx.strokeStyle = '#F472B6';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.arc(0, 0, 11, 0, Math.PI * 2);
            ctx.stroke();
            
            ctx.restore();
            break;
            
          case 'beacon':
            // 信标塔
            ctx.fillStyle = '#6366F1';
            
            ctx.save();
            ctx.translate(x, y);
            
            // 信标光束
            ctx.strokeStyle = '#818CF8';
            ctx.lineWidth = 4;
            ctx.beginPath();
            ctx.moveTo(0, -15);
            ctx.lineTo(0, 15);
            ctx.stroke();
            
            // 信标核心
            ctx.beginPath();
            ctx.arc(0, 0, 5, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.restore();
            break;
            
          case 'emp':
            // EMP电磁脉冲波
            ctx.fillStyle = '#8B5CF6';
            
            ctx.save();
            ctx.translate(x, y);
            
            // 计算方向
            let empAngle = 0;
            if (projectile.target) {
              const dx = projectile.target.x - projectile.position.x;
              const dy = projectile.target.y - projectile.position.y;
              empAngle = Math.atan2(dy, dx);
            }
            
            ctx.rotate(empAngle);
            
            // 绘制EMP波主体
            ctx.beginPath();
            ctx.moveTo(0, -5);
            ctx.lineTo(15, 0);
            ctx.lineTo(0, 5);
            ctx.closePath();
            ctx.fill();
            
            // EMP波光晕
            ctx.strokeStyle = '#C4B5FD';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(0, -8);
            ctx.lineTo(18, 0);
            ctx.lineTo(0, 8);
            ctx.stroke();
            
            // 能量粒子效果
            for (let i = 0; i < 3; i++) {
              const particleX = 5 + Math.random() * 8;
              const particleY = (Math.random() - 0.5) * 6;
              
              ctx.fillStyle = '#E9D5FF';
              ctx.beginPath();
              ctx.arc(particleX, particleY, 1 + Math.random(), 0, Math.PI * 2);
              ctx.fill();
            }
            
            ctx.restore();
            break;

            ctx.arc(0, 0, 8, 0, Math.PI * 2);
            ctx.stroke();
            
            ctx.restore();
            break;
            
          case 'gravity':
            // 绘制重力波
            ctx.fillStyle = '#3B82F6';
            
            ctx.beginPath();
            ctx.arc(x, y, 6, 0, Math.PI * 2);
            ctx.fill();
            
            // 重力场效果
            ctx.strokeStyle = '#60A5FA';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(x, y, 10, 0, Math.PI * 2);
            ctx.stroke();
            break;
            
          case 'plasma':
            // 绘制等离子球
            ctx.fillStyle = '#EC4899';
            
            ctx.beginPath();
            ctx.arc(x, y, 7, 0, Math.PI * 2);
            ctx.fill();
            
            // 等离子能量效果
            ctx.strokeStyle = '#F472B6';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.arc(x, y, 9, 0, Math.PI * 2);
            ctx.stroke();
            break;
            
          case 'missile':
            // 绘制导弹
            ctx.fillStyle = '#1E40AF';
            
            ctx.save();
            ctx.translate(x, y);
            
            // 计算方向
            let missileAngle = 0;
            if (projectile.target) {
              const dx = projectile.target.x - projectile.position.x;
              const dy = projectile.target.y - projectile.position.y;
              missileAngle = Math.atan2(dy, dx);
            }
            
            ctx.rotate(missileAngle);
            ctx.beginPath();
            ctx.moveTo(0, -5);
            ctx.lineTo(14, 0);
            ctx.lineTo(0, 5);
            ctx.closePath();
            ctx.fill();
            
            // 导弹尾焰
            ctx.fillStyle = '#EF4444';
            ctx.beginPath();
            ctx.moveTo(-6, -3);
            ctx.lineTo(0, 0);
            ctx.lineTo(-6, 3);
            ctx.closePath();
            ctx.fill();
            ctx.restore();
            break;
            
          case 'emp':
            // 绘制EMP波
            ctx.fillStyle = '#8B5CF6';
            
            ctx.beginPath();
            ctx.arc(x, y, 8, 0, Math.PI * 2);
            ctx.fill();
            
            // EMP能量效果
            ctx.strokeStyle = '#A78BFA';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.arc(x, y, 12, 0, Math.PI * 2);
            ctx.stroke();
            
            // 电磁效果
            for (let i = 0; i < 8; i++) {
              const angle = (Math.PI * 2 / 8) * i;
              ctx.beginPath();
              ctx.moveTo(x, y);
              ctx.lineTo(x + Math.cos(angle) * 15, y + Math.sin(angle) * 15);
              ctx.stroke();
            }
            break;
        }
      });
    }
    
    // 绘制爆炸效果
    function renderExplosions() {
      gameData.explosions.forEach(explosion => {
        const alpha = 1 - explosion.time * 2; // 0.5秒内从1到0
        
        ctx.fillStyle = `rgba(245, 158, 11, ${alpha})`;
        ctx.beginPath();
        ctx.arc(explosion.x, explosion.y, explosion.radius * explosion.time * 2, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.fillStyle = `rgba(239, 68, 68, ${alpha * 0.7})`;
        ctx.beginPath();
        ctx.arc(explosion.x, explosion.y, explosion.radius * explosion.time * 1.5, 0, Math.PI * 2);
        ctx.fill();
      });
    }
    
    // 绘制特效
    function renderEffects() {
      // 添加数据有效性检查
      if (!gameData || !gameData.effects || !Array.isArray(gameData.effects)) {
        console.error('特效数据损坏！', {
          gameDataExists: !!gameData,
          effectsExists: !!gameData?.effects,
          effectsIsArray: Array.isArray(gameData?.effects)
        });
        return;
      }
      
      gameData.effects.forEach(effect => {
        // 检查特效对象是否有效
        if (!effect || typeof effect.x !== 'number' || typeof effect.y !== 'number') {
          console.error('无效的特效对象！', effect);
          return;
        }
        const alpha = 1 - effect.time; // 1秒内从1到0
        
        switch (effect.type) {
          case 'laser':
            ctx.strokeStyle = `rgba(59, 130, 246, ${alpha})`;
            ctx.lineWidth = 4;
            ctx.beginPath();
            ctx.moveTo(effect.x, effect.y);
            ctx.lineTo(effect.x + Math.cos(effect.angle) * effect.length, effect.y + Math.sin(effect.angle) * effect.length);
            ctx.stroke();
            
            // 激光光晕
            ctx.strokeStyle = `rgba(16, 185, 129, ${alpha * 0.5})`;
            ctx.lineWidth = 8;
            ctx.beginPath();
            ctx.moveTo(effect.x, effect.y);
            ctx.lineTo(effect.x + Math.cos(effect.angle) * effect.length, effect.y + Math.sin(effect.angle) * effect.length);
            ctx.stroke();
            break;
            
          case 'ionBeam':
            // 绘制蓝色离子束
            ctx.strokeStyle = `rgba(59, 130, 246, ${alpha})`;
            ctx.lineWidth = 6;
            ctx.beginPath();
            ctx.moveTo(effect.x, effect.y);
            ctx.lineTo(effect.x + Math.cos(effect.angle) * effect.length, effect.y + Math.sin(effect.angle) * effect.length);
            ctx.stroke();
            
            // 离子束光晕
            ctx.strokeStyle = `rgba(147, 197, 253, ${alpha * 0.6})`;
            ctx.lineWidth = 12;
            ctx.beginPath();
            ctx.moveTo(effect.x, effect.y);
            ctx.lineTo(effect.x + Math.cos(effect.angle) * effect.length, effect.y + Math.sin(effect.angle) * effect.length);
            ctx.stroke();
            
            // 离子束粒子效果
            for (let i = 0; i < 5; i++) {
              const particlePos = (i + 1) / 6;
              const particleX = effect.x + Math.cos(effect.angle) * effect.length * particlePos;
              const particleY = effect.y + Math.sin(effect.angle) * effect.length * particlePos;
              
              ctx.fillStyle = `rgba(255, 255, 255, ${alpha})`;
              ctx.beginPath();
              ctx.arc(particleX, particleY, 2 + Math.random() * 2, 0, Math.PI * 2);
              ctx.fill();
            }
            break;
            
          case 'stun':
            ctx.fillStyle = `rgba(245, 158, 11, ${alpha * 0.3})`;
            ctx.beginPath();
            ctx.arc(effect.x, effect.y, effect.size * (0.5 + effect.time * 0.5), 0, Math.PI * 2);
            ctx.fill();
            break;
            
          case 'heal':
            // 绘制治疗效果
            ctx.fillStyle = `rgba(16, 185, 129, ${alpha * 0.4})`;
            ctx.beginPath();
            ctx.arc(effect.x, effect.y, effect.size * (0.3 + effect.time * 0.7), 0, Math.PI * 2);
            ctx.fill();
            
            // 治疗光环
            ctx.strokeStyle = `rgba(34, 197, 94, ${alpha})`;
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.arc(effect.x, effect.y, effect.size * (0.5 + effect.time * 0.5), 0, Math.PI * 2);
            ctx.stroke();
            break;
            
          case 'shield':
            // 绘制护盾效果
            ctx.strokeStyle = `rgba(59, 130, 246, ${alpha * 0.8})`;
            ctx.lineWidth = 4;
            ctx.beginPath();
            ctx.arc(effect.x, effect.y, effect.size * (0.8 + Math.sin(effect.time * 10) * 0.1), 0, Math.PI * 2);
            ctx.stroke();
            
            // 护盾内部光晕
            ctx.fillStyle = `rgba(147, 197, 253, ${alpha * 0.1})`;
            ctx.beginPath();
            ctx.arc(effect.x, effect.y, effect.size * 0.7, 0, Math.PI * 2);
            ctx.fill();
            break;
            
          case 'hit':
            ctx.fillStyle = `rgba(255, 255, 255, ${alpha * 0.5})`;
            ctx.beginPath();
            ctx.arc(effect.x, effect.y, effect.size * 0.3 * (1 + effect.time), 0, Math.PI * 2);
            ctx.fill();
            break;
        }
      });
    }
    
    // 绘制浮动文本
    function renderFloatingTexts() {
      gameData.floatingTexts.forEach(text => {
        const alpha = 1 - text.time; // 1秒内从1到0
        
        ctx.fillStyle = `${text.color}${Math.floor(alpha * 255).toString(16).padStart(2, '0')}`;
        ctx.font = 'bold 16px Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(text.text, text.x, text.y);
      });
    }
    
    // 绘制选中的格子
    function renderSelectedCell() {
      // 绘制加农炮目标选择范围
      if (gameData.isHowitzerTargeting && gameData.selectedTargetCell) {
        const centerX = gameData.gridOffset.x + gameData.selectedTargetCell.x * gameData.cellSize;
        const centerY = gameData.gridOffset.y + gameData.selectedTargetCell.y * gameData.cellSize;
        
        // 绘制7x7范围（半径3）
        ctx.strokeStyle = 'rgba(245, 158, 11, 0.8)';
        ctx.lineWidth = 3;
        ctx.strokeRect(
          centerX - gameData.cellSize * 3, 
          centerY - gameData.cellSize * 3, 
          gameData.cellSize * 7, 
          gameData.cellSize * 7
        );
        
        // 绘制中心格子
        ctx.fillStyle = 'rgba(245, 158, 11, 0.3)';
        ctx.fillRect(
          centerX, 
          centerY, 
          gameData.cellSize, 
          gameData.cellSize
        );
        
        // 绘制中间3x3范围的辅助线
        ctx.strokeStyle = 'rgba(245, 158, 11, 0.5)';
        ctx.lineWidth = 2;
        ctx.strokeRect(
          centerX - gameData.cellSize, 
          centerY - gameData.cellSize, 
          gameData.cellSize * 3, 
          gameData.cellSize * 3
        );
        
        return;
      }
      
      if (!gameData.selectedCell) return;
      
      const x = gameData.gridOffset.x + gameData.selectedCell.x * gameData.cellSize;
      const y = gameData.gridOffset.y + gameData.selectedCell.y * gameData.cellSize;
      
      // 检查是否是禁止放置区域
      if (gameData.blockedCells.has(`${gameData.selectedCell.x},${gameData.selectedCell.y}`)) {
        ctx.strokeStyle = 'rgba(239, 68, 68, 0.8)';
      } else if (gameData.selectedTower && typeof gameData.selectedTower === 'string') {
        // 检查金钱是否足够
        const towerData = gameData.towerTypes.find(t => t.id === gameData.selectedTower);
        if (towerData && gameData.money >= towerData.price) {
          ctx.strokeStyle = 'rgba(16, 185, 129, 0.8)';
          
          // 绘制炮塔预览
          ctx.globalAlpha = 0.5;
          
          switch (towerData.id) {
            case 'energy':
              ctx.fillStyle = '#3B82F6';
              break;
            case 'rapid':
              ctx.fillStyle = '#10B981';
              break;
            case 'ice':
              ctx.fillStyle = '#60A5FA';
              break;
            case 'pierce':
              ctx.fillStyle = '#8B5CF6';
              break;
            case 'laser':
              ctx.fillStyle = '#EC4899';
              break;
            case 'rocket':
              ctx.fillStyle = '#EF4444';
              break;
            case 'electro':
              ctx.fillStyle = '#F59E0B';
              break;
            case 'titan':
              ctx.fillStyle = '#1F2937';
              break;
            case 'sniper':
              ctx.fillStyle = '#4B5563';
              break;
            case 'aa':
              ctx.fillStyle = '#3B82F6';
              break;
            case 'flame':
              ctx.fillStyle = '#F59E0B';
              break;
            case 'howitzer':
              ctx.fillStyle = '#DC2626';
              break;
            case 'toxin':
              ctx.fillStyle = '#10B981';
              break;
            case 'healer':
              ctx.fillStyle = '#10B981';
              break;
          }
          
          ctx.beginPath();
          ctx.arc(x + gameData.cellSize / 2, y + gameData.cellSize / 2, gameData.cellSize / 3, 0, Math.PI * 2);
          ctx.fill();
          
          // 绘制炮管
          ctx.fillStyle = '#1F2937';
          ctx.beginPath();
          ctx.rect(x + gameData.cellSize / 2, y + gameData.cellSize / 2 - 2, gameData.cellSize / 3, 4);
          ctx.fill();
          
          ctx.globalAlpha = 1.0;
          
          // 绘制射程范围
          ctx.strokeStyle = 'rgba(16, 185, 129, 0.3)';
          ctx.lineWidth = 2;
          ctx.setLineDash([5, 5]);
          ctx.beginPath();
          ctx.arc(x + gameData.cellSize / 2, y + gameData.cellSize / 2, towerData.range * gameData.cellSize, 0, Math.PI * 2);
          ctx.stroke();
          ctx.setLineDash([]);
        } else {
          ctx.strokeStyle = 'rgba(239, 68, 68, 0.8)';
        }
      } else if (gameData.selectedAllyType) {
        // 处理单位选择预览
        const allyType = gameData.allyTypes.find(t => t.id === gameData.selectedAllyType);
        if (allyType && gameData.money >= allyType.price) {
          // 检查是否在路径上
          const isOnPath = gameData.path.some(point => point.x === gameData.selectedCell.x && point.y === gameData.selectedCell.y);
          if (isOnPath) {
            // 检查该位置是否已有单位
            const hasExistingAlly = gameData.allies && gameData.allies.some(ally => 
              Math.floor(ally.x) === gameData.selectedCell.x && Math.floor(ally.y) === gameData.selectedCell.y
            );
            
            if (!hasExistingAlly) {
              ctx.strokeStyle = 'rgba(16, 185, 129, 0.8)'; // 绿色边框，表示可以放置
              
              // 绘制单位预览
              ctx.globalAlpha = 0.5;
              
              // 根据单位类型设置不同的颜色
              switch (allyType.id) {
                case 'soldier':
                  ctx.fillStyle = '#3B82F6'; // 蓝色
                  break;
                case 'archer':
                  ctx.fillStyle = '#10B981'; // 绿色
                  break;
                case 'tank':
                  ctx.fillStyle = '#EF4444'; // 红色
                  break;
                case 'healer':
                  ctx.fillStyle = '#EC4899'; // 粉色
                  break;
                case 'mage':
                  ctx.fillStyle = '#8B5CF6'; // 紫色
                  break;
                default:
                  ctx.fillStyle = '#F59E0B'; // 黄色
              }
              
              // 绘制单位圆形
              ctx.beginPath();
              ctx.arc(x + gameData.cellSize / 2, y + gameData.cellSize / 2, gameData.cellSize / 4, 0, Math.PI * 2);
              ctx.fill();
              
              ctx.globalAlpha = 1.0;
            } else {
              ctx.strokeStyle = 'rgba(239, 68, 68, 0.8)'; // 红色边框，表示该位置已有单位
            }
          } else {
            ctx.strokeStyle = 'rgba(239, 68, 68, 0.8)'; // 红色边框，表示不在路径上
          }
        } else {
          ctx.strokeStyle = 'rgba(239, 68, 68, 0.8)'; // 红色边框，表示金钱不足
        }
      } else {
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
      }
      
      ctx.lineWidth = 3;
      ctx.strokeRect(x, y, gameData.cellSize, gameData.cellSize);
    }
    
    // 显示版本号
    console.log('终极塔防 V5.8.2');
    
    // DOM加载完成后初始化游戏
    document.addEventListener('DOMContentLoaded', () => {
      // 初始化音效
      soundManager.init();
      
      // 初始化游戏
      initGame();
      
      // 初始化音量控制
      initVolumeControls();
      
      const versionElement = document.createElement('div');
      versionElement.textContent = 'V5.8.2';
      versionElement.className = 'fixed bottom-2 right-2 text-xs text-gray-400';
      document.body.appendChild(versionElement);
    });
    
    // 初始化音量控制
    function initVolumeControls() {
      // 音乐开关
      const musicToggle = document.getElementById('music-toggle');
      musicToggle.addEventListener('click', () => {
        const enabled = soundManager.toggleMusic();
        if (enabled) {
          musicToggle.classList.remove('muted');
          musicToggle.className = 'fa fa-music audio-toggle';
        } else {
          musicToggle.classList.add('muted');
          musicToggle.className = 'fa fa-music audio-toggle muted';
        }
      });
      
      // 音效开关
      const sfxToggle = document.getElementById('sfx-toggle');
      sfxToggle.addEventListener('click', () => {
        const enabled = soundManager.toggleSfx();
        if (enabled) {
          sfxToggle.classList.remove('muted');
          sfxToggle.className = 'fa fa-volume-up audio-toggle';
        } else {
          sfxToggle.classList.add('muted');
          sfxToggle.className = 'fa fa-volume-off audio-toggle muted';
        }
      });
      
      // 音乐音量滑块
      const musicVolume = document.getElementById('music-volume');
      musicVolume.addEventListener('input', () => {
        soundManager.setMusicVolume(parseFloat(musicVolume.value));
      });
      
      // 音效音量滑块
      const sfxVolume = document.getElementById('sfx-volume');
      sfxVolume.addEventListener('input', () => {
        soundManager.setSfxVolume(parseFloat(sfxVolume.value));
      });
    }
  </script>
  
  <script>
    // 页面加载完成后初始化游戏面板
    document.addEventListener('DOMContentLoaded', function() {
      console.log('初始化游戏面板...');
      
      // 初始化单位购买按钮
      if (typeof initAllyBuyButtons === 'function') {
        initAllyBuyButtons();
        console.log('单位购买按钮初始化完成');
      }
      
      // 初始化炮台购买按钮
      if (typeof initTowerSelection === 'function') {
        initTowerSelection();
        console.log('炮台购买按钮初始化完成');
      }
      
      // 设置炮台购买面板的收起功能
      if (typeof setupTowerPanelToggle === 'function') {
        setupTowerPanelToggle();
        console.log('炮台面板收起功能设置完成');
      }
      
      // 设置单位购买面板的收起功能
      if (typeof setupAllyPanelToggle === 'function') {
        setupAllyPanelToggle();
        console.log('单位面板收起功能设置完成');
      }
    });
  </script>
  <script src="fix-ally-selection.js"></script>
</body>
</html>
